
# Maratona Java Virado No Jiraya - DevDojo Academy

https://www.youtube.com/playlist?list=PL62G310vn6nFIsOCC0H-C2infYgwm8SWW

Créditos: Melhor, maior, e o mais completo curso de Java em português grátis de toda Internet está de volta. Maratona Java Virado No Jiraya. Regravado desde a aula 0, com extrema qualidade, utilizando a última versão do Java, com fonte 22 e fundo branco celestial. FAQ Q. Quem criou? A. O cara com um parafuso a menos que colocou um curso desses gratuito foi esse aqui: https://www.linkedin.com/in/williamsuane/ Q. Quem editou os vídeos? A. O irmão do cara com um parafuso a menos, que também tem um parafuso a menos, já que editou de graça: https://www.linkedin.com/in/wildneisuane/

## <a name="indice">Índice</a>

001. [000 - Maratona Java Virado No Jiraya - Bem-vindo](#parte1)
002. [001 - O que esperar do curso](#parte2)
003. [002 - Como Java Funciona](#parte3)
004. [003 - Fazendo o download da JDK 15](#parte4)
005. [004 - Configurando variaveis de ambiente](#parte5)
006. [005 - Executando compilação manualmente](#parte6)
007. [006 - Download da IDE IntelliJ Community](#parte7)
008. [007 - Conhecendo a IDE IntelliJ Community](#parte8)
009. [008 - Organizando o código em pacotes](#parte9)
010. [009 - Comentários](#parte10)
011. [010 - Tipos primitivos pt 01 - convenções de variáveis](#parte11)
012. [011 - Tipos primitivos pt 02 - declaração e tamanho em memória](#parte12)
013. [012 - Tipos primitivos pt 03 - casting](#parte13)
014. [013 - Tipos primitivos pt 04 - Strings](#parte14)
015. [014 - Tipos primitivos pt 05 - Exercício](#parte15)
016. [015 - Operadores pt 01 - Aritiméticos](#parte16)
017. [016 - Operadores pt 02 - Relacionais](#parte17)
018. [017 - Operadores pt 03 - Lógicos AND](#parte18)
019. [018 - Operadores pt 04 - Lógicos OR](#parte19)
020. [019 - Operadores pt 05 - Atribuição](#parte20)
021. [020 - Estruturas Condicionais pt 01 - IF](#parte21)
022. [021 - Estruturas Condicionais pt 02 - ELSE IF](#parte22)
023. [022 - Estruturas Condicionais pt 03 - Operador ternário](#parte23)
024. [023 - Estruturas Condicionais pt 04 - Tabela Verdade e exercício](#parte24)
025. [024 - Estruturas Condicionais pt 05 - Resolução do exercícios](#parte25)
026. [025 - Estruturas Condicionais pt 06 - Switch](#parte26)
027. [026 - Estruturas Condicionais pt 07 - Switch exercício](#parte27)
028. [027 - Estruturas de Repetição pt 01 - Laços de repetição while, do while, for](#parte28)
029. [028 - Estruturas de Repetição pt 02 - Exercício for](#parte29)
030. [029 - Estruturas de Repetição pt 03 - Break](#parte30)
031. [030 - Estruturas de Repetição pt 04 - Exercício Break](#parte31)
032. [031 - Estruturas de Repetição pt 05 - Continue](#parte32)
033. [032 - Arrays pt 01](#parte33)
034. [033 - Arrays pt 02](#parte34)
035. [034 - Arrays pt 03](#parte35)
036. [035 - Arrays pt 04 - Foreach](#parte36)
037. [036 - Arrays Multidimensionais pt 01](#parte37)
038. [037 - Arrays Multidimensionais pt 02 - Foreach](#parte38)
039. [038 - Arrays Multidimensionais pt 03 - Inicialização](#parte39)
040. [039 - Orientação Objetos pt 01 - Introdução classes pt 01](#parte40)
041. [040 - Orientação Objetos - Introdução classes pt 02](#parte41)
042. [041 - Orientação Objetos - Coesão](#parte42)
043. [042 - Orientação Objetos - Exercício Classes](#parte43)
044. [043 - Orientação Objetos - Referência de objetos](#parte44)
045. [044 - Orientação Objetos - Métodos pt 01](#parte45)
046. [045 - Orientação Objetos - Métodos pt 02 - Parâmetros](#parte46)
047. [046 - Orientação Objetos - Métodos pt 03 - Retorno pt 01](#parte47)
048. [047 - Orientação Objetos - Métodos pt 04 - Retorno pt 02](#parte48)
049. [048 - Orientação Objetos - Métodos pt 05 - Parâmetros tipo primitivo](#parte49)
050. [049 - Orientação Objetos - Métodos pt 06 - Parâmetros tipo referência](#parte50)
051. [050 - Orientação Objetos - Métodos pt 07 - Parâmetros tipo referência pt 02](#parte51)
052. [051 - Orientação Objetos - Métodos pt 08 - Referência this](#parte52)
053. [052 - Orientação Objetos - Métodos pt 09 - Varargs](#parte53)
054. [053 - Orientação Objetos - Métodos pt 10 - Exercise](#parte54)
055. [054 - Orientação Objetos - Modificador de acesso private, get e set pt 01](#parte55)
056. [055 - Orientação Objetos - Modificador de acesso private, get e set pt 02](#parte56)
057. [056 - Orientação Objetos - Modificador de acesso private, get e set pt 03](#parte57)
058. [057 - Orientação Objetos - Sobrecarga de métodos](#parte58)
059. [058 - Orientação Objetos - Construtores pt 01](#parte59)
060. [059 - Orientação Objetos - Construtores pt 02 - Sobrecarga](#parte60)
061. [060 - Orientação Objetos - Blocos de inicialização](#parte61)
062. [061 - Orientação Objetos - Modificador static](#parte62)
063. [062 - Orientação Objetos - Métodos estáticos](#parte63)
064. [063 - Orientação Objetos - Bloco de inicialização estático](#parte64)
065. [064 - Orientação Objetos - Associação pt 01 - Arrays com Objetos](#parte65)
066. [065 - Orientação Objetos - Associação pt 02 - Associação unidirecional um para muitos](#parte66)
067. [066 - Orientação Objetos - Associação pt 03 - Associação unidirecional muitos para um](#parte67)
068. [067 - Orientação Objetos - Associação pt 04 - Associação bidirecional](#parte68)
069. [068 - Orientação Objetos - Leitura de dados pelo console](#parte69)
070. [069 - Orientação Objetos - Exercício leitura de dados do teclado](#parte70)
071. [068 - Orientação Objetos - Leitura de dados pelo console](#parte71)
072. [069 - Orientação Objetos - Exercício leitura de dados do teclado](#parte72)
073. [070 - Orientação Objetos - Associação pt 05 - Exercício Associação](#parte73)
074. [071 - Orientação Objetos - Herança pt 01](#parte74)
075. [072 - Orientação Objetos - Herança pt 02 - Super](#parte75)
076. [073 - Orientação Objetos - Herança pt 03 - protected](#parte76)
077. [074 - Orientação Objetos - Herança pt 04 - Construtores](#parte77)
078. [075 - Orientação Objetos - Herança pt 05 - Sequência de inicialização](#parte78)
079. [076 - Orientação Objetos - Sobrescrita do método toString](#parte79)
080. [077 - Orientação Objetos - Modificador final pt 01 - Tipo primitivo](#parte80)
081. [078 - Orientação Objetos - Modificador final pt 02 - Tipo referência](#parte81)
082. [079 - Orientação Objetos - Modificador final pt 03 - Classes e métodos](#parte82)
083. [080 - Orientação Objetos - Enumeração pt 01 - Introdução](#parte83)
084. [081 - Orientação Objetos - Enumeração pt 02 - Construtores e atributos](#parte84)
085. [082 - Orientação Objetos - Enumeração pt 03 - Sobrescrita de métodos](#parte85)
086. [083 - Orientação Objetos - Enumeração pt 04 - Busca por atributos](#parte86)
087. [084 - Orientação Objetos - Classes abstratas pt 01](#parte87)
088. [085 - Orientação Objetos - Classes abstratas pt 02 - Métodos abstratos](#parte88)
089. [086 - Orientação Objetos - Classes abstratas pt 03 - Métodos abstratos regras](#parte89)
090. [087 - Orientação Objetos - Interfaces pt 01 - Introdução](#parte90)
091. [088 - Orientação Objetos - Interfaces pt 02 - Implementando múltiplas interfaces](#parte91)
092. [089 - Orientação Objetos - Interfaces pt 03 - Atributos e métodos estáticos](#parte92)
093. [090 - Orientação Objetos - Polimorfismo pt 01 - Introdução](#parte93)
094. [091 - Orientação Objetos - Polimorfismo pt 02 - Funcionamento](#parte94)
095. [092 - Orientação Objetos - Polimorfismo pt 03 - Parâmetros polimórficos](#parte95)
096. [093 - Orientação Objetos - Polimorfismo pt 04 - Cast e instanceof](#parte96)
097. [094 - Orientação Objetos - Polimorfismo pt 05 - Programação orientada a interface](#parte97)
098. [095 - Exceções pt 01 - Errors](#parte98)
099. [096 - Exceções pt 02 - RuntimeException](#parte99)
100. [097 - Exceções pt 03 - Exception](#parte100)
101. [098 - Exceções pt 04 - Lançando exceção unchecked](#parte101)
102. [099 - Exceções pt 05 - Lançando exceção checked](#parte102)
103. [100 - Exceções pt 06 - Bloco Finally](#parte103)
104. [101 - Exceções pt 07 - Capturando múltiplas exceções](#parte104)
105. [102 - Exceções pt 08 - Multi catch em linha](#parte105)
106. [103 - Exceções pt 09 - Try with resources](#parte106)
107. [104 - Exceções pt 10 - Exceção customizada](#parte107)
108. [105 - Exceções pt 11 - Exceção e regras de sobrescrita](#parte108)
109. [106 - Classes Utilitárias - Wrappers pt 01](#parte109)
110. [107 - Classes Utilitárias - Wrappers pt 02](#parte110)
111. [108 - Classes Utilitárias - Strings pt 01](#parte111)
112. [109 - Classes Utilitárias - Strings pt 02](#parte112)
113. [110 - Classes Utilitárias - Strings pt 03 - Desempenho](#parte113)
114. [111 - Classes Utilitárias - Strings pt 04 - StringBuilder](#parte114)
115. [112 - Classes Utilitárias - Date](#parte115)
116. [113 - Classes Utilitárias - Calendar](#parte116)
117. [114 - Classes Utilitárias - DateFormat](#parte117)
118. [115 - Classes Utilitárias - Internacionalização Datas com Locale](#parte118)
119. [116 - Classes Utilitárias - Internacionalização Números com Locale](#parte119)
120. [117 - Classes Utilitárias - Internacionalização de moeda com Locale](#parte120)
121. [118 - Classes Utilitárias - SimpleDateFormat](#parte121)
122. [119 - Classes Utilitárias - LocalDate](#parte122)
123. [120 - Classes Utilitárias - LocalTime](#parte123)
124. [121 - Classes Utilitárias - LocalDateTime](#parte124)
125. [122 - Classes Utilitárias - Instant](#parte125)
126. [123 - Classes Utilitárias - Duration](#parte126)
127. [124 - Classes Utilitárias - Period](#parte127)
128. [125 - Classes Utilitárias - ChronoUnit](#parte128)
129. [126 - Classes Utilitárias - TemporalAdjusters](#parte129)
130. [127 - Classes Utilitárias - TemporalAdjuster](#parte130)
131. [128 - Classes Utilitárias - ZonedDateTime, ZoneId, OffsetDateTime](#parte131)
132. [129 - Classes Utilitárias - DateTimeFormatter](#parte132)
133. [130 - Classes Utilitárias - ResourceBundle](#parte133)
134. [131 - Classes Utilitárias - Regex pt 01 - Pattern e Matcher](#parte134)
135. [132 - Classes Utilitárias - Regex pt 02 - Pattern e Matcher - Meta caracteres](#parte135)
136. [133 - Classes Utilitárias - Regex pt 03 - Pattern e Matcher - Range](#parte136)
137. [134 - Classes Utilitárias - Regex pt 04 - Pattern e Matcher - Quantificadores pt 01](#parte137)
138. [135 - Classes Utilitárias - Regex pt 05 - Pattern e Matcher - Quantificadores pt 02](#parte138)
139. [136 - Classes Utilitárias - Regex pt 06 - Pattern e Matcher - Anchor](#parte139)
140. [137 - Classes Utilitárias - Scanner - Tokens e Delimitadores](#parte140)
141. [138 - Classes Utilitárias - IO pt 01 - File](#parte141)
142. [139 - Classes Utilitárias - IO pt 02 - FileWriter](#parte142)
143. [140 - Classes Utilitárias - IO pt 03 - FileReader](#parte143)
144. [141 - Classes Utilitárias - IO pt 04 - BufferedWriter](#parte144)
145. [142 - Classes Utilitárias - IO pt 05 - BufferedReader](#parte145)
146. [143 - Classes Utilitárias - IO pt 06 - File para diretórios](#parte146)
147. [144 - Classes Utilitárias - NIO pt 01 - Path, Paths, Files pt 01](#parte147)
148. [145 - Classes Utilitárias - NIO pt 02 - Path, Paths, Files pt 02](#parte148)
149. [146 - Classes Utilitárias - NIO pt 03 - Normalização](#parte149)
150. [147 - Classes Utilitárias - NIO pt 04 - Resolvendo Paths](#parte150)
151. [148 - Classes Utilitárias - NIO pt 05 - Relativize](#parte151)
152. [149 - Classes Utilitárias - NIO pt 06 - BasicFileAttributes pt 01](#parte152)
153. [150 - Classes Utilitárias - NIO pt 07 - BasicFileAttributes pt 02](#parte153)
154. [151 - Classes Utilitárias - NIO pt 08 - DosFileAttribute](#parte154)
155. [152 - Classes Utilitárias - NIO pt 09 - PosixFileAttributes](#parte155)
156. [153 - Classes Utilitárias - NIO pt 10 - DirectoryStream](#parte156)
157. [154 - Classes Utilitárias - NIO pt 11 - SimpleFileVisitor pt 01](#parte157)
158. [155 - Classes Utilitárias - NIO pt 12 - SimpleFileVisitor pt 02](#parte158)
159. [156 - Classes Utilitárias - NIO pt 13 - PathMatcher pt 01](#parte159)
160. [157 - Classes Utilitárias - NIO pt 14 - PathMatcher pt 02](#parte160)
161. [158 - Classes Utilitárias - NIO pt 15 - ZipOutputStream](#parte161)
162. [159 - Classes Utilitárias - Serialization pt 01](#parte162)
163. [160 - Classes Utilitárias - Serialization pt 02](#parte163)
164. [161 - Coleções pt 01 - equals pt 01](#parte164)
165. [162 - Coleções pt 02 - equals pt 02](#parte165)
166. [163 - Coleções pt 03 - hashCode pt 01](#parte166)
167. [164 - Coleções pt 04 - hashCode pt 02](#parte167)
168. [165 - Coleções pt 05 - Complexidade Big-O](#parte168)
169. [166 - Coleções pt 06 - List pt 01](#parte169)
170. [167 - Coleções pt 07 - List pt 02](#parte170)
171. [168 - Coleções pt 08 - List pt 03](#parte171)
172. [169 - Coleções pt 09 - Sorting lists pt 01](#parte172)
173. [170 - Coleções pt 10 - Sorting lists pt 02 - Comparable](#parte173)
174. [171 - Coleções pt 11 - Sorting lists pt 03 - Comparator](#parte174)
175. [172 - Coleções pt 12 - Binary Search](#parte175)
176. [173 - Coleções pt 13 - Conversão de Lista para Arrays e vice versa](#parte176)
177. [174 - Coleções pt 14 - Iterator](#parte177)
178. [175 - Coleções pt 15 - Set, HashSet](#parte178)
179. [176 - Coleções pt 16 - NavigableSet, TreeSet pt 01](#parte179)
180. [177 - Coleções pt 17 - NavigableSet, TreeSet pt 02](#parte180)
181. [178 - Coleções pt 18 - Map, HashMap, LinkedHashMap pt 01](#parte181)
182. [179 - Coleções pt 19 - Map, HashMap, LinkedHashMap pt 02](#parte182)
183. [180 - Coleções pt 20 - Map, HashMap, LinkedHashMap pt 03](#parte183)
184. [181 - Coleções pt 21 - NavigableMap, TreeMap](#parte184)
185. [182 - Coleções pt 22 - Queue, PriorityQueue](#parte185)
186. [183 - Generics pt 01 - Introdução](#parte186)
187. [184 - Generics pt 02 - Wildcard pt 01](#parte187)
188. [185 - Generics pt 03 - Wildcard pt 02](#parte188)
189. [186 - Generics pt 04 - Classes Genéricas pt 01](#parte189)
190. [187 - Generics pt 05 - Classes Genéricas pt 02](#parte190)
191. [188 - Generics pt 06 - Métodos Genéricos](#parte191)
192. [189 - Classes Internas pt 01 - Classes aninhadas](#parte192)
193. [190 - Classes Internas pt 02 - Classes Locais](#parte193)
194. [191 - Classes Internas pt 03 - Classes Anônimas](#parte194)
195. [192 - Classes Internas pt 04 - Classes aninhadas estáticas](#parte195)
196. [193 - Parametrizando comportamentos pt 01](#parte196)
197. [194 - Parametrizando comportamentos pt 02](#parte197)
198. [195 - Lambdas pt 01 - Predicate](#parte198)
199. [196 - Lambdas pt 02 - Consumer](#parte199)
200. [197 - Lambdas pt 03 - Function](#parte200)
201. [198 - Method Reference pt 01 - Referência a métodos estáticos](#parte201)
202. [199 - Method Reference pt 02 - Referência a métodos não estáticos](#parte202)
203. [200 - Method Reference pt 03 - Referência a construtor](#parte203)
204. [201 - Optional pt 01](#parte204)
205. [202 - Optional pt 02](#parte205)
206. [203 - Streams pt 01 - Introduction pt 01](#parte206)
207. [204 - Streams pt 02 - Introduction pt 02](#parte207)
208. [205 - Streams pt 03 - Introduction pt 03](#parte208)
209. [206 - Streams pt 04 - FlatMap pt 01](#parte209)
210. [207 - Streams pt 05 - FlatMap pt 02](#parte210)
211. [208 - Streams pt 06 - Finding and Matching](#parte211)
212. [209 - Streams pt 07 - Reduce pt 01](#parte212)
213. [210 - Streams pt 08 - Reduce pt 02](#parte213)
214. [211 - Streams pt 09 - Gerando streams pt 01](#parte214)
215. [212 - Streams pt 10 - Gerando streams pt 02](#parte215)
216. [213 - Streams pt 11 - Collectors pt 01 - Summarizing](#parte216)
217. [214 - Streams pt 12 - Collectors pt 02 - Grouping by pt 01](#parte217)
218. [215 - Streams pt 13 - Collectors pt 03 - Grouping by pt 02](#parte218)
219. [216 - Streams pt 14 - Collectors pt 04 - Grouping by pt 03](#parte219)
220. [217 - Streams pt 15 - Collectors pt 05 - Grouping by pt 04](#parte220)
221. [218 - Streams pt 16 - Parallel Streams pt 01](#parte221)
222. [219 - Streams pt 17 - Parallel Streams pt 02](#parte222)
223. [220 - Threads pt 01 - Introduction](#parte223)
224. [221 - Threads pt 02 - Estados das threads](#parte224)
225. [222 - Threads pt 03 - Prioridade e Sleep](#parte225)
226. [223 - Threads pt 04 - Yield e Join](#parte226)
227. [224 - Threads pt 05 - Sincronismo de thread pt 01](#parte227)
228. [225 - Threads pt 06 - Sincronismo de thread pt 02](#parte228)
229. [226 - Threads pt 07 - Sincronismo de thread pt 03 - Classes thread safe](#parte229)
230. [227 - Threads pt 08 - Sincronismo de thread pt 04 - Deadlock](#parte230)
231. [228 - Threads pt 09 - Sincronismo de thread pt 05 - Wait, notify e notifyAll](#parte231)
232. [229 - Concorrência pt 01 - AtomicInteger](#parte232)
233. [230 - Concorrência pt 02 - Lock and ReentrantLock](#parte233)
234. [231 - Concorrência pt 03 - Conditions](#parte234)
235. [232 - Concorrência pt 04 - ReentrantReadWriteLock](#parte235)
236. [233 - Concorrência pt 05 - CopyOnWriteArrayList](#parte236)
237. [234 - Concorrência pt 06 - ArrayBlockingQueue](#parte237)
238. [235 - Concorrência pt 07 - LinkedTransferQueue](#parte238)
239. [236 - Concorrência pt 08 - Executors pt 01 - Thread Pools](#parte239)
240. [237 - Concorrência pt 09 - Executors pt 02 - ScheduledExecutorService](#parte240)
241. [238 - Concorrência pt 10 - Executors pt 03 - Interface Callable](#parte241)
242. [239 - Concorrência pt 11 - Executors pt 04 - Future](#parte242)
243. [240 - Concorrência pt 12 - CompletableFuture pt 01 - get and join](#parte243)
244. [241 - Concorrência pt 13 - CompletableFuture pt 02 - streams](#parte244)
245. [242 - Concorrência pt 14 - CompletableFuture pt 03 - ThreadFactory](#parte245)
246. [243 - Concorrência pt 15 - CompletableFuture pt 04 - Encadeando chamadas pt 01](#parte246)
247. [244 - Concorrência pt 16 - CompletableFuture pt 05 - Encadeando chamadas pt 02](#parte247)
248. [245 - Concorrência pt 17 - CompletableFuture pt 06 - allOf, anyOf](#parte248)
249. [246 - Padrões de Projeto pt 01 - Builder](#parte249)
250. [247 - Padrões de Projeto pt 02 - Factory](#parte250)
251. [248 - Padrões de Projeto pt 03 - Singleton pt 01 - Eager Initialization](#parte251)
252. [249 - Padrões de Projeto pt 04 - Singleton pt 02 - Lazy Initialization](#parte252)
253. [250 - Padrões de Projeto pt 05 - Singleton pt 03 - Singleton with enumeration](#parte253)
254. [251 - Padrões de Projeto pt 06 - Data Transfer Object](#parte254)
255. [252 - JDBC pt 01 - Instalando Docker](#parte255)
256. [253 - JDBC pt 02 - Criando container MySQL](#parte256)
257. [254 - JDBC pt 03 - Instalando Workbench, criando schema e tabelas](#parte257)
258. [255 - JDBC pt 04 - Instalando e adicionando maven ao projeto](#parte258)
259. [256 - JDBC pt 05 - Adicionando dependência e conectando com banco](#parte259)
260. [257 - JDBC pt 06 - Inserindo dados com Statement](#parte260)
261. [258 - JDBC pt 07 - Lombok e Log4J2](#parte261)
262. [259 - JDBC pt 08 - Deletando dados com Statement](#parte262)
263. [260 - JDBC pt 09 - Atualizando dados com Statement](#parte263)
264. [261 - JDBC pt 10 - Buscando dados com ResultSet pt 01 - findAll](#parte264)
265. [262 - JDBC pt 11 - Buscando dados com ResultSet pt 02 - findByName](#parte265)
266. [263 - JDBC pt 12 - ResultSetMetaData](#parte266)
267. [264 - JDBC pt 13 - DatabaseMetaData](#parte267)
268. [265 - JDBC pt 14 - ResultSet.TYPE_SCROLL_INSENSITIVE](#parte268)
269. [266 - JDBC pt 15 - Atualizando registros com ResultSet](#parte269)
270. [267 - JDBC pt 16 - Inserindo e deletando registros com ResultSet](#parte270)
271. [268 - JDBC pt 17 - PreparedStatement pt 01](#parte271)
272. [269 - JDBC pt 18 - PreparedStatement pt 02](#parte272)
273. [270 - JDBC pt 19 - CallableStatement](#parte273)
274. [271 - JDBC pt 20 - Connected RowSet - JdbcRowSet pt 01](#parte274)
275. [272 - JDBC pt 21 - Connected RowSet - JdbcRowSet pt 02](#parte275)
276. [273 - JDBC pt 22 - Disconnected RowSet - CachedRowSet](#parte276)
277. [274 - JDBC pt 23 - Transação](#parte277)
278. [275 - JDBC pt 24 - CRUD pt 01 - findByName and findAll](#parte278)
279. [276 - JDBC pt 25 - CRUD pt 02 - delete](#parte279)
280. [277 - JDBC pt 26 - CRUD pt 03 - save](#parte280)
281. [278 - JDBC pt 27 - CRUD pt 04 - update](#parte281)
282. [279 - JDBC pt 28 - CRUD pt 05 - Anime Crud](#parte282)
283. [280 - Testes unitários com jUnit pt 01](#parte283)
284. [281 - Testes unitários com jUnit pt 02](#parte284)
285. [282 - Atualizando JDK](#parte285)
286. [283 - Record Class](#parte286)
287. [284 - Pattern Matching for instanceof](#parte287)
288. [285 - É só correr pro abraço](#parte288)
---


## <a name="parte1">1 - 000 - Maratona Java Virado No Jiraya - Bem-vindo</a>

https://www.youtube.com/watch?v=VKjFuX91G5Q



[Voltar ao Índice](#indice)

---


## <a name="parte2">2 - 001 - O que esperar do curso</a>

https://www.youtube.com/watch?v=ooCqalwSpuE&list=PL62G310vn6nFIsOCC0H-C2infYgwm8SWW&index=2

[Voltar ao Índice](#indice)

---


## <a name="parte3">3 - 002 - Como Java Funciona</a>

https://www.youtube.com/watch?v=ooCqalwSpuE&list=PL62G310vn6nFIsOCC0H-C2infYgwm8SWW&index=2

[Voltar ao Índice](#indice)

---


## <a name="parte4">4 - 003 - Fazendo o download da JDK 15</a>

https://www.youtube.com/watch?v=Tsyeybeh968&list=PL62G310vn6nFIsOCC0H-C2infYgwm8SWW&index=4

https://www.codejava.net/java-se/java-se-versions-history



[Voltar ao Índice](#indice)

---


## <a name="parte5">5 - 004 - Configurando variaveis de ambiente</a>

https://www.youtube.com/watch?v=xzAESAp_soQ&list=PL62G310vn6nFIsOCC0H-C2infYgwm8SWW&index=5

[Voltar ao Índice](#indice)

---


## <a name="parte6">6 - 005 - Executando compilação manualmente</a>

https://www.youtube.com/watch?v=E64JTsEyXCM&list=PL62G310vn6nFIsOCC0H-C2infYgwm8SWW&index=6

[Voltar ao Índice](#indice)

---


## <a name="parte7">7 - 006 - Download da IDE IntelliJ Community</a>

https://www.youtube.com/watch?v=uB5Qbm-RMyU&list=PL62G310vn6nFIsOCC0H-C2infYgwm8SWW&index=7

[Voltar ao Índice](#indice)

---


## <a name="parte8">8 - 007 - Conhecendo a IDE IntelliJ Community</a>

https://www.youtube.com/watch?v=ds3t9C2A50U&list=PL62G310vn6nFIsOCC0H-C2infYgwm8SWW&index=8

[Voltar ao Índice](#indice)

---


## <a name="parte9">9 - 008 - Organizando o código em pacotes</a>

https://www.youtube.com/watch?v=TnnS-R--WKc&list=PL62G310vn6nFIsOCC0H-C2infYgwm8SWW&index=9

```java
package net.josemalcher;

public class OlaDevDojo {
    public static void main(String[] args) {
        System.out.println("Olá mundo!!");
    }
}

```

[Voltar ao Índice](#indice)

---


## <a name="parte10">10 - 009 - Comentários</a>

https://www.youtube.com/watch?v=2rMT0qRyiYs&list=PL62G310vn6nFIsOCC0H-C2infYgwm8SWW&index=10

[Voltar ao Índice](#indice)

---


## <a name="parte11">11 - 010 - Tipos primitivos pt 01 - convenções de variáveis</a>

https://www.youtube.com/watch?v=RRHGYyJTTpQ&list=PL62G310vn6nFIsOCC0H-C2infYgwm8SWW&index=11


Todos os valores, na verdade, são formados por bits e eles ficam na nossa memória RAM. 
> Um pente de memória RAM de 8gb (64,000,000,000bits).

Cada tipo primitivo utiliza uma quantidade fixa de bits para representar um valor na RAM. 
O tipo 'int' usa 4 bytes para representar números. Isto é, para representar números, o 'int' utiliza 32 dígitos binários (uns e zeros): 00000000000000000000000000000000

Com 32 bits, podemos representar um total de 4 bilhões e alguns milhões (2^32).
Porém, para acomodar tanto números NEGATIVOS quanto POSITIVOS, esse valor é "partido ao meio".
Consequentemente, uma variável do tipo 'int' pode armazenar, aproximadamente, cerca de 2 bilhões e 100 milhões:
int num = 2100000000;
// ou
int num = -2100000000;

Se a gente ultrapassar muito esse valor, teremos erro:
int num = 2800000000; // error

->> Esse erro ocorre porque o valor '2800000000' exige mais bits para ser representado.
E para resolver essa questão, temos o tipo 'long'. O 'long' utiliza 8 bytes (64 bits) para armazenar valores, então, se precisarmos armazenar o número '2800000000', usaremos o tipo 'long' e não o 'int'

Além disso, temos o 'byte' e o 'short'. Não vou me prolongar muito na explicação, então vou abordar apenas o tipo 'byte'.
O 'byte' utiliza apenas 1 byte (8 bits - 00000000) para representar um valor. Portanto, variáveis do tipo 'byte' são usadas para armazenar valores muito pequenos, por exemplo:
byte numzinho = 100 

Se tentarmos armazenar o valor de 200 numa variável do tipo 'byte', teremos um erro, já que o 200 requer mais bits para ser representado

FONTE: Comentário do vídeo

Resumo

#### ✅ Tipos Primitivos em Java

Java possui **8 tipos primitivos**, que são a base para representar dados simples:

```
| Tipo      | Tamanho      | Exemplo de uso                          |
|-----------|--------------|-----------------------------------------|
| `byte`    | 8 bits       | Armazena números pequenos (-128 a 127)  |
| `short`   | 16 bits      | Números inteiros maiores que `byte`     |
| `int`     | 32 bits      | Mais usado para números inteiros        |
| `long`    | 64 bits      | Números inteiros muito grandes          |
| `float`   | 32 bits      | Números decimais com menos precisão     |
| `double`  | 64 bits      | Números decimais com mais precisão      |
| `char`    | 16 bits      | Um único caractere (ex: 'A', '9')       |
| `boolean` | 1 bit (lógico) | Verdadeiro ou falso (`true` ou `false`) |
```
---

## 📝 Convenções de Variáveis em Java

Java é **case-sensitive** e segue algumas convenções de nomeação (não obrigatórias, mas boas práticas):

- **camelCase** para nomes de variáveis e métodos:
  ```java
  int idadeDoUsuario;
  boolean isAtivo;
  ```

- **UPPER_CASE** para constantes:
  ```java
  final int MAX_TENTATIVAS = 3;
  ```

- **Nomes claros e significativos** (evitar `x`, `y`, `z`, a não ser em exemplos matemáticos):
  ```java
  double salarioMensal;
  ```

- **Não usar palavras reservadas** como nome de variável (`int`, `class`, `public`, etc).


FONTE: CHATGPT


[Voltar ao Índice](#indice)

---


## <a name="parte12">12 - 011 - Tipos primitivos pt 02 - declaração e tamanho em memória</a>

https://www.youtube.com/watch?v=veDgI_zZ7uk&list=PL62G310vn6nFIsOCC0H-C2infYgwm8SWW&index=12

Declaração de variáveis primitivas: Como declarar e inicializar variáveis dos tipos byte, short, int, long, float, double, char e boolean.​
Universidade Java

Tamanho em memória: Discussão sobre o espaço que cada tipo primitivo ocupa na memória, por exemplo:

byte: 1 byte (8 bits)

short: 2 bytes (16 bits)

int: 4 bytes (32 bits)

long: 8 bytes (64 bits)

float: 4 bytes (32 bits)

double: 8 bytes (64 bits)

char: 2 bytes (16 bits)

boolean: 1 bit (valor lógico true ou false)​

Importância da escolha do tipo adequado: Explicação sobre como a escolha correta do tipo primitivo pode impactar na performance e no uso eficiente da memória.​

📌 Observações
A aula enfatiza a importância de entender os tipos primitivos para uma programação eficiente e eficaz em Java.​

FONTE: CHATGPT

https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html

[Voltar ao Índice](#indice)

---


## <a name="parte13">13 - 012 - Tipos primitivos pt 03 - casting</a>

https://www.youtube.com/watch?v=74hd4o7V328&list=PL62G310vn6nFIsOCC0H-C2infYgwm8SWW&index=13

## 🧠 CAST de Tipos Primitivos em Java

### ✅ O que é *Cast*?

O **casting** (ou conversão de tipos) é o processo de **converter um valor de um tipo primitivo para outro**. Existem dois tipos de cast em Java:

- **Casting implícito (widening cast):** Quando convertendo de um tipo menor para um tipo maior.
- **Casting explícito (narrowing cast):** Quando convertendo de um tipo maior para um tipo menor. Nesse caso, você precisa informar a conversão de forma explícita.

---

### 📈 Casting Implícito (Widening)

Não precisa de código adicional. Acontece quando não há risco de perda de dados.

```java
int num = 10;
long numeroMaior = num; // int -> long (OK)
double numeroDecimal = numeroMaior; // long -> double (OK)

System.out.println(numeroDecimal); // Saída: 10.0
```

#### ✅ Por que funciona?
O tipo `long` pode armazenar todos os valores possíveis de um `int`, e o `double` pode armazenar todos os valores possíveis de um `long`.

---

### 📉 Casting Explícito (Narrowing)

Precisa de conversão manual porque há risco de perda de dados.

```java
double valorDecimal = 10.99;
int valorInteiro = (int) valorDecimal; // double -> int

System.out.println(valorInteiro); // Saída: 10
```

#### ⚠️ Cuidado!
Nesse exemplo, **o valor após o ponto é perdido**.

---

### 🎯 Exemplo com perda de dados

```java
int valorGrande = 130;
byte valorPequeno = (byte) valorGrande; // int -> byte

System.out.println(valorPequeno); // Saída: -126
```

> `byte` vai de -128 a 127. Como `130` está fora desse intervalo, o valor é "reciclado" e vira -126.

---

### 🧪 Comparação entre tipos e conversão

| De         | Para       | Precisa de Cast? | Risco de perda? |
|------------|------------|------------------|-----------------|
| byte       | short      | Não              | Não             |
| int        | long       | Não              | Não             |
| long       | int        | Sim              | Sim             |
| double     | float      | Sim              | Sim             |
| float      | double     | Não              | Não             |
| char       | int        | Não              | Não             |
| int        | char       | Sim              | Sim             |

---

### 💡 Dica de ouro

Sempre que você estiver **reduzindo o tamanho do tipo**, pense:  
> “Estou avisando ao Java que **eu assumo o risco de perda de dados**”.

---

FONTE: CHATGPT

[Voltar ao Índice](#indice)

---


## <a name="parte14">14 - 013 - Tipos primitivos pt 04 - Strings</a>

https://www.youtube.com/watch?v=13VfcFXwsjw&list=PL62G310vn6nFIsOCC0H-C2infYgwm8SWW&index=14

iturn0image0turn0image1turn0image3turn0image5Claro! Aqui está um resumo em formato Markdown da aula **"13 - Tipos Primitivos pt 04 - Strings"** do curso Maratona Java do DevDojo, complementado com explicações e exemplos práticos:

---

# Aula 13 – Tipos Primitivos pt 04: Strings

📺 **Link do vídeo:** [Assista no YouTube](https://www.youtube.com/watch?v=13VfcFXwsjw)

### 🧠 Conteúdo Abordado

Nesta aula, o instrutor William Suane introduz o tipo `String` em Java, destacando que, embora não seja um tipo primitivo, é amplamente utilizado e possui características especiais. Os principais pontos abordados incluem:

- **Declaração e inicialização de Strings:**
  ```java
  String nome = "DevDojo";
  ```
 
Aqui, a variável `nome` é uma referência a um objeto do tipo `String` contendo o valor `"DevDojo".

- **Imutabilidade das Strings:**
 Em Java, as Strings são objetos imutáveis. Isso significa que, uma vez criada, uma `String` não pode ser alterada. Qualquer operação que pareça modificar uma `String` na verdade cria uma nova instânci.

- **Concatenação de Strings:**
 A aula demonstra como concatenar Strings utilizando o operador `+:
  ```java
  String saudacao = "Olá, ";
  String nome = "Mundo!";
  String mensagem = saudacao + nome;
  System.out.println(mensagem); // Saída: Olá, Mundo!
  ```


- **Uso de caracteres especiais:**
 Para incluir caracteres especiais em Strings, utiliza-se a barra invertida (`\`) como caractere de escap:
  ```java
  String texto = "Ele disse: \"Java é incrível!\"";
  System.out.println(texto); // Saída: Ele disse: "Java é incrível!"
  ```


---

### 📚 Complemento: Métodos Comuns da Classe String

Além dos conceitos abordados na aula, é importante conhecer alguns métodos úteis da classe `String`:

- **`length()`**: Retorna o comprimento da Strig.
  ```java
  String texto = "Java";
  int tamanho = texto.length(); // tamanho = 4
  ```


- **`toUpperCase()` e `toLowerCase()`**: Convertem a String para letras maiúsculas ou minúsculas, respectivamene.
  ```java
  String original = "DevDojo";
  String maiuscula = original.toUpperCase(); // "DEVDOJO"
  String minuscula = original.toLowerCase(); // "devdojo"
  ```


- **`substring(int beginIndex, int endIndex)`**: Retorna uma nova String que é uma subsequência da originl.
  ```java
  String texto = "Maratona Java";
  String parte = texto.substring(9, 13); // "Java"
  ```


- **`equals(String anotherString)`**: Compara o conteúdo de duas Strins.
  ```java
  String a = "Java";
  String b = "java";
  boolean iguais = a.equals(b); // false
  ```


- **`equalsIgnoreCase(String anotherString)`**: Compara o conteúdo de duas Strings, ignorando diferenças entre maiúsculas e minúsculs.
  ```java
  boolean iguaisIgnorandoCase = a.equalsIgnoreCase(b); // true
  ```


- **`trim()`**: Remove espaços em branco do início e do fim da Strig.
  ```java
  String texto = "  DevDojo  ";
  String ajustado = texto.trim(); // "DevDojo"
  ```


---

## 🔍 Observações Importantes
- Embora `String` não seja um tipo primitivo, é tratado de forma especial em Java devido à sua ampla utilizaão.
- A imutabilidade das Strings é uma característica que oferece segurança e facilita o uso em ambientes concorrentes, mas pode impactar a performance em operações intensivas de concatenação. Nesses casos, é recomendável utilizar classes como `StringBuilder` ou `StringBuffr`.

---


[Voltar ao Índice](#indice)

---


## <a name="parte15">15 - 014 - Tipos primitivos pt 05 - Exercício</a>

https://www.youtube.com/watch?v=Q0REhCVBvAg&list=PL62G310vn6nFIsOCC0H-C2infYgwm8SWW&index=15



[Voltar ao Índice](#indice)

---


## <a name="parte16">16 - 015 - Operadores pt 01 - Aritiméticos</a>

https://www.youtube.com/watch?v=1Fsvlted69g&list=PL62G310vn6nFIsOCC0H-C2infYgwm8SWW&index=16

# Aula 15 – Operadores pt 01: Aritméticos

## 🧠 Conteúdo Abordado

Nesta aula, o instrutor William Suane introduz os operadores aritméticos em Java, que são utilizados para realizar operações matemáticas básicas. Os principais operadores abordados incluem:

- **Adição (`+`)**: Soma dois valores.
- **Subtração (`-`)**: Subtrai o segundo valor do primeiro.
- **Multiplicação (`*`)**: Multiplica dois valores.
- **Divisão (`/`)**: Divide o primeiro valor pelo segundo.
- **Módulo (`%`)**: Retorna o resto da divisão do primeiro valor pelo segundo.

## 📝 Exemplos Práticos

```java
int a = 10;
int b = 3;

int soma = a + b;          // 13
int subtracao = a - b;     // 7
int multiplicacao = a * b; // 30
int divisao = a / b;       // 3
int modulo = a % b;        // 1

System.out.println("Soma: " + soma);
System.out.println("Subtração: " + subtracao);
System.out.println("Multiplicação: " + multiplicacao);
System.out.println("Divisão: " + divisao);
System.out.println("Módulo: " + modulo);
```

## ⚠️ Observações Importantes

- **Divisão entre inteiros**: Ao dividir dois números inteiros, o resultado também será um número inteiro, descartando qualquer parte decimal.
- **Divisão por zero**: Tentar dividir um número inteiro por zero resultará em uma exceção (`ArithmeticException`).
- **Uso do módulo**: O operador `%` é útil para determinar se um número é par ou ímpar, entre outras aplicações.

---

## 📚 Complemento: Precedência de Operadores

Em expressões com múltiplos operadores, a ordem de execução segue a precedência dos operadores:

1. Multiplicação (`*`), Divisão (`/`) e Módulo (`%`)
2. Adição (`+`) e Subtração (`-`)

Operadores com a mesma precedência são avaliados da esquerda para a direita.

### 🧪 Exemplo de Precedência

```java
int resultado = 10 + 5 * 2; // Resultado: 20
```

Neste exemplo, a multiplicação é realizada antes da adição.

Para alterar a ordem de execução, utilize parênteses:

```java
int resultado = (10 + 5) * 2; // Resultado: 30
```


[Voltar ao Índice](#indice)

---


## <a name="parte17">17 - 016 - Operadores pt 02 - Relacionais</a>

# Aula 16 – Operadores pt 02: Relacionais

📺 **Link do vídeo:** [Assista no YouTube](https://www.youtube.com/watch?v=U390IaCtOUk)

## 🧠 Conteúdo Abordado

Nesta aula, o instrutor William Suane apresenta os **operadores relacionais** em Java, que são utilizados para comparar dois valores e retornam um resultado booleano (`true` ou `false`).

### 🔎 Operadores Relacionais em Java

| Operador | Descrição         | Exemplo (`a = 10`, `b = 20`) |
|----------|-------------------|------------------------------|
| `==`     | Igual a           | `a == b` → `false`           |
| `!=`     | Diferente de      | `a != b` → `true`            |
| `>`      | Maior que         | `a > b` → `false`            |
| `<`      | Menor que         | `a < b` → `true`             |
| `>=`     | Maior ou igual a  | `a >= b` → `false`           |
| `<=`     | Menor ou igual a  | `a <= b` → `true`            |

Esses operadores são frequentemente utilizados em estruturas de controle, como `if`, `else if`, `while` e `for`, para tomar decisões baseadas em comparações.

### 📝 Exemplos Práticos

```java
int idade = 18;

if (idade >= 18) {
    System.out.println("Você é maior de idade.");
} else {
    System.out.println("Você é menor de idade.");
}
```

```java
int numero1 = 10;
int numero2 = 20;

System.out.println(numero1 == numero2); // false
System.out.println(numero1 != numero2); // true
System.out.println(numero1 > numero2);  // false
System.out.println(numero1 < numero2);  // true
```

---

## 📚 Complemento: Comparação de Strings

Em Java, para comparar o conteúdo de duas strings, deve-se utilizar o método `.equals()`, pois o operador `==` verifica se as referências apontam para o mesmo objeto na memória.

```java
String nome1 = "Java";
String nome2 = "Java";

System.out.println(nome1 == nome2);       // true (pode ser true devido ao pool de strings)
System.out.println(nome1.equals(nome2));  // true

String nome3 = new String("Java");
System.out.println(nome1 == nome3);       // false
System.out.println(nome1.equals(nome3));  // true
```

---

## ⚠️ Observações Importantes

- **Resultado Booleano:** Todos os operadores relacionais retornam um valor do tipo `boolean`.

- **Comparação de Tipos Diferentes:** Ao comparar tipos diferentes, o Java realiza a promoção de tipos para fazer a comparação.

- **Uso em Estruturas de Controle:** São amplamente utilizados em estruturas como `if`, `while`, `for`, entre outras, para controlar o fluxo do programa com base em condições.


[Voltar ao Índice](#indice)

---


## <a name="parte18">18 - 017 - Operadores pt 03 - Lógicos AND</a>


# Aula 17 – Operadores pt 03: Lógicos AND (`&&`)

📺 **Link do vídeo:** [Assista no YouTube](https://www.youtube.com/watch?v=cT6sw-Pw4l0)

## 🧠 Conteúdo Abordado

Nesta aula, o instrutor William Suane apresenta o operador lógico **AND (`&&`)** em Java, que é utilizado para combinar duas expressões booleanas. O resultado será `true` apenas se **ambas** as expressões forem verdadeiras.

### 🔎 Operador Lógico AND (`&&`)

- **Definição:** O operador `&&` retorna `true` se **ambas** as expressões forem verdadeiras; caso contrário, retorna `false`.

- **Curto-circuito:** O operador `&&` é conhecido por seu comportamento de curto-circuito. Isso significa que, se a primeira expressão for `false`, a segunda expressão **não será avaliada**, pois o resultado final já será `false`.

## 📝 Exemplos Práticos

```java
int idade = 25;
float salario = 3500.0f;

boolean isAprovado = idade >= 18 && salario >= 3000;
System.out.println("Aprovado? " + isAprovado); // true
```

```java
int idade = 16;
float salario = 4000.0f;

boolean isAprovado = idade >= 18 && salario >= 3000;
System.out.println("Aprovado? " + isAprovado); // false
```

## ⚠️ Observações Importantes

- **Avaliação Condicional:** Devido ao comportamento de curto-circuito, é possível evitar erros em certas situações. Por exemplo:

```java
int x = 0;
if (x != 0 && (10 / x) > 1) {
    System.out.println("Condição verdadeira");
}
```

Neste exemplo, a segunda condição `(10 / x) > 1` **não será avaliada** se `x != 0` for `false`, evitando assim uma divisão por zero.

## 📚 Complemento: Operadores Lógicos em Java

Além do operador `&&`, Java possui outros operadores lógicos:

- `||` (OR lógico): Retorna `true` se **pelo menos uma** das expressões for verdadeira.
- `!` (NOT lógico): Inverte o valor lógico da expressão.
- `^` (XOR lógico): Retorna `true` se **apenas uma** das expressões for verdadeira.

### 🧪 Exemplo com `||`:

```java
boolean temCarteira = true;
boolean temIdade = false;

if (temCarteira || temIdade) {
    System.out.println("Pode dirigir");
} else {
    System.out.println("Não pode dirigir");
}
```

[Voltar ao Índice](#indice)

---


## <a name="parte19">19 - 018 - Operadores pt 04 - Lógicos OR</a>


# Aula 18 – Operadores pt 04: Lógicos OR (`||`)

📺 **Link do vídeo:** [Assista no YouTube](https://www.youtube.com/watch?v=ELcO4DN7lxw)

## 🧠 Conteúdo Abordado

Nesta aula, o instrutor William Suane apresenta o operador lógico **OR (`||`)** em Java, que é utilizado para combinar duas expressões booleanas. O resultado será `true` se **pelo menos uma** das expressões for verdadeira.

### 🔎 Operador Lógico OR (`||`)

- **Definição:** O operador `||` retorna `true` se **pelo menos uma** das expressões for verdadeira; retorna `false` somente se **ambas** forem falsas.

- **Curto-circuito:** O operador `||` possui comportamento de curto-circuito. Isso significa que, se a primeira expressão for `true`, a segunda expressão **não será avaliada**, pois o resultado final já será `true`.

## 📝 Exemplos Práticos

```java
int idade = 16;
float salario = 4000.0f;

boolean isAprovado = idade >= 18 || salario >= 3000;
System.out.println("Aprovado? " + isAprovado); // true
```

```java
int idade = 16;
float salario = 2500.0f;

boolean isAprovado = idade >= 18 || salario >= 3000;
System.out.println("Aprovado? " + isAprovado); // false
```

## ⚠️ Observações Importantes

- **Avaliação Condicional:** Devido ao comportamento de curto-circuito, é possível evitar erros em certas situações. Por exemplo:

```java
String texto = null;
if (texto != null || texto.length() > 0) {
    System.out.println("Texto válido");
}
```

Neste exemplo, a segunda condição `texto.length() > 0` **não será avaliada** se `texto != null` for `true`, evitando assim um `NullPointerException`.

## 📚 Complemento: Operadores Lógicos em Java

Além do operador `||`, Java possui outros operadores lógicos:

- `&&` (AND lógico): Retorna `true` se **ambas** as expressões forem verdadeiras.
- `!` (NOT lógico): Inverte o valor lógico da expressão.
- `^` (XOR lógico): Retorna `true` se **apenas uma** das expressões for verdadeira.

### 🧪 Exemplo com `&&`:

```java
boolean temCarteira = true;
boolean temIdade = false;

if (temCarteira && temIdade) {
    System.out.println("Pode dirigir");
} else {
    System.out.println("Não pode dirigir");
}
```


[Voltar ao Índice](#indice)

---


## <a name="parte20">20 - 019 - Operadores pt 05 - Atribuição</a>

# Aula 19 – Operadores pt 05: Atribuição

📺 **Link do vídeo:** [Assista no YouTube](https://www.youtube.com/watch?v=EFrq1WxsL1k)

## 🧠 Conteúdo Abordado

Nesta aula, o instrutor William Suane apresenta os **operadores de atribuição** em Java, que são utilizados para atribuir valores a variáveis. Existem dois tipos principais:

### 🔹 Atribuição Simples (`=`)

- **Definição:** Atribui o valor da expressão à direita para a variável à esquerda.
- **Exemplo:**

  ```java
  int idade = 25;
  String nome = "João";
  double salario = 3500.50;
  ```

### 🔹 Atribuição Composta

- **Definição:** Combina um operador aritmético com a atribuição, simplificando expressões.
- **Operadores Comuns:**

  | Operador | Equivalente a     | Exemplo             |
  |----------|-------------------|---------------------|
  | `+=`     | `x = x + y`       | `x += y;`           |
  | `-=`     | `x = x - y`       | `x -= y;`           |
  | `*=`     | `x = x * y`       | `x *= y;`           |
  | `/=`     | `x = x / y`       | `x /= y;`           |
  | `%=`     | `x = x % y`       | `x %= y;`           |

- **Exemplo:**

  ```java
  int x = 10;
  x += 5; // x agora é 15
  x *= 2; // x agora é 30
  ```

## ⚠️ Observações Importantes

- **Tipo de Dados:** O tipo da expressão à direita deve ser compatível com o tipo da variável à esquerda.
- **Atribuição Múltipla:** É possível realizar atribuições encadeadas:

  ```java
  int a, b, c;
  a = b = c = 100;
  ```

  Neste exemplo, todas as variáveis `a`, `b` e `c` receberão o valor `100`.

## 📚 Complemento: Operadores de Atribuição Bit a Bit

Além dos operadores mencionados, Java possui operadores de atribuição bit a bit:

| Operador | Descrição                 | Exemplo             |
|----------|---------------------------|---------------------|
| `&=`     | AND bit a bit e atribui   | `x &= y;`           |
| `|=`     | OR bit a bit e atribui    | `x |= y;`           |
| `^=`     | XOR bit a bit e atribui   | `x ^= y;`           |
| `<<=`    | Desloca bits à esquerda   | `x <<= 2;`          |
| `>>=`    | Desloca bits à direita    | `x >>= 2;`          |
| `>>>=`   | Desloca bits à direita sem sinal | `x >>>= 2;`    |

Esses operadores são úteis em operações de baixo nível, como manipulação de bits e desenvolvimento de sistemas embarcados.


[Voltar ao Índice](#indice)

---


## <a name="parte21">21 - 020 - Estruturas Condicionais pt 01 - IF</a>

# Aula 20 – Estruturas Condicionais pt 01: IF

📺 **Link do vídeo:** [Assista no YouTube](https://www.youtube.com/watch?v=gk1_Pn8GZA4)

## 🧠 Conteúdo Abordado

Nesta aula, o instrutor William Suane apresenta a estrutura condicional **`if`** em Java, que permite executar blocos de código com base em condições booleanas.

### 🔹 Estrutura do `if`

- **Definição:** O `if` é utilizado para verificar se uma condição é verdadeira. Se for, o bloco de código dentro do `if` é executado.

- **Sintaxe:**

  ```java
  if (condição) {
      // bloco de código a ser executado se a condição for verdadeira
  }
  ```

### 🔹 Exemplo Prático

```java
int idade = 18;

if (idade >= 18) {
    System.out.println("Você é maior de idade.");
}
```

Neste exemplo, a mensagem será exibida apenas se a variável `idade` for maior ou igual a 18.

## ⚠️ Observações Importantes

- **Avaliação de Condições:** A condição dentro do `if` deve resultar em um valor booleano (`true` ou `false`).

- **Uso de Chaves `{}`:** Embora não seja obrigatório usar chaves `{}` quando há apenas uma instrução dentro do `if`, é uma boa prática utilizá-las para melhorar a legibilidade e evitar erros.

  ```java
  // Sem chaves - válido, mas não recomendado
  if (idade >= 18)
      System.out.println("Maior de idade.");

  // Com chaves - recomendado
  if (idade >= 18) {
      System.out.println("Maior de idade.");
  }
  ```

## 📚 Complemento: Estruturas Condicionais em Java

Além do `if`, Java oferece outras estruturas condicionais:

- **`if-else`:** Executa um bloco de código se a condição for verdadeira e outro bloco se for falsa.

  ```java
  if (condição) {
      // bloco se condição for verdadeira
  } else {
      // bloco se condição for falsa
  }
  ```

- **`if-else if-else`:** Permite verificar múltiplas condições em sequência.

  ```java
  if (condição1) {
      // bloco se condição1 for verdadeira
  } else if (condição2) {
      // bloco se condição2 for verdadeira
  } else {
      // bloco se nenhuma condição anterior for verdadeira
  }
  ```

- **`switch`:** Ideal para verificar a igualdade de uma variável contra múltiplos valores.

  ```java
  switch (variável) {
      case valor1:
          // bloco para valor1
          break;
      case valor2:
          // bloco para valor2
          break;
      default:
          // bloco se nenhum caso anterior for correspondente
  }
  ```


[Voltar ao Índice](#indice)

---


## <a name="parte22">22 - 021 - Estruturas Condicionais pt 02 - ELSE IF</a>

# Aula 21 – Estruturas Condicionais pt 02: ELSE IF

📺 **Link do vídeo:** [Assista no YouTube](https://www.youtube.com/watch?v=exxeNsgcg3c)

## 🧠 Conteúdo Abordado

Nesta aula, o instrutor William Suane apresenta a estrutura condicional **`else if`** em Java, que permite verificar múltiplas condições em sequência. Essa estrutura é útil quando há mais de duas possibilidades a serem avaliadas.

### 🔹 Estrutura do `if-else if-else`

- **Definição:** Permite testar várias condições em sequência. A primeira condição verdadeira terá seu bloco de código executado, e as demais serão ignoradas.

- **Sintaxe:**

  ```java
  if (condição1) {
      // bloco de código se condição1 for verdadeira
  } else if (condição2) {
      // bloco de código se condição2 for verdadeira
  } else {
      // bloco de código se nenhuma das condições anteriores for verdadeira
  }
  ```

### 🔹 Exemplo Prático

```java
int nota = 85;

if (nota >= 90) {
    System.out.println("Excelente");
} else if (nota >= 75) {
    System.out.println("Bom");
} else if (nota >= 60) {
    System.out.println("Regular");
} else {
    System.out.println("Reprovado");
}
```

Neste exemplo, a variável `nota` é avaliada em diferentes faixas, e a mensagem correspondente é exibida com base na condição satisfeita.

## ⚠️ Observações Importantes

- **Ordem das Condições:** As condições devem ser organizadas da mais restritiva para a mais abrangente para evitar que condições mais gerais sejam avaliadas antes das específicas.

- **Avaliação Sequencial:** Assim que uma condição é satisfeita, as demais não são avaliadas. Portanto, a ordem das condições é crucial.

## 📚 Complemento: Estrutura `if-else if` em Java

- A estrutura `if-else if` é conhecida como "if-else-if ladder" em Java. Ela permite que o programa escolha entre várias alternativas com base em diferentes condições.

- É uma alternativa ao uso de múltiplas estruturas `if-else` aninhadas, proporcionando um código mais limpo e legível.


[Voltar ao Índice](#indice)

---


## <a name="parte23">23 - 022 - Estruturas Condicionais pt 03 - Operador ternário</a>


# Aula 22 – Estruturas Condicionais pt 03: Operador Ternário

📺 **Link do vídeo:** [Assista no YouTube](https://www.youtube.com/watch?v=gU-qCpBC5jk)

## 🧠 Conteúdo Abordado

Nesta aula, o instrutor William Suane apresenta o **operador ternário** em Java, uma forma concisa de escrever expressões condicionais simples, substituindo estruturas `if-else` em uma única linha.

### 🔹 Sintaxe do Operador Ternário

```java
condição ? expressão_se_verdadeiro : expressão_se_falso;
```

- **condição**: Uma expressão que retorna `true` ou `false`.
- **expressão_se_verdadeiro**: Executada se a condição for verdadeira.
- **expressão_se_falso**: Executada se a condição for falsa.

### 🔹 Exemplo Prático

```java
int idade = 18;
String mensagem = (idade >= 18) ? "Você é maior de idade." : "Você é menor de idade.";
System.out.println(mensagem);
```

Neste exemplo, a variável `mensagem` recebe um valor com base na condição `idade >= 18`.

### 🔹 Comparação com `if-else`

```java
// Usando if-else
if (idade >= 18) {
    mensagem = "Você é maior de idade.";
} else {
    mensagem = "Você é menor de idade.";
}

// Usando operador ternário
mensagem = (idade >= 18) ? "Você é maior de idade." : "Você é menor de idade.";
```

Ambas as abordagens produzem o mesmo resultado, mas o operador ternário oferece uma sintaxe mais enxuta.

## ⚠️ Observações Importantes

- **Legibilidade**: O operador ternário é ideal para condições simples. Para lógica mais complexa, o uso de `if-else` é recomendado para manter a clareza do código.
- **Tipo de Retorno**: As expressões `expressão_se_verdadeiro` e `expressão_se_falso` devem retornar valores compatíveis com o tipo da variável que receberá o resultado.
- **Aninhamento**: É possível aninhar operadores ternários, mas isso pode comprometer a legibilidade do código.

### 🔹 Exemplo de Aninhamento

```java
int nota = 85;
String resultado = (nota >= 90) ? "Excelente" :
                   (nota >= 75) ? "Bom" :
                   (nota >= 60) ? "Regular" : "Reprovado";
System.out.println("Desempenho: " + resultado);
```

Neste exemplo, múltiplas condições são avaliadas em sequência para determinar o desempenho com base na nota.

## 📚 Complemento: Quando Usar o Operador Ternário

- **Atribuições Simples**: Ideal para atribuir valores a variáveis com base em uma condição.

  ```java
  int numero = 10;
  String paridade = (numero % 2 == 0) ? "Par" : "Ímpar";
  ```

- **Retorno de Métodos**: Pode ser utilizado para retornar valores diretamente de métodos.

  ```java
  public String verificarIdade(int idade) {
      return (idade >= 18) ? "Maior de idade" : "Menor de idade";
  }
  ```

- **Evitar Uso Excessivo**: Para condições complexas ou múltiplas, prefira estruturas `if-else` para manter a legibilidade.


[Voltar ao Índice](#indice)

---


## <a name="parte24">24 - 023 - Estruturas Condicionais pt 04 - Tabela Verdade e exercício</a>

# Aula 23 – Estruturas Condicionais pt 04: Tabela Verdade e Exercício

📺 **Link do vídeo:** [Assista no YouTube](https://www.youtube.com/watch?v=Y3ODYE3npgo)

## 🧠 Conteúdo Abordado

Nesta aula, o instrutor William Suane apresenta a **tabela verdade** dos operadores lógicos `&&` (E lógico) e `||` (OU lógico) em Java, além de propor um exercício prático para fixar o conhecimento.

### 🔹 Tabela Verdade dos Operadores Lógicos

#### Operador `&&` (E lógico)

| Condição 1 | Condição 2 | Resultado |
|------------|------------|-----------|
| false      | false      | false     |
| false      | true       | false     |
| true       | false      | false     |
| true       | true       | true      |

- **Comportamento:** O resultado é `true` apenas se **ambas** as condições forem verdadeiras.

#### Operador `||` (OU lógico)

| Condição 1 | Condição 2 | Resultado |
|------------|------------|-----------|
| false      | false      | false     |
| false      | true       | true      |
| true       | false      | true      |
| true       | true       | true      |

- **Comportamento:** O resultado é `true` se **pelo menos uma** das condições for verdadeira.

### 🔹 Exercício Proposto

**Objetivo:** Determinar se um funcionário pode receber auxílio com base em seu salário e dependentes.

**Critérios:**

- **Salário Baixo:** Salário menor que R$ 2000.00
- **Muitos Dependentes:** Mais de 2 dependentes

**Implementação:**

```java
public class Auxilio {
    public static void main(String[] args) {
        double salario = 1900.0;
        int dependentes = 3;

        boolean salarioBaixo = salario < 2000.0;
        boolean muitosDependentes = dependentes > 2;

        if (salarioBaixo && muitosDependentes) {
            System.out.println("Funcionário deve receber auxílio.");
        } else {
            System.out.println("Funcionário não se enquadra para o auxílio.");
        }
    }
}
```

**Explicação:**

- As variáveis `salarioBaixo` e `muitosDependentes` armazenam os resultados das condições.
- O `if` verifica se **ambas** as condições são verdadeiras usando o operador `&&`.
- Se ambas forem verdadeiras, o funcionário tem direito ao auxílio.

## ⚠️ Observações Importantes

- **Avaliação Curta-Circuito:**
  - No operador `&&`, se a primeira condição for `false`, a segunda **não é avaliada**, pois o resultado já será `false`.
  - No operador `||`, se a primeira condição for `true`, a segunda **não é avaliada**, pois o resultado já será `true`.

- **Boa Prática:**
  - Utilizar variáveis booleanas intermediárias (`salarioBaixo`, `muitosDependentes`) melhora a legibilidade e facilita a manutenção do código.



[Voltar ao Índice](#indice)

---


## <a name="parte25">25 - 024 - Estruturas Condicionais pt 05 - Resolução do exercícios</a>

# Aula 24 – Estruturas Condicionais pt 05: Resolução do Exercício

📺 **Link do vídeo:** [Assista no YouTube](https://www.youtube.com/watch?v=W-ng6Dqa-E4)

## 🧠 Conteúdo Abordado

Nesta aula, o instrutor William Suane apresenta a resolução do exercício proposto na aula anterior, utilizando estruturas condicionais em Java para determinar se um funcionário deve receber auxílio com base em seu salário e número de dependentes.

### 🔹 Relembrando o Exercício

**Objetivo:** Determinar se um funcionário deve receber auxílio.

**Critérios:**

- **Salário Baixo:** Salário menor que R$ 2000.00
- **Muitos Dependentes:** Mais de 2 dependentes

### 🔹 Implementação em Java

```java
public class Auxilio {
    public static void main(String[] args) {
        double salario = 1900.0;
        int dependentes = 3;

        boolean salarioBaixo = salario < 2000.0;
        boolean muitosDependentes = dependentes > 2;

        if (salarioBaixo && muitosDependentes) {
            System.out.println("Funcionário deve receber auxílio.");
        } else {
            System.out.println("Funcionário não se enquadra para o auxílio.");
        }
    }
}
```

**Explicação:**

- As variáveis `salarioBaixo` e `muitosDependentes` armazenam os resultados das condições.
- O `if` verifica se **ambas** as condições são verdadeiras usando o operador `&&`.
- Se ambas forem verdadeiras, o funcionário tem direito ao auxílio.

### 🔹 Utilizando o Operador Ternário

Para tornar o código mais conciso, é possível utilizar o operador ternário:

```java
public class Auxilio {
    public static void main(String[] args) {
        double salario = 1900.0;
        int dependentes = 3;

        String resultado = (salario < 2000.0 && dependentes > 2) 
            ? "Funcionário deve receber auxílio." 
            : "Funcionário não se enquadra para o auxílio.";

        System.out.println(resultado);
    }
}
```

**Explicação:**

- O operador ternário avalia a condição `(salario < 2000.0 && dependentes > 2)`.
- Se verdadeira, retorna "Funcionário deve receber auxílio."
- Caso contrário, retorna "Funcionário não se enquadra para o auxílio."

## ⚠️ Observações Importantes

- **Avaliação Curta-Circuito:**
  - No operador `&&`, se a primeira condição for `false`, a segunda **não é avaliada**, pois o resultado já será `false`.
  - No operador `||`, se a primeira condição for `true`, a segunda **não é avaliada**, pois o resultado já será `true`.

- **Boas Práticas:**
  - Utilizar variáveis booleanas intermediárias (`salarioBaixo`, `muitosDependentes`) melhora a legibilidade e facilita a manutenção do código.
  - O operador ternário é ideal para condições simples. Para lógica mais complexa, prefira estruturas `if-else` para manter a clareza do código.



[Voltar ao Índice](#indice)

---


## <a name="parte26">26 - 025 - Estruturas Condicionais pt 06 - Switch</a>

# Aula 25 – Estruturas Condicionais pt 06: Switch

📺 **Link do vídeo:** [Assista no YouTube](https://www.youtube.com/watch?v=AYMtqJSrQTU)

## 🧠 Conteúdo Abordado

Nesta aula, o instrutor William Suane apresenta a estrutura condicional `switch` em Java, que permite executar diferentes blocos de código com base no valor de uma variável, oferecendo uma alternativa mais organizada ao uso de múltiplos `if-else`.

### 🔹 Sintaxe do `switch`

```java
switch (expressão) {
    case valor1:
        // código a ser executado
        break;
    case valor2:
        // código a ser executado
        break;
    // outros casos
    default:
        // código a ser executado se nenhum caso for satisfeito
}
```

- **expressão**: Pode ser do tipo `byte`, `short`, `char`, `int`, `String` ou `enum`.
- **case**: Cada `case` compara o valor da expressão com um valor constante.
- **break**: Impede o *fall-through*, ou seja, evita que a execução continue nos próximos casos.
- **default**: Executado quando nenhum `case` corresponde ao valor da expressão.

### 🔹 Exemplo Prático

```java
public class DiaDaSemana {
    public static void main(String[] args) {
        int dia = 3;
        switch (dia) {
            case 1:
                System.out.println("Domingo");
                break;
            case 2:
                System.out.println("Segunda-feira");
                break;
            case 3:
                System.out.println("Terça-feira");
                break;
            case 4:
                System.out.println("Quarta-feira");
                break;
            case 5:
                System.out.println("Quinta-feira");
                break;
            case 6:
                System.out.println("Sexta-feira");
                break;
            case 7:
                System.out.println("Sábado");
                break;
            default:
                System.out.println("Dia inválido");
        }
    }
}
```

**Saída:**

```
Terça-feira
```

### 🔹 Uso com `String` (a partir do Java 7)

```java
public class DiaDaSemanaString {
    public static void main(String[] args) {
        String dia = "terça";
        switch (dia.toLowerCase()) {
            case "segunda":
                System.out.println("Dia 2");
                break;
            case "terça":
                System.out.println("Dia 3");
                break;
            case "quarta":
                System.out.println("Dia 4");
                break;
            case "quinta":
                System.out.println("Dia 5");
                break;
            case "sexta":
                System.out.println("Dia 6");
                break;
            case "sábado":
                System.out.println("Dia 7");
                break;
            case "domingo":
                System.out.println("Dia 1");
                break;
            default:
                System.out.println("Dia inválido");
        }
    }
}
```

**Saída:**

```
Dia 3
```

## ⚠️ Observações Importantes

- **Fall-through**: Se o `break` for omitido, a execução continuará nos próximos casos até encontrar um `break` ou o final do `switch`.
  
  ```java
  int numero = 2;
  switch (numero) {
      case 1:
          System.out.println("Um");
      case 2:
          System.out.println("Dois");
      case 3:
          System.out.println("Três");
      default:
          System.out.println("Número não identificado");
  }
  ```

  **Saída:**

  ```
  Dois
  Três
  Número não identificado
  ```

- **`default` opcional**: O bloco `default` é opcional, mas recomendado para tratar valores inesperados.
- **Valores únicos**: Cada `case` deve ter um valor constante e único.



[Voltar ao Índice](#indice)

---


## <a name="parte27">27 - 026 - Estruturas Condicionais pt 07 - Switch exercício</a>

# Aula 26 – Estruturas Condicionais pt 07: Switch Exercício

📺 **Link do vídeo:** [Assista no YouTube](https://www.youtube.com/watch?v=GDAgMb9amow)

## 🧠 Conteúdo Abordado

Nesta aula, o instrutor William Suane propõe um exercício prático para reforçar o entendimento da estrutura condicional `switch` em Java. O objetivo é aplicar o conhecimento adquirido na aula anterior, utilizando o `switch` para resolver problemas reais.

### 🔹 Descrição do Exercício

**Objetivo:** Criar um programa que, com base em um número de 1 a 7, exiba o dia da semana correspondente.

**Requisitos:**

- Utilizar a estrutura `switch`.
- Tratar casos onde o número não corresponde a um dia da semana válido.

### 🔹 Implementação em Java

```java
public class DiaDaSemana {
    public static void main(String[] args) {
        int dia = 3; // Você pode alterar este valor para testar outros casos

        switch (dia) {
            case 1:
                System.out.println("Domingo");
                break;
            case 2:
                System.out.println("Segunda-feira");
                break;
            case 3:
                System.out.println("Terça-feira");
                break;
            case 4:
                System.out.println("Quarta-feira");
                break;
            case 5:
                System.out.println("Quinta-feira");
                break;
            case 6:
                System.out.println("Sexta-feira");
                break;
            case 7:
                System.out.println("Sábado");
                break;
            default:
                System.out.println("Dia inválido");
        }
    }
}
```

**Explicação:**

- A variável `dia` representa o número do dia da semana.
- O `switch` avalia o valor de `dia` e executa o bloco correspondente.
- O `default` trata casos onde o valor de `dia` não está entre 1 e 7.

### 🔹 Testando o Programa

Altere o valor da variável `dia` para testar diferentes cenários:

- `dia = 1` → Saída: `Domingo`
- `dia = 5` → Saída: `Quinta-feira`
- `dia = 8` → Saída: `Dia inválido`

## ⚠️ Observações Importantes

- **Uso do `break`:** Cada `case` termina com um `break` para evitar o *fall-through*, onde múltiplos blocos seriam executados.
- **`default` opcional:** Embora opcional, é uma boa prática incluir o `default` para tratar valores inesperados.
- **Tipos compatíveis:** A expressão no `switch` pode ser dos tipos `byte`, `short`, `int`, `char`, `String` (a partir do Java 7) ou `enum`.


[Voltar ao Índice](#indice)

---


## <a name="parte28">28 - 027 - Estruturas de Repetição pt 01 - Laços de repetição while, do while, for</a>

# Aula 27 – Estruturas de Repetição pt 01: Laços de repetição while, do while, for

📺 **Link do vídeo:** [Assista no YouTube](https://www.youtube.com/watch?v=hEl67ZAU_Hg)

## 🧠 Conteúdo Abordado

Nesta aula, o instrutor William Suane apresenta as estruturas de repetição em Java: `while`, `do-while` e `for`. Essas estruturas permitem executar um bloco de código repetidamente, com base em uma condição.

### 🔹 Estrutura `while`

A estrutura `while` executa um bloco de código enquanto uma condição for verdadeira. A condição é verificada antes da execução do bloco.

**Sintaxe:**

```java
while (condição) {
    // código a ser executado
}
```

**Exemplo:**

```java
int i = 1;
while (i <= 5) {
    System.out.println("Valor de i: " + i);
    i++;
}
```

**Saída:**

```
Valor de i: 1
Valor de i: 2
Valor de i: 3
Valor de i: 4
Valor de i: 5
```

### 🔹 Estrutura `do-while`

A estrutura `do-while` é semelhante ao `while`, mas a condição é verificada após a execução do bloco. Isso garante que o bloco seja executado pelo menos uma vez.

**Sintaxe:**

```java
do {
    // código a ser executado
} while (condição);
```

**Exemplo:**

```java
int i = 1;
do {
    System.out.println("Valor de i: " + i);
    i++;
} while (i <= 5);
```

**Saída:**

```
Valor de i: 1
Valor de i: 2
Valor de i: 3
Valor de i: 4
Valor de i: 5
```

### 🔹 Estrutura `for`

A estrutura `for` é utilizada quando se sabe previamente o número de vezes que o bloco de código deve ser executado. Ela combina inicialização, condição e incremento em uma única linha.

**Sintaxe:**

```java
for (inicialização; condição; incremento) {
    // código a ser executado
}
```

**Exemplo:**

```java
for (int i = 1; i <= 5; i++) {
    System.out.println("Valor de i: " + i);
}
```

**Saída:**

```
Valor de i: 1
Valor de i: 2
Valor de i: 3
Valor de i: 4
Valor de i: 5
```

## ⚠️ Observações Importantes

- **`while`**: Verifica a condição antes de executar o bloco. Se a condição for falsa na primeira verificação, o bloco pode não ser executado nenhuma vez.
- **`do-while`**: Executa o bloco pelo menos uma vez, pois a condição é verificada após a execução.
- **`for`**: Ideal quando se sabe exatamente quantas vezes o loop deve ser executado.



[Voltar ao Índice](#indice)

---


## <a name="parte29">29 - 028 - Estruturas de Repetição pt 02 - Exercício for</a>

# Aula 28 – Estruturas de Repetição pt 02: Exercício com `for`

📺 **Link do vídeo:** [Assista no YouTube](https://www.youtube.com/watch?v=nvFAe05Ok3g)

## 🧠 Conteúdo Abordado

Nesta aula, o instrutor William Suane propõe um exercício prático para reforçar o entendimento da estrutura de repetição `for` em Java. O objetivo é aplicar o conhecimento adquirido na aula anterior, utilizando o `for` para resolver problemas reais.

### 🔹 Descrição do Exercício

**Objetivo:** Criar um programa que exiba todos os números pares de 0 a 100.

**Requisitos:**

- Utilizar a estrutura `for`.
- Exibir apenas números pares no intervalo de 0 a 100.

### 🔹 Implementação em Java

```java
public class NumerosPares {
    public static void main(String[] args) {
        for (int i = 0; i <= 100; i++) {
            if (i % 2 == 0) {
                System.out.println("Número par: " + i);
            }
        }
    }
}
```

**Explicação:**

- A variável `i` é inicializada com 0 e incrementada até 100.
- A condição `i % 2 == 0` verifica se o número é par.
- Se a condição for verdadeira, o número é exibido no console.

### 🔹 Alternativa com Incremento de 2

Uma forma mais eficiente de exibir apenas os números pares é incrementar a variável `i` de 2 em 2:

```java
public class NumerosPares {
    public static void main(String[] args) {
        for (int i = 0; i <= 100; i += 2) {
            System.out.println("Número par: " + i);
        }
    }
}
```

**Vantagens:**

- Elimina a necessidade de verificar se o número é par.
- Reduz o número de iterações, tornando o programa mais eficiente.

## ⚠️ Observações Importantes

- **Uso do `for`:** Ideal quando se sabe exatamente quantas vezes o loop deve ser executado.
- **Eficiência:** Incrementar de 2 em 2 é mais eficiente do que verificar se o número é par a cada iteração.
- **Legibilidade:** Escolher a abordagem que torna o código mais legível e fácil de entender.


[Voltar ao Índice](#indice)

---


## <a name="parte30">30 - 029 - Estruturas de Repetição pt 03 - Break</a>

# Aula 29 – Estruturas de Repetição pt 03: Break

📺 **Link do vídeo:** [Assista no YouTube](https://www.youtube.com/watch?v=bcv-cgpw7Ak)

## 🧠 Conteúdo Abordado

Nesta aula, o instrutor William Suane apresenta o uso da instrução `break` em Java, que é utilizada para interromper a execução de estruturas de repetição (`for`, `while`, `do-while`) ou de um bloco `switch`.

### 🔹 O que é o `break`?

O `break` é uma instrução de controle de fluxo que, quando executada, termina imediatamente a estrutura de controle mais próxima (`for`, `while`, `do-while` ou `switch`) e transfere o controle para a próxima instrução após essa estrutura.

### 🔹 Uso do `break` em loops

**Exemplo com `for`:**

```java
for (int i = 0; i < 10; i++) {
    if (i == 5) {
        break;
    }
    System.out.println("i: " + i);
}
```

**Saída:**

```
i: 0
i: 1
i: 2
i: 3
i: 4
```

**Exemplo com `while`:**

```java
int i = 0;
while (i < 10) {
    if (i == 5) {
        break;
    }
    System.out.println("i: " + i);
    i++;
}
```

**Saída:**

```
i: 0
i: 1
i: 2
i: 3
i: 4
```

**Exemplo com `do-while`:**

```java
int i = 0;
do {
    if (i == 5) {
        break;
    }
    System.out.println("i: " + i);
    i++;
} while (i < 10);
```

**Saída:**

```
i: 0
i: 1
i: 2
i: 3
i: 4
```

### 🔹 Uso do `break` em `switch`

```java
int dia = 3;
switch (dia) {
    case 1:
        System.out.println("Domingo");
        break;
    case 2:
        System.out.println("Segunda-feira");
        break;
    case 3:
        System.out.println("Terça-feira");
        break;
    default:
        System.out.println("Dia inválido");
}
```

**Saída:**

```
Terça-feira
```

### 🔹 Uso de `break` com rótulos (labeled break)

Em loops aninhados, o `break` afeta apenas o loop mais interno. Para sair de loops externos, utiliza-se rótulos:

```java
externo:
for (int i = 0; i < 3; i++) {
    for (int j = 0; j < 3; j++) {
        if (i == 1 && j == 1) {
            break externo;
        }
        System.out.println("i: " + i + ", j: " + j);
    }
}
```

**Saída:**

```
i: 0, j: 0
i: 0, j: 1
i: 0, j: 2
i: 1, j: 0
```

## ⚠️ Observações Importantes

- **Uso adequado:** Utilize o `break` para sair de loops ou `switch` quando uma condição específica for atendida.
- **Legibilidade:** Evite o uso excessivo de `break`, pois pode dificultar a leitura e manutenção do código.
- **Loops infinitos:** Em loops sem condição de término explícita, o `break` pode ser utilizado para definir uma condição de saída.


[Voltar ao Índice](#indice)

---


## <a name="parte31">31 - 030 - Estruturas de Repetição pt 04 - Exercício Break</a>

# Aula 30 – Estruturas de Repetição pt 04: Exercício com `break`

📺 **Link do vídeo:** [Assista no YouTube](https://www.youtube.com/watch?v=RaEO2YsqFII)

## 🧠 Conteúdo Abordado

Nesta aula, o instrutor William Suane propõe um exercício prático para reforçar o entendimento da instrução `break` em Java. O objetivo é aplicar o conhecimento adquirido na aula anterior, utilizando o `break` para controlar o fluxo de execução em estruturas de repetição.

### 🔹 Descrição do Exercício

**Objetivo:** Criar um programa que exiba os números de 1 a 50, mas interrompa a execução quando encontrar um número divisível por 25.

**Requisitos:**

- Utilizar a estrutura `for`.
- Exibir os números de 1 a 50.
- Interromper a execução ao encontrar um número divisível por 25.

### 🔹 Implementação em Java

```java
public class BreakExercicio {
    public static void main(String[] args) {
        for (int i = 1; i <= 50; i++) {
            if (i % 25 == 0) {
                System.out.println("Número divisível por 25 encontrado: " + i);
                break;
            }
            System.out.println("i = " + i);
        }
    }
}
```

**Explicação:**

- A variável `i` é inicializada com 1 e incrementada até 50.
- A condição `i % 25 == 0` verifica se o número é divisível por 25.
- Se a condição for verdadeira, o número é exibido e a execução é interrompida com o `break`.
- Caso contrário, o número é exibido normalmente.

### 🔹 Saída Esperada

```
i = 1
i = 2
...
i = 24
Número divisível por 25 encontrado: 25
```

## ⚠️ Observações Importantes

- **Uso do `break`:** A instrução `break` é utilizada para interromper a execução de loops (`for`, `while`, `do-while`) ou de um bloco `switch` quando uma condição específica é atendida.
- **Legibilidade:** Utilizar o `break` de forma adequada pode melhorar a legibilidade e eficiência do código, evitando execuções desnecessárias.
- **Loops Infinitos:** Em loops sem condição de término explícita, o `break` pode ser utilizado para definir uma condição de saída.


[Voltar ao Índice](#indice)

---


## <a name="parte32">32 - 031 - Estruturas de Repetição pt 05 - Continue</a>

# Aula 31 – Estruturas de Repetição pt 05: Continue

📺 **Link do vídeo:** [Assista no YouTube](https://www.youtube.com/watch?v=f65R-lQ4NpY)

## 🧠 Conteúdo Abordado

Nesta aula, o instrutor William Suane apresenta a instrução `continue` em Java, que é utilizada para pular a execução do restante do código dentro de um loop e iniciar a próxima iteração.

### 🔹 O que é o `continue`?

O `continue` é uma instrução de controle de fluxo que, quando executada dentro de um loop (`for`, `while` ou `do-while`), faz com que o loop pule o restante do código na iteração atual e prossiga para a próxima iteração.

### 🔹 Uso do `continue` em loops

**Exemplo com `for`:**

```java
for (int i = 0; i < 10; i++) {
    if (i == 5) {
        continue;
    }
    System.out.println("i: " + i);
}
```

**Saída:**

```
i: 0
i: 1
i: 2
i: 3
i: 4
i: 6
i: 7
i: 8
i: 9
```

**Exemplo com `while`:**

```java
int i = 0;
while (i < 10) {
    i++;
    if (i == 5) {
        continue;
    }
    System.out.println("i: " + i);
}
```

**Saída:**

```
i: 1
i: 2
i: 3
i: 4
i: 6
i: 7
i: 8
i: 9
i: 10
```

**Exemplo com `do-while`:**

```java
int i = 0;
do {
    i++;
    if (i == 5) {
        continue;
    }
    System.out.println("i: " + i);
} while (i < 10);
```

**Saída:**

```
i: 1
i: 2
i: 3
i: 4
i: 6
i: 7
i: 8
i: 9
i: 10
```

### 🔹 Uso do `continue` em loops aninhados

Em loops aninhados, o `continue` afeta apenas o loop mais interno. Para controlar loops externos, utiliza-se rótulos:

```java
externo:
for (int i = 0; i < 3; i++) {
    for (int j = 0; j < 3; j++) {
        if (i == 1 && j == 1) {
            continue externo;
        }
        System.out.println("i: " + i + ", j: " + j);
    }
}
```

**Saída:**

```
i: 0, j: 0
i: 0, j: 1
i: 0, j: 2
i: 1, j: 0
i: 2, j: 0
i: 2, j: 1
i: 2, j: 2
```

## ⚠️ Observações Importantes

- **Uso adequado:** Utilize o `continue` para pular determinadas iterações com base em condições específicas.
- **Legibilidade:** Evite o uso excessivo de `continue`, pois pode dificultar a leitura e manutenção do código.
- **Loops infinitos:** Certifique-se de que o uso de `continue` não interfira na lógica de término do loop, evitando loops infinitos.


[Voltar ao Índice](#indice)

---


## <a name="parte33">33 - 032 - Arrays pt 01</a>

# Aula 32 – Arrays pt 01

📺 **Link do vídeo:** [Assista no YouTube](https://www.youtube.com/watch?v=fvw4bmihZHA)

## 🧠 Conteúdo Abordado

Nesta aula, o instrutor William Suane introduz o conceito de arrays em Java, abordando sua declaração, inicialização e acesso aos elementos.

### 🔹 O que são Arrays?

Arrays são estruturas de dados que armazenam múltiplos valores do mesmo tipo em uma única variável. Eles são úteis quando precisamos trabalhar com coleções de dados homogêneos.

### 🔹 Declaração e Inicialização de Arrays

**Forma 1: Declaração e atribuição separadas**

```java
int[] numeros; // declaração
numeros = new int[5]; // inicialização com tamanho 5
```

**Forma 2: Declaração e inicialização conjunta**

```java
int[] numeros = new int[5];
```

**Forma 3: Inicialização com valores definidos**

```java
int[] numeros = {1, 2, 3, 4, 5};
```

### 🔹 Acessando Elementos de um Array

Os elementos de um array são acessados por índices, que começam em 0.

```java
System.out.println(numeros[0]); // Acessa o primeiro elemento
```

### 🔹 Iterando sobre Arrays

Podemos utilizar loops para percorrer os elementos de um array.

**Exemplo com `for`:**

```java
for (int i = 0; i < numeros.length; i++) {
    System.out.println(numeros[i]);
}
```

**Exemplo com `for-each`:**

```java
for (int numero : numeros) {
    System.out.println(numero);
}
```

### 🔹 Tamanho do Array

O tamanho de um array é acessado através da propriedade `length`.

```java
int tamanho = numeros.length;
System.out.println("Tamanho do array: " + tamanho);
```

## ⚠️ Observações Importantes

- **Tipo homogêneo:** Arrays armazenam elementos do mesmo tipo.
- **Tamanho fixo:** Após a inicialização, o tamanho do array não pode ser alterado.
- **Índices:** Os índices começam em 0 e vão até `length - 1`.



[Voltar ao Índice](#indice)

---


## <a name="parte34">34 - 033 - Arrays pt 02</a>

# Aula 33 – Arrays pt 02

📺 **Link do vídeo:** [Assista no YouTube](https://www.youtube.com/watch?v=S8Eaq6uxnd8)

## 🧠 Conteúdo Abordado

Nesta aula, o instrutor William Suane aprofunda o estudo sobre arrays em Java, abordando conceitos como:

- Acessando elementos de arrays
- Iterando sobre arrays com diferentes estruturas de repetição
- Utilizando a propriedade `length` para determinar o tamanho do array
- Práticas recomendadas ao trabalhar com arrays

### 🔹 Acessando Elementos de um Array

Os elementos de um array são acessados por índices, que começam em 0.

```java
int[] numeros = {10, 20, 30, 40, 50};
System.out.println(numeros[0]); // Saída: 10
System.out.println(numeros[4]); // Saída: 50
```

### 🔹 Iterando sobre Arrays

Podemos utilizar diferentes estruturas de repetição para percorrer os elementos de um array.

**Usando o loop `for`:**

```java
for (int i = 0; i < numeros.length; i++) {
    System.out.println("Elemento na posição " + i + ": " + numeros[i]);
}
```

**Usando o loop `while`:**

```java
int i = 0;
while (i < numeros.length) {
    System.out.println("Elemento na posição " + i + ": " + numeros[i]);
    i++;
}
```

**Usando o loop `do-while`:**

```java
int i = 0;
do {
    System.out.println("Elemento na posição " + i + ": " + numeros[i]);
    i++;
} while (i < numeros.length);
```

### 🔹 Propriedade `length`

A propriedade `length` retorna o tamanho do array, ou seja, o número de elementos que ele pode armazenar.

```java
System.out.println("Tamanho do array: " + numeros.length); // Saída: 5
```

### 🔹 Práticas Recomendadas

- **Evite acessar índices fora do intervalo:** Certifique-se de que os índices utilizados estão dentro do intervalo válido (0 a `length - 1`) para evitar `ArrayIndexOutOfBoundsException`.
- **Utilize loops apropriados:** Escolha a estrutura de repetição que melhor se adequa à lógica do seu programa.
- **Inicialize arrays corretamente:** Ao declarar arrays, certifique-se de inicializá-los antes de acessar seus elementos.


[Voltar ao Índice](#indice)

---


## <a name="parte35">35 - 034 - Arrays pt 03</a>

# Aula 33 – Arrays pt 02

📺 **Link do vídeo:** [Assista no YouTube](https://www.youtube.com/watch?v=S8Eaq6uxnd8)

## 🧠 Conteúdo Abordado

Nesta aula, o instrutor William Suane aprofunda o estudo sobre arrays em Java, abordando conceitos como:

- Acessando elementos de arrays
- Iterando sobre arrays com diferentes estruturas de repetição
- Utilizando a propriedade `length` para determinar o tamanho do array
- Práticas recomendadas ao trabalhar com arrays

### 🔹 Acessando Elementos de um Array

Os elementos de um array são acessados por índices, que começam em 0.

```java
int[] numeros = {10, 20, 30, 40, 50};
System.out.println(numeros[0]); // Saída: 10
System.out.println(numeros[4]); // Saída: 50
```

### 🔹 Iterando sobre Arrays

Podemos utilizar diferentes estruturas de repetição para percorrer os elementos de um array.

**Usando o loop `for`:**

```java
for (int i = 0; i < numeros.length; i++) {
    System.out.println("Elemento na posição " + i + ": " + numeros[i]);
}
```

**Usando o loop `while`:**

```java
int i = 0;
while (i < numeros.length) {
    System.out.println("Elemento na posição " + i + ": " + numeros[i]);
    i++;
}
```

**Usando o loop `do-while`:**

```java
int i = 0;
do {
    System.out.println("Elemento na posição " + i + ": " + numeros[i]);
    i++;
} while (i < numeros.length);
```

### 🔹 Propriedade `length`

A propriedade `length` retorna o tamanho do array, ou seja, o número de elementos que ele pode armazenar.

```java
System.out.println("Tamanho do array: " + numeros.length); // Saída: 5
```

### 🔹 Práticas Recomendadas

- **Evite acessar índices fora do intervalo:** Certifique-se de que os índices utilizados estão dentro do intervalo válido (0 a `length - 1`) para evitar `ArrayIndexOutOfBoundsException`.
- **Utilize loops apropriados:** Escolha a estrutura de repetição que melhor se adequa à lógica do seu programa.
- **Inicialize arrays corretamente:** Ao declarar arrays, certifique-se de inicializá-los antes de acessar seus elementos.


[Voltar ao Índice](#indice)

---


## <a name="parte36">36 - 035 - Arrays pt 04 - Foreach</a>

# Aula 35 – Arrays pt 04: Foreach

📺 **Link do vídeo:** [Assista no YouTube](https://www.youtube.com/watch?v=cl47iLWalUw)

## 🧠 Conteúdo Abordado

Nesta aula, o instrutor William Suane apresenta o loop `foreach` (também conhecido como "enhanced for loop") em Java, uma forma simplificada e mais legível de iterar sobre arrays e coleções.

---

## 🔹 O que é o `foreach`?

O `foreach` é uma estrutura de repetição introduzida no Java 5 que permite iterar sobre elementos de arrays ou coleções sem a necessidade de utilizar índices. Embora utilize a palavra-chave `for`, sua estrutura é diferente do `for` tradicional — por isso é conhecido como **"foreach"**.

---

## 🔹 Sintaxe do `foreach`

```java
for (Tipo elemento : arrayOuColecao) {
    // Bloco de código a ser executado para cada elemento
}
```

- `Tipo`: tipo do elemento dentro do array ou coleção.
- `elemento`: variável temporária que armazena o valor atual.
- `arrayOuColecao`: estrutura de dados a ser percorrida.

---

## 🔹 Exemplo 1: `foreach` com array de inteiros

```java
int[] numeros = {1, 2, 3, 4, 5};

// foreach para imprimir cada número
for (int numero : numeros) {
    System.out.println(numero);
}
```

**Saída:**

```
1
2
3
4
5
```

---

## 🔹 Exemplo 2: `foreach` com array de Strings

```java
String[] nomes = {"Ana", "Bruno", "Carlos"};

// foreach para imprimir cada nome
for (String nome : nomes) {
    System.out.println(nome);
}
```

**Saída:**

```
Ana
Bruno
Carlos
```

---

## ✅ Vantagens do `foreach`

- Código mais limpo e legível.
- Evita erros de acesso por índice.
- Ideal para percorrer todos os elementos de forma simples.

---

## ⚠️ Limitações do `foreach`

- Não permite acesso ao índice dos elementos.
- Não serve para modificar os elementos diretamente (em arrays de tipos primitivos).
- Só percorre os dados do início ao fim.

---



[Voltar ao Índice](#indice)

---


## <a name="parte37">37 - 036 - Arrays Multidimensionais pt 01</a>

# Aula 36 – Arrays Multidimensionais pt 01

📺 **Vídeo:** [Arrays Multidimensionais pt 01 - DevDojo](https://www.youtube.com/watch?v=EalQ6X_RtJk&list=PL62G310vn6nFIsOCC0H-C2infYgwm8SWW&index=37)

## 🧠 O que são Arrays Multidimensionais?

Em Java, arrays multidimensionais são estruturas que armazenam dados em mais de uma dimensão — como uma **tabela (matriz)** com linhas e colunas. O mais comum é o array bidimensional, ou seja, com duas dimensões.

---

## 🧱 Declaração de um Array Bidimensional

```java
int[][] dias = new int[2][2];
```

- Isso cria um array com **2 linhas** e **2 colunas**.
- Cada elemento do array `dias[i][j]` pode ser acessado e manipulado individualmente.

---

## 🛠️ Atribuindo valores

```java
dias[0][0] = 1;
dias[0][1] = 2;
dias[1][0] = 3;
dias[1][1] = 4;
```

---

## 🔁 Acessando elementos com `for` aninhado

```java
for (int i = 0; i < dias.length; i++) {
    for (int j = 0; j < dias[i].length; j++) {
        System.out.println("dias[" + i + "][" + j + "] = " + dias[i][j]);
    }
}
```

**Saída esperada:**

```
dias[0][0] = 1
dias[0][1] = 2
dias[1][0] = 3
dias[1][1] = 4
```

---

## 💡 Dicas da Aula

- `dias.length` retorna o número de **linhas**.
- `dias[i].length` retorna o número de **colunas da linha i**.
- Java permite arrays de arrays com **tamanhos diferentes** em cada linha.

### Exemplo de array com colunas irregulares:

```java
int[][] irregular = new int[2][];
irregular[0] = new int[2]; // 2 colunas na linha 0
irregular[1] = new int[3]; // 3 colunas na linha 1
```

---

## ✅ Vantagens de usar arrays multidimensionais

- Organizam dados em estrutura de grade (matriz).
- Úteis para tabelas, mapas, jogos, horários, etc.
- Podem ser aninhados com laços para iteração completa.

---

## 📌 Exercício proposto (extra)

Crie uma matriz `3x3` que armazene os números de 1 a 9 e imprima o conteúdo formatado.

```java
public class MatrizExemplo {
    public static void main(String[] args) {
        int[][] matriz = new int[3][3];
        int contador = 1;

        for (int i = 0; i < matriz.length; i++) {
            for (int j = 0; j < matriz[i].length; j++) {
                matriz[i][j] = contador++;
            }
        }

        // Impressão formatada
        for (int[] linha : matriz) {
            for (int valor : linha) {
                System.out.print(valor + " ");
            }
            System.out.println();
        }
    }
}
```

**Saída:**

```
1 2 3
4 5 6
7 8 9
```

---

🧠 **Conclusão:** Arrays multidimensionais são extremamente úteis para representar dados tabulares e devem ser bem compreendidos para manipulação de estruturas complexas em Java.

---


[Voltar ao Índice](#indice)

---


## <a name="parte38">38 - 037 - Arrays Multidimensionais pt 02 - Foreach</a>

# Aula 37 – Arrays Multidimensionais pt 02 - Foreach

📺 **Vídeo:** [Arrays Multidimensionais pt 02 - Foreach](https://www.youtube.com/watch?v=TGq3754CsN4&list=PL62G310vn6nFIsOCC0H-C2infYgwm8SWW&index=38)

## 🧠 O que foi abordado na aula?

Nesta aula, o professor explica como percorrer **arrays multidimensionais** utilizando o **laço `foreach`**, que facilita a leitura de elementos em arrays sem precisar controlar os índices manualmente.

---

## 🔁 Relembrando o `foreach`

O `foreach` é um **laço de repetição** utilizado para iterar diretamente sobre os elementos de um array ou coleção, sem a necessidade de índices.

### Sintaxe:

```java
for (tipo variavel : array) {
    // Ações com a variavel
}
```

---

## 🧱 Exemplo com array multidimensional

```java
public class AulaForeachMultidimensional {
    public static void main(String[] args) {
        int[][] arrayMultidimensional = {
            {1, 2, 3},
            {4, 5, 6},
            {7, 8, 9}
        };

        for (int[] linha : arrayMultidimensional) {
            for (int valor : linha) {
                System.out.print(valor + " ");
            }
            System.out.println();
        }
    }
}
```

### 🖨️ Saída:

```
1 2 3 
4 5 6 
7 8 9 
```

---

## ✅ Vantagens do uso de `foreach`

- Código mais limpo e legível.
- Elimina erros comuns com índices.
- Ideal para leitura e exibição de dados.

---

## ⚠️ Limitações

- Não permite acesso direto ao índice dos elementos.
- Não é possível alterar os elementos diretamente do array original (para arrays de tipos primitivos).

---

## 🧪 Exercício sugerido

Crie um array bidimensional de nomes de frutas e imprima todas as frutas usando `foreach`.

```java
public class ExercicioFrutas {
    public static void main(String[] args) {
        String[][] frutas = {
            {"Maçã", "Banana"},
            {"Laranja", "Uva"},
            {"Melancia", "Manga"}
        };

        for (String[] linha : frutas) {
            for (String fruta : linha) {
                System.out.print(fruta + " | ");
            }
            System.out.println();
        }
    }
}
```

**Saída:**

```
Maçã | Banana | 
Laranja | Uva | 
Melancia | Manga | 
```

---

## 🧠 Conclusão

Usar `foreach` com arrays multidimensionais deixa o código muito mais enxuto e prático para leitura e exibição de dados. Apesar de suas limitações, é uma ferramenta poderosa especialmente em situações onde o índice não é necessário.



[Voltar ao Índice](#indice)

---


## <a name="parte39">39 - 038 - Arrays Multidimensionais pt 03 - Inicialização</a>

# Aula 38 – Arrays Multidimensionais pt 03 - Inicialização

📺 **Vídeo:** [Arrays Multidimensionais pt 03 - Inicialização](https://www.youtube.com/watch?v=vp8bQZomKLo&list=PL62G310vn6nFIsOCC0H-C2infYgwm8SWW&index=39)

## 🧠 O que foi abordado na aula?

Nesta aula, o professor do DevDojo explica as formas de **inicialização de arrays multidimensionais em Java**, com foco na clareza e praticidade do código. Ele mostra como criar e atribuir valores a esses arrays de forma explícita ou separando a alocação da atribuição.

---

## 🔢 O que é um Array Multidimensional?

Um array multidimensional é uma estrutura de dados composta por **arrays dentro de arrays**. Em Java, arrays 2D são representados como `tipo[][]`, sendo o tipo mais comum `int[][]`, `String[][]`, etc.

---

## ✅ Formas de inicialização

### 1. Inicialização direta (em linha)

```java
int[][] numeros = {
    {1, 2, 3},
    {4, 5},
    {6, 7, 8, 9}
};
```

- Aqui o array já é criado e preenchido com valores.
- Permite criar "linhas" com diferentes quantidades de colunas (vetores irregulares).

### 2. Inicialização separada (alocação + atribuição)

```java
int[][] numeros = new int[3][];
numeros[0] = new int[]{1, 2, 3};
numeros[1] = new int[]{4, 5};
numeros[2] = new int[]{6, 7, 8, 9};
```

- Primeiro é alocado o array de arrays (`3` linhas).
- Depois, cada linha é instanciada individualmente com o número de colunas desejado.

---

## 🔍 Exemplo prático com `String`

```java
public class ExemploArrayMultidimensional {
    public static void main(String[] args) {
        String[][] nomes = {
            {"Ana", "Carlos"},
            {"Bruno"},
            {"Letícia", "Rafael", "Marcos"}
        };

        for (String[] grupo : nomes) {
            for (String nome : grupo) {
                System.out.print(nome + " ");
            }
            System.out.println();
        }
    }
}
```

### 🖨️ Saída:

```
Ana Carlos 
Bruno 
Letícia Rafael Marcos 
```

---

## 🧪 Dicas e boas práticas

- **Declare e inicialize em uma linha** sempre que possível para melhorar a legibilidade.
- Lembre-se que os arrays internos (colunas) podem ter tamanhos diferentes.
- Para arrays de grandes dimensões, mantenha o código organizado com indentação adequada.

---

## 🧠 Conclusão

Inicializar corretamente arrays multidimensionais em Java é essencial para a estruturação de dados mais complexos. A linguagem oferece flexibilidade para criar arrays regulares (matrizes) e irregulares (vetores de vetores). Entender como e quando usar cada forma de inicialização ajuda a escrever um código mais limpo e eficiente.



[Voltar ao Índice](#indice)

---


## <a name="parte40">40 - 039 - Orientação Objetos pt 01 - Introdução classes pt 01</a>



[Voltar ao Índice](#indice)

---


## <a name="parte41">41 - 040 - Orientação Objetos - Introdução classes pt 02</a>



[Voltar ao Índice](#indice)

---


## <a name="parte42">42 - 041 - Orientação Objetos - Coesão</a>



[Voltar ao Índice](#indice)

---


## <a name="parte43">43 - 042 - Orientação Objetos - Exercício Classes</a>



[Voltar ao Índice](#indice)

---


## <a name="parte44">44 - 043 - Orientação Objetos - Referência de objetos</a>



[Voltar ao Índice](#indice)

---


## <a name="parte45">45 - 044 - Orientação Objetos - Métodos pt 01</a>



[Voltar ao Índice](#indice)

---


## <a name="parte46">46 - 045 - Orientação Objetos - Métodos pt 02 - Parâmetros</a>



[Voltar ao Índice](#indice)

---


## <a name="parte47">47 - 046 - Orientação Objetos - Métodos pt 03 - Retorno pt 01</a>



[Voltar ao Índice](#indice)

---


## <a name="parte48">48 - 047 - Orientação Objetos - Métodos pt 04 - Retorno pt 02</a>



[Voltar ao Índice](#indice)

---


## <a name="parte49">49 - 048 - Orientação Objetos - Métodos pt 05 - Parâmetros tipo primitivo</a>



[Voltar ao Índice](#indice)

---


## <a name="parte50">50 - 049 - Orientação Objetos - Métodos pt 06 - Parâmetros tipo referência</a>



[Voltar ao Índice](#indice)

---


## <a name="parte51">51 - 050 - Orientação Objetos - Métodos pt 07 - Parâmetros tipo referência pt 02</a>



[Voltar ao Índice](#indice)

---


## <a name="parte52">52 - 051 - Orientação Objetos - Métodos pt 08 - Referência this</a>



[Voltar ao Índice](#indice)

---


## <a name="parte53">53 - 052 - Orientação Objetos - Métodos pt 09 - Varargs</a>



[Voltar ao Índice](#indice)

---


## <a name="parte54">54 - 053 - Orientação Objetos - Métodos pt 10 - Exercise</a>



[Voltar ao Índice](#indice)

---


## <a name="parte55">55 - 054 - Orientação Objetos - Modificador de acesso private, get e set pt 01</a>



[Voltar ao Índice](#indice)

---


## <a name="parte56">56 - 055 - Orientação Objetos - Modificador de acesso private, get e set pt 02</a>



[Voltar ao Índice](#indice)

---


## <a name="parte57">57 - 056 - Orientação Objetos - Modificador de acesso private, get e set pt 03</a>



[Voltar ao Índice](#indice)

---


## <a name="parte58">58 - 057 - Orientação Objetos - Sobrecarga de métodos</a>



[Voltar ao Índice](#indice)

---


## <a name="parte59">59 - 058 - Orientação Objetos - Construtores pt 01</a>



[Voltar ao Índice](#indice)

---


## <a name="parte60">60 - 059 - Orientação Objetos - Construtores pt 02 - Sobrecarga</a>



[Voltar ao Índice](#indice)

---


## <a name="parte61">61 - 060 - Orientação Objetos - Blocos de inicialização</a>



[Voltar ao Índice](#indice)

---


## <a name="parte62">62 - 061 - Orientação Objetos - Modificador static</a>



[Voltar ao Índice](#indice)

---


## <a name="parte63">63 - 062 - Orientação Objetos - Métodos estáticos</a>



[Voltar ao Índice](#indice)

---


## <a name="parte64">64 - 063 - Orientação Objetos - Bloco de inicialização estático</a>



[Voltar ao Índice](#indice)

---


## <a name="parte65">65 - 064 - Orientação Objetos - Associação pt 01 - Arrays com Objetos</a>



[Voltar ao Índice](#indice)

---


## <a name="parte66">66 - 065 - Orientação Objetos - Associação pt 02 - Associação unidirecional um para muitos</a>



[Voltar ao Índice](#indice)

---


## <a name="parte67">67 - 066 - Orientação Objetos - Associação pt 03 - Associação unidirecional muitos para um</a>



[Voltar ao Índice](#indice)

---


## <a name="parte68">68 - 067 - Orientação Objetos - Associação pt 04 - Associação bidirecional</a>



[Voltar ao Índice](#indice)

---


## <a name="parte69">69 - 068 - Orientação Objetos - Leitura de dados pelo console</a>



[Voltar ao Índice](#indice)

---


## <a name="parte70">70 - 069 - Orientação Objetos - Exercício leitura de dados do teclado</a>



[Voltar ao Índice](#indice)

---


## <a name="parte71">71 - 068 - Orientação Objetos - Leitura de dados pelo console</a>



[Voltar ao Índice](#indice)

---


## <a name="parte72">72 - 069 - Orientação Objetos - Exercício leitura de dados do teclado</a>



[Voltar ao Índice](#indice)

---


## <a name="parte73">73 - 070 - Orientação Objetos - Associação pt 05 - Exercício Associação</a>



[Voltar ao Índice](#indice)

---


## <a name="parte74">74 - 071 - Orientação Objetos - Herança pt 01</a>



[Voltar ao Índice](#indice)

---


## <a name="parte75">75 - 072 - Orientação Objetos - Herança pt 02 - Super</a>



[Voltar ao Índice](#indice)

---


## <a name="parte76">76 - 073 - Orientação Objetos - Herança pt 03 - protected</a>



[Voltar ao Índice](#indice)

---


## <a name="parte77">77 - 074 - Orientação Objetos - Herança pt 04 - Construtores</a>



[Voltar ao Índice](#indice)

---


## <a name="parte78">78 - 075 - Orientação Objetos - Herança pt 05 - Sequência de inicialização</a>



[Voltar ao Índice](#indice)

---


## <a name="parte79">79 - 076 - Orientação Objetos - Sobrescrita do método toString</a>



[Voltar ao Índice](#indice)

---


## <a name="parte80">80 - 077 - Orientação Objetos - Modificador final pt 01 - Tipo primitivo</a>



[Voltar ao Índice](#indice)

---


## <a name="parte81">81 - 078 - Orientação Objetos - Modificador final pt 02 - Tipo referência</a>



[Voltar ao Índice](#indice)

---


## <a name="parte82">82 - 079 - Orientação Objetos - Modificador final pt 03 - Classes e métodos</a>



[Voltar ao Índice](#indice)

---


## <a name="parte83">83 - 080 - Orientação Objetos - Enumeração pt 01 - Introdução</a>



[Voltar ao Índice](#indice)

---


## <a name="parte84">84 - 081 - Orientação Objetos - Enumeração pt 02 - Construtores e atributos</a>



[Voltar ao Índice](#indice)

---


## <a name="parte85">85 - 082 - Orientação Objetos - Enumeração pt 03 - Sobrescrita de métodos</a>



[Voltar ao Índice](#indice)

---


## <a name="parte86">86 - 083 - Orientação Objetos - Enumeração pt 04 - Busca por atributos</a>



[Voltar ao Índice](#indice)

---


## <a name="parte87">87 - 084 - Orientação Objetos - Classes abstratas pt 01</a>



[Voltar ao Índice](#indice)

---


## <a name="parte88">88 - 085 - Orientação Objetos - Classes abstratas pt 02 - Métodos abstratos</a>



[Voltar ao Índice](#indice)

---


## <a name="parte89">89 - 086 - Orientação Objetos - Classes abstratas pt 03 - Métodos abstratos regras</a>



[Voltar ao Índice](#indice)

---


## <a name="parte90">90 - 087 - Orientação Objetos - Interfaces pt 01 - Introdução</a>



[Voltar ao Índice](#indice)

---


## <a name="parte91">91 - 088 - Orientação Objetos - Interfaces pt 02 - Implementando múltiplas interfaces</a>



[Voltar ao Índice](#indice)

---


## <a name="parte92">92 - 089 - Orientação Objetos - Interfaces pt 03 - Atributos e métodos estáticos</a>



[Voltar ao Índice](#indice)

---


## <a name="parte93">93 - 090 - Orientação Objetos - Polimorfismo pt 01 - Introdução</a>



[Voltar ao Índice](#indice)

---


## <a name="parte94">94 - 091 - Orientação Objetos - Polimorfismo pt 02 - Funcionamento</a>



[Voltar ao Índice](#indice)

---


## <a name="parte95">95 - 092 - Orientação Objetos - Polimorfismo pt 03 - Parâmetros polimórficos</a>



[Voltar ao Índice](#indice)

---


## <a name="parte96">96 - 093 - Orientação Objetos - Polimorfismo pt 04 - Cast e instanceof</a>



[Voltar ao Índice](#indice)

---


## <a name="parte97">97 - 094 - Orientação Objetos - Polimorfismo pt 05 - Programação orientada a interface</a>



[Voltar ao Índice](#indice)

---


## <a name="parte98">98 - 095 - Exceções pt 01 - Errors</a>



[Voltar ao Índice](#indice)

---


## <a name="parte99">99 - 096 - Exceções pt 02 - RuntimeException</a>



[Voltar ao Índice](#indice)

---


## <a name="parte100">100 - 097 - Exceções pt 03 - Exception</a>



[Voltar ao Índice](#indice)

---


## <a name="parte101">101 - 098 - Exceções pt 04 - Lançando exceção unchecked</a>



[Voltar ao Índice](#indice)

---


## <a name="parte102">102 - 099 - Exceções pt 05 - Lançando exceção checked</a>



[Voltar ao Índice](#indice)

---


## <a name="parte103">103 - 100 - Exceções pt 06 - Bloco Finally</a>



[Voltar ao Índice](#indice)

---


## <a name="parte104">104 - 101 - Exceções pt 07 - Capturando múltiplas exceções</a>



[Voltar ao Índice](#indice)

---


## <a name="parte105">105 - 102 - Exceções pt 08 - Multi catch em linha</a>



[Voltar ao Índice](#indice)

---


## <a name="parte106">106 - 103 - Exceções pt 09 - Try with resources</a>



[Voltar ao Índice](#indice)

---


## <a name="parte107">107 - 104 - Exceções pt 10 - Exceção customizada</a>



[Voltar ao Índice](#indice)

---


## <a name="parte108">108 - 105 - Exceções pt 11 - Exceção e regras de sobrescrita</a>



[Voltar ao Índice](#indice)

---


## <a name="parte109">109 - 106 - Classes Utilitárias - Wrappers pt 01</a>



[Voltar ao Índice](#indice)

---


## <a name="parte110">110 - 107 - Classes Utilitárias - Wrappers pt 02</a>



[Voltar ao Índice](#indice)

---


## <a name="parte111">111 - 108 - Classes Utilitárias - Strings pt 01</a>



[Voltar ao Índice](#indice)

---


## <a name="parte112">112 - 109 - Classes Utilitárias - Strings pt 02</a>



[Voltar ao Índice](#indice)

---


## <a name="parte113">113 - 110 - Classes Utilitárias - Strings pt 03 - Desempenho</a>



[Voltar ao Índice](#indice)

---


## <a name="parte114">114 - 111 - Classes Utilitárias - Strings pt 04 - StringBuilder</a>



[Voltar ao Índice](#indice)

---


## <a name="parte115">115 - 112 - Classes Utilitárias - Date</a>



[Voltar ao Índice](#indice)

---


## <a name="parte116">116 - 113 - Classes Utilitárias - Calendar</a>



[Voltar ao Índice](#indice)

---


## <a name="parte117">117 - 114 - Classes Utilitárias - DateFormat</a>



[Voltar ao Índice](#indice)

---


## <a name="parte118">118 - 115 - Classes Utilitárias - Internacionalização Datas com Locale</a>



[Voltar ao Índice](#indice)

---


## <a name="parte119">119 - 116 - Classes Utilitárias - Internacionalização Números com Locale</a>



[Voltar ao Índice](#indice)

---


## <a name="parte120">120 - 117 - Classes Utilitárias - Internacionalização de moeda com Locale</a>



[Voltar ao Índice](#indice)

---


## <a name="parte121">121 - 118 - Classes Utilitárias - SimpleDateFormat</a>



[Voltar ao Índice](#indice)

---


## <a name="parte122">122 - 119 - Classes Utilitárias - LocalDate</a>



[Voltar ao Índice](#indice)

---


## <a name="parte123">123 - 120 - Classes Utilitárias - LocalTime</a>



[Voltar ao Índice](#indice)

---


## <a name="parte124">124 - 121 - Classes Utilitárias - LocalDateTime</a>



[Voltar ao Índice](#indice)

---


## <a name="parte125">125 - 122 - Classes Utilitárias - Instant</a>



[Voltar ao Índice](#indice)

---


## <a name="parte126">126 - 123 - Classes Utilitárias - Duration</a>



[Voltar ao Índice](#indice)

---


## <a name="parte127">127 - 124 - Classes Utilitárias - Period</a>



[Voltar ao Índice](#indice)

---


## <a name="parte128">128 - 125 - Classes Utilitárias - ChronoUnit</a>



[Voltar ao Índice](#indice)

---


## <a name="parte129">129 - 126 - Classes Utilitárias - TemporalAdjusters</a>



[Voltar ao Índice](#indice)

---


## <a name="parte130">130 - 127 - Classes Utilitárias - TemporalAdjuster</a>



[Voltar ao Índice](#indice)

---


## <a name="parte131">131 - 128 - Classes Utilitárias - ZonedDateTime, ZoneId, OffsetDateTime</a>



[Voltar ao Índice](#indice)

---


## <a name="parte132">132 - 129 - Classes Utilitárias - DateTimeFormatter</a>



[Voltar ao Índice](#indice)

---


## <a name="parte133">133 - 130 - Classes Utilitárias - ResourceBundle</a>



[Voltar ao Índice](#indice)

---


## <a name="parte134">134 - 131 - Classes Utilitárias - Regex pt 01 - Pattern e Matcher</a>



[Voltar ao Índice](#indice)

---


## <a name="parte135">135 - 132 - Classes Utilitárias - Regex pt 02 - Pattern e Matcher - Meta caracteres</a>



[Voltar ao Índice](#indice)

---


## <a name="parte136">136 - 133 - Classes Utilitárias - Regex pt 03 - Pattern e Matcher - Range</a>



[Voltar ao Índice](#indice)

---


## <a name="parte137">137 - 134 - Classes Utilitárias - Regex pt 04 - Pattern e Matcher - Quantificadores pt 01</a>



[Voltar ao Índice](#indice)

---


## <a name="parte138">138 - 135 - Classes Utilitárias - Regex pt 05 - Pattern e Matcher - Quantificadores pt 02</a>



[Voltar ao Índice](#indice)

---


## <a name="parte139">139 - 136 - Classes Utilitárias - Regex pt 06 - Pattern e Matcher - Anchor</a>



[Voltar ao Índice](#indice)

---


## <a name="parte140">140 - 137 - Classes Utilitárias - Scanner - Tokens e Delimitadores</a>



[Voltar ao Índice](#indice)

---


## <a name="parte141">141 - 138 - Classes Utilitárias - IO pt 01 - File</a>



[Voltar ao Índice](#indice)

---


## <a name="parte142">142 - 139 - Classes Utilitárias - IO pt 02 - FileWriter</a>



[Voltar ao Índice](#indice)

---


## <a name="parte143">143 - 140 - Classes Utilitárias - IO pt 03 - FileReader</a>



[Voltar ao Índice](#indice)

---


## <a name="parte144">144 - 141 - Classes Utilitárias - IO pt 04 - BufferedWriter</a>



[Voltar ao Índice](#indice)

---


## <a name="parte145">145 - 142 - Classes Utilitárias - IO pt 05 - BufferedReader</a>



[Voltar ao Índice](#indice)

---


## <a name="parte146">146 - 143 - Classes Utilitárias - IO pt 06 - File para diretórios</a>



[Voltar ao Índice](#indice)

---


## <a name="parte147">147 - 144 - Classes Utilitárias - NIO pt 01 - Path, Paths, Files pt 01</a>



[Voltar ao Índice](#indice)

---


## <a name="parte148">148 - 145 - Classes Utilitárias - NIO pt 02 - Path, Paths, Files pt 02</a>



[Voltar ao Índice](#indice)

---


## <a name="parte149">149 - 146 - Classes Utilitárias - NIO pt 03 - Normalização</a>



[Voltar ao Índice](#indice)

---


## <a name="parte150">150 - 147 - Classes Utilitárias - NIO pt 04 - Resolvendo Paths</a>



[Voltar ao Índice](#indice)

---


## <a name="parte151">151 - 148 - Classes Utilitárias - NIO pt 05 - Relativize</a>



[Voltar ao Índice](#indice)

---


## <a name="parte152">152 - 149 - Classes Utilitárias - NIO pt 06 - BasicFileAttributes pt 01</a>



[Voltar ao Índice](#indice)

---


## <a name="parte153">153 - 150 - Classes Utilitárias - NIO pt 07 - BasicFileAttributes pt 02</a>



[Voltar ao Índice](#indice)

---


## <a name="parte154">154 - 151 - Classes Utilitárias - NIO pt 08 - DosFileAttribute</a>



[Voltar ao Índice](#indice)

---


## <a name="parte155">155 - 152 - Classes Utilitárias - NIO pt 09 - PosixFileAttributes</a>



[Voltar ao Índice](#indice)

---


## <a name="parte156">156 - 153 - Classes Utilitárias - NIO pt 10 - DirectoryStream</a>



[Voltar ao Índice](#indice)

---


## <a name="parte157">157 - 154 - Classes Utilitárias - NIO pt 11 - SimpleFileVisitor pt 01</a>



[Voltar ao Índice](#indice)

---


## <a name="parte158">158 - 155 - Classes Utilitárias - NIO pt 12 - SimpleFileVisitor pt 02</a>



[Voltar ao Índice](#indice)

---


## <a name="parte159">159 - 156 - Classes Utilitárias - NIO pt 13 - PathMatcher pt 01</a>



[Voltar ao Índice](#indice)

---


## <a name="parte160">160 - 157 - Classes Utilitárias - NIO pt 14 - PathMatcher pt 02</a>



[Voltar ao Índice](#indice)

---


## <a name="parte161">161 - 158 - Classes Utilitárias - NIO pt 15 - ZipOutputStream</a>



[Voltar ao Índice](#indice)

---


## <a name="parte162">162 - 159 - Classes Utilitárias - Serialization pt 01</a>



[Voltar ao Índice](#indice)

---


## <a name="parte163">163 - 160 - Classes Utilitárias - Serialization pt 02</a>



[Voltar ao Índice](#indice)

---


## <a name="parte164">164 - 161 - Coleções pt 01 - equals pt 01</a>



[Voltar ao Índice](#indice)

---


## <a name="parte165">165 - 162 - Coleções pt 02 - equals pt 02</a>



[Voltar ao Índice](#indice)

---


## <a name="parte166">166 - 163 - Coleções pt 03 - hashCode pt 01</a>



[Voltar ao Índice](#indice)

---


## <a name="parte167">167 - 164 - Coleções pt 04 - hashCode pt 02</a>



[Voltar ao Índice](#indice)

---


## <a name="parte168">168 - 165 - Coleções pt 05 - Complexidade Big-O</a>



[Voltar ao Índice](#indice)

---


## <a name="parte169">169 - 166 - Coleções pt 06 - List pt 01</a>



[Voltar ao Índice](#indice)

---


## <a name="parte170">170 - 167 - Coleções pt 07 - List pt 02</a>



[Voltar ao Índice](#indice)

---


## <a name="parte171">171 - 168 - Coleções pt 08 - List pt 03</a>



[Voltar ao Índice](#indice)

---


## <a name="parte172">172 - 169 - Coleções pt 09 - Sorting lists pt 01</a>



[Voltar ao Índice](#indice)

---


## <a name="parte173">173 - 170 - Coleções pt 10 - Sorting lists pt 02 - Comparable</a>



[Voltar ao Índice](#indice)

---


## <a name="parte174">174 - 171 - Coleções pt 11 - Sorting lists pt 03 - Comparator</a>



[Voltar ao Índice](#indice)

---


## <a name="parte175">175 - 172 - Coleções pt 12 - Binary Search</a>



[Voltar ao Índice](#indice)

---


## <a name="parte176">176 - 173 - Coleções pt 13 - Conversão de Lista para Arrays e vice versa</a>



[Voltar ao Índice](#indice)

---


## <a name="parte177">177 - 174 - Coleções pt 14 - Iterator</a>



[Voltar ao Índice](#indice)

---


## <a name="parte178">178 - 175 - Coleções pt 15 - Set, HashSet</a>



[Voltar ao Índice](#indice)

---


## <a name="parte179">179 - 176 - Coleções pt 16 - NavigableSet, TreeSet pt 01</a>



[Voltar ao Índice](#indice)

---


## <a name="parte180">180 - 177 - Coleções pt 17 - NavigableSet, TreeSet pt 02</a>



[Voltar ao Índice](#indice)

---


## <a name="parte181">181 - 178 - Coleções pt 18 - Map, HashMap, LinkedHashMap pt 01</a>



[Voltar ao Índice](#indice)

---


## <a name="parte182">182 - 179 - Coleções pt 19 - Map, HashMap, LinkedHashMap pt 02</a>



[Voltar ao Índice](#indice)

---


## <a name="parte183">183 - 180 - Coleções pt 20 - Map, HashMap, LinkedHashMap pt 03</a>



[Voltar ao Índice](#indice)

---


## <a name="parte184">184 - 181 - Coleções pt 21 - NavigableMap, TreeMap</a>



[Voltar ao Índice](#indice)

---


## <a name="parte185">185 - 182 - Coleções pt 22 - Queue, PriorityQueue</a>



[Voltar ao Índice](#indice)

---


## <a name="parte186">186 - 183 - Generics pt 01 - Introdução</a>



[Voltar ao Índice](#indice)

---


## <a name="parte187">187 - 184 - Generics pt 02 - Wildcard pt 01</a>



[Voltar ao Índice](#indice)

---


## <a name="parte188">188 - 185 - Generics pt 03 - Wildcard pt 02</a>



[Voltar ao Índice](#indice)

---


## <a name="parte189">189 - 186 - Generics pt 04 - Classes Genéricas pt 01</a>



[Voltar ao Índice](#indice)

---


## <a name="parte190">190 - 187 - Generics pt 05 - Classes Genéricas pt 02</a>



[Voltar ao Índice](#indice)

---


## <a name="parte191">191 - 188 - Generics pt 06 - Métodos Genéricos</a>



[Voltar ao Índice](#indice)

---


## <a name="parte192">192 - 189 - Classes Internas pt 01 - Classes aninhadas</a>



[Voltar ao Índice](#indice)

---


## <a name="parte193">193 - 190 - Classes Internas pt 02 - Classes Locais</a>



[Voltar ao Índice](#indice)

---


## <a name="parte194">194 - 191 - Classes Internas pt 03 - Classes Anônimas</a>



[Voltar ao Índice](#indice)

---


## <a name="parte195">195 - 192 - Classes Internas pt 04 - Classes aninhadas estáticas</a>



[Voltar ao Índice](#indice)

---


## <a name="parte196">196 - 193 - Parametrizando comportamentos pt 01</a>



[Voltar ao Índice](#indice)

---


## <a name="parte197">197 - 194 - Parametrizando comportamentos pt 02</a>



[Voltar ao Índice](#indice)

---


## <a name="parte198">198 - 195 - Lambdas pt 01 - Predicate</a>



[Voltar ao Índice](#indice)

---


## <a name="parte199">199 - 196 - Lambdas pt 02 - Consumer</a>



[Voltar ao Índice](#indice)

---


## <a name="parte200">200 - 197 - Lambdas pt 03 - Function</a>



[Voltar ao Índice](#indice)

---


## <a name="parte201">201 - 198 - Method Reference pt 01 - Referência a métodos estáticos</a>



[Voltar ao Índice](#indice)

---


## <a name="parte202">202 - 199 - Method Reference pt 02 - Referência a métodos não estáticos</a>



[Voltar ao Índice](#indice)

---


## <a name="parte203">203 - 200 - Method Reference pt 03 - Referência a construtor</a>



[Voltar ao Índice](#indice)

---


## <a name="parte204">204 - 201 - Optional pt 01</a>



[Voltar ao Índice](#indice)

---


## <a name="parte205">205 - 202 - Optional pt 02</a>



[Voltar ao Índice](#indice)

---


## <a name="parte206">206 - 203 - Streams pt 01 - Introduction pt 01</a>



[Voltar ao Índice](#indice)

---


## <a name="parte207">207 - 204 - Streams pt 02 - Introduction pt 02</a>



[Voltar ao Índice](#indice)

---


## <a name="parte208">208 - 205 - Streams pt 03 - Introduction pt 03</a>



[Voltar ao Índice](#indice)

---


## <a name="parte209">209 - 206 - Streams pt 04 - FlatMap pt 01</a>



[Voltar ao Índice](#indice)

---


## <a name="parte210">210 - 207 - Streams pt 05 - FlatMap pt 02</a>



[Voltar ao Índice](#indice)

---


## <a name="parte211">211 - 208 - Streams pt 06 - Finding and Matching</a>



[Voltar ao Índice](#indice)

---


## <a name="parte212">212 - 209 - Streams pt 07 - Reduce pt 01</a>



[Voltar ao Índice](#indice)

---


## <a name="parte213">213 - 210 - Streams pt 08 - Reduce pt 02</a>



[Voltar ao Índice](#indice)

---


## <a name="parte214">214 - 211 - Streams pt 09 - Gerando streams pt 01</a>



[Voltar ao Índice](#indice)

---


## <a name="parte215">215 - 212 - Streams pt 10 - Gerando streams pt 02</a>



[Voltar ao Índice](#indice)

---


## <a name="parte216">216 - 213 - Streams pt 11 - Collectors pt 01 - Summarizing</a>



[Voltar ao Índice](#indice)

---


## <a name="parte217">217 - 214 - Streams pt 12 - Collectors pt 02 - Grouping by pt 01</a>



[Voltar ao Índice](#indice)

---


## <a name="parte218">218 - 215 - Streams pt 13 - Collectors pt 03 - Grouping by pt 02</a>



[Voltar ao Índice](#indice)

---


## <a name="parte219">219 - 216 - Streams pt 14 - Collectors pt 04 - Grouping by pt 03</a>



[Voltar ao Índice](#indice)

---


## <a name="parte220">220 - 217 - Streams pt 15 - Collectors pt 05 - Grouping by pt 04</a>



[Voltar ao Índice](#indice)

---


## <a name="parte221">221 - 218 - Streams pt 16 - Parallel Streams pt 01</a>



[Voltar ao Índice](#indice)

---


## <a name="parte222">222 - 219 - Streams pt 17 - Parallel Streams pt 02</a>



[Voltar ao Índice](#indice)

---


## <a name="parte223">223 - 220 - Threads pt 01 - Introduction</a>



[Voltar ao Índice](#indice)

---


## <a name="parte224">224 - 221 - Threads pt 02 - Estados das threads</a>



[Voltar ao Índice](#indice)

---


## <a name="parte225">225 - 222 - Threads pt 03 - Prioridade e Sleep</a>



[Voltar ao Índice](#indice)

---


## <a name="parte226">226 - 223 - Threads pt 04 - Yield e Join</a>



[Voltar ao Índice](#indice)

---


## <a name="parte227">227 - 224 - Threads pt 05 - Sincronismo de thread pt 01</a>



[Voltar ao Índice](#indice)

---


## <a name="parte228">228 - 225 - Threads pt 06 - Sincronismo de thread pt 02</a>



[Voltar ao Índice](#indice)

---


## <a name="parte229">229 - 226 - Threads pt 07 - Sincronismo de thread pt 03 - Classes thread safe</a>



[Voltar ao Índice](#indice)

---


## <a name="parte230">230 - 227 - Threads pt 08 - Sincronismo de thread pt 04 - Deadlock</a>



[Voltar ao Índice](#indice)

---


## <a name="parte231">231 - 228 - Threads pt 09 - Sincronismo de thread pt 05 - Wait, notify e notifyAll</a>



[Voltar ao Índice](#indice)

---


## <a name="parte232">232 - 229 - Concorrência pt 01 - AtomicInteger</a>



[Voltar ao Índice](#indice)

---


## <a name="parte233">233 - 230 - Concorrência pt 02 - Lock and ReentrantLock</a>



[Voltar ao Índice](#indice)

---


## <a name="parte234">234 - 231 - Concorrência pt 03 - Conditions</a>



[Voltar ao Índice](#indice)

---


## <a name="parte235">235 - 232 - Concorrência pt 04 - ReentrantReadWriteLock</a>



[Voltar ao Índice](#indice)

---


## <a name="parte236">236 - 233 - Concorrência pt 05 - CopyOnWriteArrayList</a>



[Voltar ao Índice](#indice)

---


## <a name="parte237">237 - 234 - Concorrência pt 06 - ArrayBlockingQueue</a>



[Voltar ao Índice](#indice)

---


## <a name="parte238">238 - 235 - Concorrência pt 07 - LinkedTransferQueue</a>



[Voltar ao Índice](#indice)

---


## <a name="parte239">239 - 236 - Concorrência pt 08 - Executors pt 01 - Thread Pools</a>



[Voltar ao Índice](#indice)

---


## <a name="parte240">240 - 237 - Concorrência pt 09 - Executors pt 02 - ScheduledExecutorService</a>



[Voltar ao Índice](#indice)

---


## <a name="parte241">241 - 238 - Concorrência pt 10 - Executors pt 03 - Interface Callable</a>



[Voltar ao Índice](#indice)

---


## <a name="parte242">242 - 239 - Concorrência pt 11 - Executors pt 04 - Future</a>



[Voltar ao Índice](#indice)

---


## <a name="parte243">243 - 240 - Concorrência pt 12 - CompletableFuture pt 01 - get and join</a>



[Voltar ao Índice](#indice)

---


## <a name="parte244">244 - 241 - Concorrência pt 13 - CompletableFuture pt 02 - streams</a>



[Voltar ao Índice](#indice)

---


## <a name="parte245">245 - 242 - Concorrência pt 14 - CompletableFuture pt 03 - ThreadFactory</a>



[Voltar ao Índice](#indice)

---


## <a name="parte246">246 - 243 - Concorrência pt 15 - CompletableFuture pt 04 - Encadeando chamadas pt 01</a>



[Voltar ao Índice](#indice)

---


## <a name="parte247">247 - 244 - Concorrência pt 16 - CompletableFuture pt 05 - Encadeando chamadas pt 02</a>



[Voltar ao Índice](#indice)

---


## <a name="parte248">248 - 245 - Concorrência pt 17 - CompletableFuture pt 06 - allOf, anyOf</a>



[Voltar ao Índice](#indice)

---


## <a name="parte249">249 - 246 - Padrões de Projeto pt 01 - Builder</a>



[Voltar ao Índice](#indice)

---


## <a name="parte250">250 - 247 - Padrões de Projeto pt 02 - Factory</a>



[Voltar ao Índice](#indice)

---


## <a name="parte251">251 - 248 - Padrões de Projeto pt 03 - Singleton pt 01 - Eager Initialization</a>



[Voltar ao Índice](#indice)

---


## <a name="parte252">252 - 249 - Padrões de Projeto pt 04 - Singleton pt 02 - Lazy Initialization</a>



[Voltar ao Índice](#indice)

---


## <a name="parte253">253 - 250 - Padrões de Projeto pt 05 - Singleton pt 03 - Singleton with enumeration</a>



[Voltar ao Índice](#indice)

---


## <a name="parte254">254 - 251 - Padrões de Projeto pt 06 - Data Transfer Object</a>



[Voltar ao Índice](#indice)

---


## <a name="parte255">255 - 252 - JDBC pt 01 - Instalando Docker</a>



[Voltar ao Índice](#indice)

---


## <a name="parte256">256 - 253 - JDBC pt 02 - Criando container MySQL</a>



[Voltar ao Índice](#indice)

---


## <a name="parte257">257 - 254 - JDBC pt 03 - Instalando Workbench, criando schema e tabelas</a>



[Voltar ao Índice](#indice)

---


## <a name="parte258">258 - 255 - JDBC pt 04 - Instalando e adicionando maven ao projeto</a>



[Voltar ao Índice](#indice)

---


## <a name="parte259">259 - 256 - JDBC pt 05 - Adicionando dependência e conectando com banco</a>



[Voltar ao Índice](#indice)

---


## <a name="parte260">260 - 257 - JDBC pt 06 - Inserindo dados com Statement</a>



[Voltar ao Índice](#indice)

---


## <a name="parte261">261 - 258 - JDBC pt 07 - Lombok e Log4J2</a>



[Voltar ao Índice](#indice)

---


## <a name="parte262">262 - 259 - JDBC pt 08 - Deletando dados com Statement</a>



[Voltar ao Índice](#indice)

---


## <a name="parte263">263 - 260 - JDBC pt 09 - Atualizando dados com Statement</a>



[Voltar ao Índice](#indice)

---


## <a name="parte264">264 - 261 - JDBC pt 10 - Buscando dados com ResultSet pt 01 - findAll</a>



[Voltar ao Índice](#indice)

---


## <a name="parte265">265 - 262 - JDBC pt 11 - Buscando dados com ResultSet pt 02 - findByName</a>



[Voltar ao Índice](#indice)

---


## <a name="parte266">266 - 263 - JDBC pt 12 - ResultSetMetaData</a>



[Voltar ao Índice](#indice)

---


## <a name="parte267">267 - 264 - JDBC pt 13 - DatabaseMetaData</a>



[Voltar ao Índice](#indice)

---


## <a name="parte268">268 - 265 - JDBC pt 14 - ResultSet.TYPE_SCROLL_INSENSITIVE</a>



[Voltar ao Índice](#indice)

---


## <a name="parte269">269 - 266 - JDBC pt 15 - Atualizando registros com ResultSet</a>



[Voltar ao Índice](#indice)

---


## <a name="parte270">270 - 267 - JDBC pt 16 - Inserindo e deletando registros com ResultSet</a>



[Voltar ao Índice](#indice)

---


## <a name="parte271">271 - 268 - JDBC pt 17 - PreparedStatement pt 01</a>



[Voltar ao Índice](#indice)

---


## <a name="parte272">272 - 269 - JDBC pt 18 - PreparedStatement pt 02</a>



[Voltar ao Índice](#indice)

---


## <a name="parte273">273 - 270 - JDBC pt 19 - CallableStatement</a>



[Voltar ao Índice](#indice)

---


## <a name="parte274">274 - 271 - JDBC pt 20 - Connected RowSet - JdbcRowSet pt 01</a>



[Voltar ao Índice](#indice)

---


## <a name="parte275">275 - 272 - JDBC pt 21 - Connected RowSet - JdbcRowSet pt 02</a>



[Voltar ao Índice](#indice)

---


## <a name="parte276">276 - 273 - JDBC pt 22 - Disconnected RowSet - CachedRowSet</a>



[Voltar ao Índice](#indice)

---


## <a name="parte277">277 - 274 - JDBC pt 23 - Transação</a>



[Voltar ao Índice](#indice)

---


## <a name="parte278">278 - 275 - JDBC pt 24 - CRUD pt 01 - findByName and findAll</a>



[Voltar ao Índice](#indice)

---


## <a name="parte279">279 - 276 - JDBC pt 25 - CRUD pt 02 - delete</a>



[Voltar ao Índice](#indice)

---


## <a name="parte280">280 - 277 - JDBC pt 26 - CRUD pt 03 - save</a>



[Voltar ao Índice](#indice)

---


## <a name="parte281">281 - 278 - JDBC pt 27 - CRUD pt 04 - update</a>



[Voltar ao Índice](#indice)

---


## <a name="parte282">282 - 279 - JDBC pt 28 - CRUD pt 05 - Anime Crud</a>



[Voltar ao Índice](#indice)

---


## <a name="parte283">283 - 280 - Testes unitários com jUnit pt 01</a>



[Voltar ao Índice](#indice)

---


## <a name="parte284">284 - 281 - Testes unitários com jUnit pt 02</a>



[Voltar ao Índice](#indice)

---


## <a name="parte285">285 - 282 - Atualizando JDK</a>



[Voltar ao Índice](#indice)

---


## <a name="parte286">286 - 283 - Record Class</a>



[Voltar ao Índice](#indice)

---


## <a name="parte287">287 - 284 - Pattern Matching for instanceof</a>



[Voltar ao Índice](#indice)

---


## <a name="parte288">288 - 285 - É só correr pro abraço</a>



[Voltar ao Índice](#indice)

---