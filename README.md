
# Maratona Java Virado No Jiraya - DevDojo Academy

https://www.youtube.com/playlist?list=PL62G310vn6nFIsOCC0H-C2infYgwm8SWW

Créditos: Melhor, maior, e o mais completo curso de Java em português grátis de toda Internet está de volta. Maratona Java Virado No Jiraya. Regravado desde a aula 0, com extrema qualidade, utilizando a última versão do Java, com fonte 22 e fundo branco celestial. FAQ Q. Quem criou? A. O cara com um parafuso a menos que colocou um curso desses gratuito foi esse aqui: https://www.linkedin.com/in/williamsuane/ Q. Quem editou os vídeos? A. O irmão do cara com um parafuso a menos, que também tem um parafuso a menos, já que editou de graça: https://www.linkedin.com/in/wildneisuane/

FONTE RESUMO: Deepseek/CHATGPT/COPILOT

## <a name="indice">Índice</a>

001. [000 - Maratona Java Virado No Jiraya - Bem-vindo](#parte1)
002. [001 - O que esperar do curso](#parte2)
003. [002 - Como Java Funciona](#parte3)
004. [003 - Fazendo o download da JDK 15](#parte4)
005. [004 - Configurando variaveis de ambiente](#parte5)
006. [005 - Executando compilação manualmente](#parte6)
007. [006 - Download da IDE IntelliJ Community](#parte7)
008. [007 - Conhecendo a IDE IntelliJ Community](#parte8)
009. [008 - Organizando o código em pacotes](#parte9)
010. [009 - Comentários](#parte10)
011. [010 - Tipos primitivos pt 01 - convenções de variáveis](#parte11)
012. [011 - Tipos primitivos pt 02 - declaração e tamanho em memória](#parte12)
013. [012 - Tipos primitivos pt 03 - casting](#parte13)
014. [013 - Tipos primitivos pt 04 - Strings](#parte14)
015. [014 - Tipos primitivos pt 05 - Exercício](#parte15)
016. [015 - Operadores pt 01 - Aritiméticos](#parte16)
017. [016 - Operadores pt 02 - Relacionais](#parte17)
018. [017 - Operadores pt 03 - Lógicos AND](#parte18)
019. [018 - Operadores pt 04 - Lógicos OR](#parte19)
020. [019 - Operadores pt 05 - Atribuição](#parte20)
021. [020 - Estruturas Condicionais pt 01 - IF](#parte21)
022. [021 - Estruturas Condicionais pt 02 - ELSE IF](#parte22)
023. [022 - Estruturas Condicionais pt 03 - Operador ternário](#parte23)
024. [023 - Estruturas Condicionais pt 04 - Tabela Verdade e exercício](#parte24)
025. [024 - Estruturas Condicionais pt 05 - Resolução do exercícios](#parte25)
026. [025 - Estruturas Condicionais pt 06 - Switch](#parte26)
027. [026 - Estruturas Condicionais pt 07 - Switch exercício](#parte27)
028. [027 - Estruturas de Repetição pt 01 - Laços de repetição while, do while, for](#parte28)
029. [028 - Estruturas de Repetição pt 02 - Exercício for](#parte29)
030. [029 - Estruturas de Repetição pt 03 - Break](#parte30)
031. [030 - Estruturas de Repetição pt 04 - Exercício Break](#parte31)
032. [031 - Estruturas de Repetição pt 05 - Continue](#parte32)
033. [032 - Arrays pt 01](#parte33)
034. [033 - Arrays pt 02](#parte34)
035. [034 - Arrays pt 03](#parte35)
036. [035 - Arrays pt 04 - Foreach](#parte36)
037. [036 - Arrays Multidimensionais pt 01](#parte37)
038. [037 - Arrays Multidimensionais pt 02 - Foreach](#parte38)
039. [038 - Arrays Multidimensionais pt 03 - Inicialização](#parte39)
040. [039 - Orientação Objetos pt 01 - Introdução classes pt 01](#parte40)
041. [040 - Orientação Objetos - Introdução classes pt 02](#parte41)
042. [041 - Orientação Objetos - Coesão](#parte42)
043. [042 - Orientação Objetos - Exercício Classes](#parte43)
044. [043 - Orientação Objetos - Referência de objetos](#parte44)
045. [044 - Orientação Objetos - Métodos pt 01](#parte45)
046. [045 - Orientação Objetos - Métodos pt 02 - Parâmetros](#parte46)
047. [046 - Orientação Objetos - Métodos pt 03 - Retorno pt 01](#parte47)
048. [047 - Orientação Objetos - Métodos pt 04 - Retorno pt 02](#parte48)
049. [048 - Orientação Objetos - Métodos pt 05 - Parâmetros tipo primitivo](#parte49)
050. [049 - Orientação Objetos - Métodos pt 06 - Parâmetros tipo referência](#parte50)
051. [050 - Orientação Objetos - Métodos pt 07 - Parâmetros tipo referência pt 02](#parte51)
052. [051 - Orientação Objetos - Métodos pt 08 - Referência this](#parte52)
053. [052 - Orientação Objetos - Métodos pt 09 - Varargs](#parte53)
054. [053 - Orientação Objetos - Métodos pt 10 - Exercise](#parte54)
055. [054 - Orientação Objetos - Modificador de acesso private, get e set pt 01](#parte55)
056. [055 - Orientação Objetos - Modificador de acesso private, get e set pt 02](#parte56)
057. [056 - Orientação Objetos - Modificador de acesso private, get e set pt 03](#parte57)
058. [057 - Orientação Objetos - Sobrecarga de métodos](#parte58)
059. [058 - Orientação Objetos - Construtores pt 01](#parte59)
060. [059 - Orientação Objetos - Construtores pt 02 - Sobrecarga](#parte60)
061. [060 - Orientação Objetos - Blocos de inicialização](#parte61)
062. [061 - Orientação Objetos - Modificador static](#parte62)
063. [062 - Orientação Objetos - Métodos estáticos](#parte63)
064. [063 - Orientação Objetos - Bloco de inicialização estático](#parte64)
065. [064 - Orientação Objetos - Associação pt 01 - Arrays com Objetos](#parte65)
066. [065 - Orientação Objetos - Associação pt 02 - Associação unidirecional um para muitos](#parte66)
067. [066 - Orientação Objetos - Associação pt 03 - Associação unidirecional muitos para um](#parte67)
068. [067 - Orientação Objetos - Associação pt 04 - Associação bidirecional](#parte68)
069. [068 - Orientação Objetos - Leitura de dados pelo console](#parte69)
070. [069 - Orientação Objetos - Exercício leitura de dados do teclado](#parte70)
071. [068 - Orientação Objetos - Leitura de dados pelo console](#parte71)
072. [069 - Orientação Objetos - Exercício leitura de dados do teclado](#parte72)
073. [070 - Orientação Objetos - Associação pt 05 - Exercício Associação](#parte73)
074. [071 - Orientação Objetos - Herança pt 01](#parte74)
075. [072 - Orientação Objetos - Herança pt 02 - Super](#parte75)
076. [073 - Orientação Objetos - Herança pt 03 - protected](#parte76)
077. [074 - Orientação Objetos - Herança pt 04 - Construtores](#parte77)
078. [075 - Orientação Objetos - Herança pt 05 - Sequência de inicialização](#parte78)
079. [076 - Orientação Objetos - Sobrescrita do método toString](#parte79)
080. [077 - Orientação Objetos - Modificador final pt 01 - Tipo primitivo](#parte80)
081. [078 - Orientação Objetos - Modificador final pt 02 - Tipo referência](#parte81)
082. [079 - Orientação Objetos - Modificador final pt 03 - Classes e métodos](#parte82)
083. [080 - Orientação Objetos - Enumeração pt 01 - Introdução](#parte83)
084. [081 - Orientação Objetos - Enumeração pt 02 - Construtores e atributos](#parte84)
085. [082 - Orientação Objetos - Enumeração pt 03 - Sobrescrita de métodos](#parte85)
086. [083 - Orientação Objetos - Enumeração pt 04 - Busca por atributos](#parte86)
087. [084 - Orientação Objetos - Classes abstratas pt 01](#parte87)
088. [085 - Orientação Objetos - Classes abstratas pt 02 - Métodos abstratos](#parte88)
089. [086 - Orientação Objetos - Classes abstratas pt 03 - Métodos abstratos regras](#parte89)
090. [087 - Orientação Objetos - Interfaces pt 01 - Introdução](#parte90)
091. [088 - Orientação Objetos - Interfaces pt 02 - Implementando múltiplas interfaces](#parte91)
092. [089 - Orientação Objetos - Interfaces pt 03 - Atributos e métodos estáticos](#parte92)
093. [090 - Orientação Objetos - Polimorfismo pt 01 - Introdução](#parte93)
094. [091 - Orientação Objetos - Polimorfismo pt 02 - Funcionamento](#parte94)
095. [092 - Orientação Objetos - Polimorfismo pt 03 - Parâmetros polimórficos](#parte95)
096. [093 - Orientação Objetos - Polimorfismo pt 04 - Cast e instanceof](#parte96)
097. [094 - Orientação Objetos - Polimorfismo pt 05 - Programação orientada a interface](#parte97)
098. [095 - Exceções pt 01 - Errors](#parte98)
099. [096 - Exceções pt 02 - RuntimeException](#parte99)
100. [097 - Exceções pt 03 - Exception](#parte100)
101. [098 - Exceções pt 04 - Lançando exceção unchecked](#parte101)
102. [099 - Exceções pt 05 - Lançando exceção checked](#parte102)
103. [100 - Exceções pt 06 - Bloco Finally](#parte103)
104. [101 - Exceções pt 07 - Capturando múltiplas exceções](#parte104)
105. [102 - Exceções pt 08 - Multi catch em linha](#parte105)
106. [103 - Exceções pt 09 - Try with resources](#parte106)
107. [104 - Exceções pt 10 - Exceção customizada](#parte107)
108. [105 - Exceções pt 11 - Exceção e regras de sobrescrita](#parte108)
109. [106 - Classes Utilitárias - Wrappers pt 01](#parte109)
110. [107 - Classes Utilitárias - Wrappers pt 02](#parte110)
111. [108 - Classes Utilitárias - Strings pt 01](#parte111)
112. [109 - Classes Utilitárias - Strings pt 02](#parte112)
113. [110 - Classes Utilitárias - Strings pt 03 - Desempenho](#parte113)
114. [111 - Classes Utilitárias - Strings pt 04 - StringBuilder](#parte114)
115. [112 - Classes Utilitárias - Date](#parte115)
116. [113 - Classes Utilitárias - Calendar](#parte116)
117. [114 - Classes Utilitárias - DateFormat](#parte117)
118. [115 - Classes Utilitárias - Internacionalização Datas com Locale](#parte118)
119. [116 - Classes Utilitárias - Internacionalização Números com Locale](#parte119)
120. [117 - Classes Utilitárias - Internacionalização de moeda com Locale](#parte120)
121. [118 - Classes Utilitárias - SimpleDateFormat](#parte121)
122. [119 - Classes Utilitárias - LocalDate](#parte122)
123. [120 - Classes Utilitárias - LocalTime](#parte123)
124. [121 - Classes Utilitárias - LocalDateTime](#parte124)
125. [122 - Classes Utilitárias - Instant](#parte125)
126. [123 - Classes Utilitárias - Duration](#parte126)
127. [124 - Classes Utilitárias - Period](#parte127)
128. [125 - Classes Utilitárias - ChronoUnit](#parte128)
129. [126 - Classes Utilitárias - TemporalAdjusters](#parte129)
130. [127 - Classes Utilitárias - TemporalAdjuster](#parte130)
131. [128 - Classes Utilitárias - ZonedDateTime, ZoneId, OffsetDateTime](#parte131)
132. [129 - Classes Utilitárias - DateTimeFormatter](#parte132)
133. [130 - Classes Utilitárias - ResourceBundle](#parte133)
134. [131 - Classes Utilitárias - Regex pt 01 - Pattern e Matcher](#parte134)
135. [132 - Classes Utilitárias - Regex pt 02 - Pattern e Matcher - Meta caracteres](#parte135)
136. [133 - Classes Utilitárias - Regex pt 03 - Pattern e Matcher - Range](#parte136)
137. [134 - Classes Utilitárias - Regex pt 04 - Pattern e Matcher - Quantificadores pt 01](#parte137)
138. [135 - Classes Utilitárias - Regex pt 05 - Pattern e Matcher - Quantificadores pt 02](#parte138)
139. [136 - Classes Utilitárias - Regex pt 06 - Pattern e Matcher - Anchor](#parte139)
140. [137 - Classes Utilitárias - Scanner - Tokens e Delimitadores](#parte140)
141. [138 - Classes Utilitárias - IO pt 01 - File](#parte141)
142. [139 - Classes Utilitárias - IO pt 02 - FileWriter](#parte142)
143. [140 - Classes Utilitárias - IO pt 03 - FileReader](#parte143)
144. [141 - Classes Utilitárias - IO pt 04 - BufferedWriter](#parte144)
145. [142 - Classes Utilitárias - IO pt 05 - BufferedReader](#parte145)
146. [143 - Classes Utilitárias - IO pt 06 - File para diretórios](#parte146)
147. [144 - Classes Utilitárias - NIO pt 01 - Path, Paths, Files pt 01](#parte147)
148. [145 - Classes Utilitárias - NIO pt 02 - Path, Paths, Files pt 02](#parte148)
149. [146 - Classes Utilitárias - NIO pt 03 - Normalização](#parte149)
150. [147 - Classes Utilitárias - NIO pt 04 - Resolvendo Paths](#parte150)
151. [148 - Classes Utilitárias - NIO pt 05 - Relativize](#parte151)
152. [149 - Classes Utilitárias - NIO pt 06 - BasicFileAttributes pt 01](#parte152)
153. [150 - Classes Utilitárias - NIO pt 07 - BasicFileAttributes pt 02](#parte153)
154. [151 - Classes Utilitárias - NIO pt 08 - DosFileAttribute](#parte154)
155. [152 - Classes Utilitárias - NIO pt 09 - PosixFileAttributes](#parte155)
156. [153 - Classes Utilitárias - NIO pt 10 - DirectoryStream](#parte156)
157. [154 - Classes Utilitárias - NIO pt 11 - SimpleFileVisitor pt 01](#parte157)
158. [155 - Classes Utilitárias - NIO pt 12 - SimpleFileVisitor pt 02](#parte158)
159. [156 - Classes Utilitárias - NIO pt 13 - PathMatcher pt 01](#parte159)
160. [157 - Classes Utilitárias - NIO pt 14 - PathMatcher pt 02](#parte160)
161. [158 - Classes Utilitárias - NIO pt 15 - ZipOutputStream](#parte161)
162. [159 - Classes Utilitárias - Serialization pt 01](#parte162)
163. [160 - Classes Utilitárias - Serialization pt 02](#parte163)
164. [161 - Coleções pt 01 - equals pt 01](#parte164)
165. [162 - Coleções pt 02 - equals pt 02](#parte165)
166. [163 - Coleções pt 03 - hashCode pt 01](#parte166)
167. [164 - Coleções pt 04 - hashCode pt 02](#parte167)
168. [165 - Coleções pt 05 - Complexidade Big-O](#parte168)
169. [166 - Coleções pt 06 - List pt 01](#parte169)
170. [167 - Coleções pt 07 - List pt 02](#parte170)
171. [168 - Coleções pt 08 - List pt 03](#parte171)
172. [169 - Coleções pt 09 - Sorting lists pt 01](#parte172)
173. [170 - Coleções pt 10 - Sorting lists pt 02 - Comparable](#parte173)
174. [171 - Coleções pt 11 - Sorting lists pt 03 - Comparator](#parte174)
175. [172 - Coleções pt 12 - Binary Search](#parte175)
176. [173 - Coleções pt 13 - Conversão de Lista para Arrays e vice versa](#parte176)
177. [174 - Coleções pt 14 - Iterator](#parte177)
178. [175 - Coleções pt 15 - Set, HashSet](#parte178)
179. [176 - Coleções pt 16 - NavigableSet, TreeSet pt 01](#parte179)
180. [177 - Coleções pt 17 - NavigableSet, TreeSet pt 02](#parte180)
181. [178 - Coleções pt 18 - Map, HashMap, LinkedHashMap pt 01](#parte181)
182. [179 - Coleções pt 19 - Map, HashMap, LinkedHashMap pt 02](#parte182)
183. [180 - Coleções pt 20 - Map, HashMap, LinkedHashMap pt 03](#parte183)
184. [181 - Coleções pt 21 - NavigableMap, TreeMap](#parte184)
185. [182 - Coleções pt 22 - Queue, PriorityQueue](#parte185)
186. [183 - Generics pt 01 - Introdução](#parte186)
187. [184 - Generics pt 02 - Wildcard pt 01](#parte187)
188. [185 - Generics pt 03 - Wildcard pt 02](#parte188)
189. [186 - Generics pt 04 - Classes Genéricas pt 01](#parte189)
190. [187 - Generics pt 05 - Classes Genéricas pt 02](#parte190)
191. [188 - Generics pt 06 - Métodos Genéricos](#parte191)
192. [189 - Classes Internas pt 01 - Classes aninhadas](#parte192)
193. [190 - Classes Internas pt 02 - Classes Locais](#parte193)
194. [191 - Classes Internas pt 03 - Classes Anônimas](#parte194)
195. [192 - Classes Internas pt 04 - Classes aninhadas estáticas](#parte195)
196. [193 - Parametrizando comportamentos pt 01](#parte196)
197. [194 - Parametrizando comportamentos pt 02](#parte197)
198. [195 - Lambdas pt 01 - Predicate](#parte198)
199. [196 - Lambdas pt 02 - Consumer](#parte199)
200. [197 - Lambdas pt 03 - Function](#parte200)
201. [198 - Method Reference pt 01 - Referência a métodos estáticos](#parte201)
202. [199 - Method Reference pt 02 - Referência a métodos não estáticos](#parte202)
203. [200 - Method Reference pt 03 - Referência a construtor](#parte203)
204. [201 - Optional pt 01](#parte204)
205. [202 - Optional pt 02](#parte205)
206. [203 - Streams pt 01 - Introduction pt 01](#parte206)
207. [204 - Streams pt 02 - Introduction pt 02](#parte207)
208. [205 - Streams pt 03 - Introduction pt 03](#parte208)
209. [206 - Streams pt 04 - FlatMap pt 01](#parte209)
210. [207 - Streams pt 05 - FlatMap pt 02](#parte210)
211. [208 - Streams pt 06 - Finding and Matching](#parte211)
212. [209 - Streams pt 07 - Reduce pt 01](#parte212)
213. [210 - Streams pt 08 - Reduce pt 02](#parte213)
214. [211 - Streams pt 09 - Gerando streams pt 01](#parte214)
215. [212 - Streams pt 10 - Gerando streams pt 02](#parte215)
216. [213 - Streams pt 11 - Collectors pt 01 - Summarizing](#parte216)
217. [214 - Streams pt 12 - Collectors pt 02 - Grouping by pt 01](#parte217)
218. [215 - Streams pt 13 - Collectors pt 03 - Grouping by pt 02](#parte218)
219. [216 - Streams pt 14 - Collectors pt 04 - Grouping by pt 03](#parte219)
220. [217 - Streams pt 15 - Collectors pt 05 - Grouping by pt 04](#parte220)
221. [218 - Streams pt 16 - Parallel Streams pt 01](#parte221)
222. [219 - Streams pt 17 - Parallel Streams pt 02](#parte222)
223. [220 - Threads pt 01 - Introduction](#parte223)
224. [221 - Threads pt 02 - Estados das threads](#parte224)
225. [222 - Threads pt 03 - Prioridade e Sleep](#parte225)
226. [223 - Threads pt 04 - Yield e Join](#parte226)
227. [224 - Threads pt 05 - Sincronismo de thread pt 01](#parte227)
228. [225 - Threads pt 06 - Sincronismo de thread pt 02](#parte228)
229. [226 - Threads pt 07 - Sincronismo de thread pt 03 - Classes thread safe](#parte229)
230. [227 - Threads pt 08 - Sincronismo de thread pt 04 - Deadlock](#parte230)
231. [228 - Threads pt 09 - Sincronismo de thread pt 05 - Wait, notify e notifyAll](#parte231)
232. [229 - Concorrência pt 01 - AtomicInteger](#parte232)
233. [230 - Concorrência pt 02 - Lock and ReentrantLock](#parte233)
234. [231 - Concorrência pt 03 - Conditions](#parte234)
235. [232 - Concorrência pt 04 - ReentrantReadWriteLock](#parte235)
236. [233 - Concorrência pt 05 - CopyOnWriteArrayList](#parte236)
237. [234 - Concorrência pt 06 - ArrayBlockingQueue](#parte237)
238. [235 - Concorrência pt 07 - LinkedTransferQueue](#parte238)
239. [236 - Concorrência pt 08 - Executors pt 01 - Thread Pools](#parte239)
240. [237 - Concorrência pt 09 - Executors pt 02 - ScheduledExecutorService](#parte240)
241. [238 - Concorrência pt 10 - Executors pt 03 - Interface Callable](#parte241)
242. [239 - Concorrência pt 11 - Executors pt 04 - Future](#parte242)
243. [240 - Concorrência pt 12 - CompletableFuture pt 01 - get and join](#parte243)
244. [241 - Concorrência pt 13 - CompletableFuture pt 02 - streams](#parte244)
245. [242 - Concorrência pt 14 - CompletableFuture pt 03 - ThreadFactory](#parte245)
246. [243 - Concorrência pt 15 - CompletableFuture pt 04 - Encadeando chamadas pt 01](#parte246)
247. [244 - Concorrência pt 16 - CompletableFuture pt 05 - Encadeando chamadas pt 02](#parte247)
248. [245 - Concorrência pt 17 - CompletableFuture pt 06 - allOf, anyOf](#parte248)
249. [246 - Padrões de Projeto pt 01 - Builder](#parte249)
250. [247 - Padrões de Projeto pt 02 - Factory](#parte250)
251. [248 - Padrões de Projeto pt 03 - Singleton pt 01 - Eager Initialization](#parte251)
252. [249 - Padrões de Projeto pt 04 - Singleton pt 02 - Lazy Initialization](#parte252)
253. [250 - Padrões de Projeto pt 05 - Singleton pt 03 - Singleton with enumeration](#parte253)
254. [251 - Padrões de Projeto pt 06 - Data Transfer Object](#parte254)
255. [252 - JDBC pt 01 - Instalando Docker](#parte255)
256. [253 - JDBC pt 02 - Criando container MySQL](#parte256)
257. [254 - JDBC pt 03 - Instalando Workbench, criando schema e tabelas](#parte257)
258. [255 - JDBC pt 04 - Instalando e adicionando maven ao projeto](#parte258)
259. [256 - JDBC pt 05 - Adicionando dependência e conectando com banco](#parte259)
260. [257 - JDBC pt 06 - Inserindo dados com Statement](#parte260)
261. [258 - JDBC pt 07 - Lombok e Log4J2](#parte261)
262. [259 - JDBC pt 08 - Deletando dados com Statement](#parte262)
263. [260 - JDBC pt 09 - Atualizando dados com Statement](#parte263)
264. [261 - JDBC pt 10 - Buscando dados com ResultSet pt 01 - findAll](#parte264)
265. [262 - JDBC pt 11 - Buscando dados com ResultSet pt 02 - findByName](#parte265)
266. [263 - JDBC pt 12 - ResultSetMetaData](#parte266)
267. [264 - JDBC pt 13 - DatabaseMetaData](#parte267)
268. [265 - JDBC pt 14 - ResultSet.TYPE_SCROLL_INSENSITIVE](#parte268)
269. [266 - JDBC pt 15 - Atualizando registros com ResultSet](#parte269)
270. [267 - JDBC pt 16 - Inserindo e deletando registros com ResultSet](#parte270)
271. [268 - JDBC pt 17 - PreparedStatement pt 01](#parte271)
272. [269 - JDBC pt 18 - PreparedStatement pt 02](#parte272)
273. [270 - JDBC pt 19 - CallableStatement](#parte273)
274. [271 - JDBC pt 20 - Connected RowSet - JdbcRowSet pt 01](#parte274)
275. [272 - JDBC pt 21 - Connected RowSet - JdbcRowSet pt 02](#parte275)
276. [273 - JDBC pt 22 - Disconnected RowSet - CachedRowSet](#parte276)
277. [274 - JDBC pt 23 - Transação](#parte277)
278. [275 - JDBC pt 24 - CRUD pt 01 - findByName and findAll](#parte278)
279. [276 - JDBC pt 25 - CRUD pt 02 - delete](#parte279)
280. [277 - JDBC pt 26 - CRUD pt 03 - save](#parte280)
281. [278 - JDBC pt 27 - CRUD pt 04 - update](#parte281)
282. [279 - JDBC pt 28 - CRUD pt 05 - Anime Crud](#parte282)
283. [280 - Testes unitários com jUnit pt 01](#parte283)
284. [281 - Testes unitários com jUnit pt 02](#parte284)
285. [282 - Atualizando JDK](#parte285)
286. [283 - Record Class](#parte286)
287. [284 - Pattern Matching for instanceof](#parte287)
288. [285 - É só correr pro abraço](#parte288)
---


## <a name="parte1">1 - 000 - Maratona Java Virado No Jiraya - Bem-vindo</a>

https://www.youtube.com/watch?v=VKjFuX91G5Q



[Voltar ao Índice](#indice)

---


## <a name="parte2">2 - 001 - O que esperar do curso</a>

https://www.youtube.com/watch?v=ooCqalwSpuE&list=PL62G310vn6nFIsOCC0H-C2infYgwm8SWW&index=2

[Voltar ao Índice](#indice)

---


## <a name="parte3">3 - 002 - Como Java Funciona</a>

https://www.youtube.com/watch?v=ooCqalwSpuE&list=PL62G310vn6nFIsOCC0H-C2infYgwm8SWW&index=2

[Voltar ao Índice](#indice)

---


## <a name="parte4">4 - 003 - Fazendo o download da JDK 15</a>

https://www.youtube.com/watch?v=Tsyeybeh968&list=PL62G310vn6nFIsOCC0H-C2infYgwm8SWW&index=4

https://www.codejava.net/java-se/java-se-versions-history



[Voltar ao Índice](#indice)

---


## <a name="parte5">5 - 004 - Configurando variaveis de ambiente</a>

https://www.youtube.com/watch?v=xzAESAp_soQ&list=PL62G310vn6nFIsOCC0H-C2infYgwm8SWW&index=5

[Voltar ao Índice](#indice)

---


## <a name="parte6">6 - 005 - Executando compilação manualmente</a>

https://www.youtube.com/watch?v=E64JTsEyXCM&list=PL62G310vn6nFIsOCC0H-C2infYgwm8SWW&index=6

[Voltar ao Índice](#indice)

---


## <a name="parte7">7 - 006 - Download da IDE IntelliJ Community</a>

https://www.youtube.com/watch?v=uB5Qbm-RMyU&list=PL62G310vn6nFIsOCC0H-C2infYgwm8SWW&index=7

[Voltar ao Índice](#indice)

---


## <a name="parte8">8 - 007 - Conhecendo a IDE IntelliJ Community</a>

https://www.youtube.com/watch?v=ds3t9C2A50U&list=PL62G310vn6nFIsOCC0H-C2infYgwm8SWW&index=8

[Voltar ao Índice](#indice)

---


## <a name="parte9">9 - 008 - Organizando o código em pacotes</a>

https://www.youtube.com/watch?v=TnnS-R--WKc&list=PL62G310vn6nFIsOCC0H-C2infYgwm8SWW&index=9

```java
package net.josemalcher;

public class OlaDevDojo {
    public static void main(String[] args) {
        System.out.println("Olá mundo!!");
    }
}

```

[Voltar ao Índice](#indice)

---


## <a name="parte10">10 - 009 - Comentários</a>

https://www.youtube.com/watch?v=2rMT0qRyiYs&list=PL62G310vn6nFIsOCC0H-C2infYgwm8SWW&index=10

[Voltar ao Índice](#indice)

---


## <a name="parte11">11 - 010 - Tipos primitivos pt 01 - convenções de variáveis</a>

https://www.youtube.com/watch?v=RRHGYyJTTpQ&list=PL62G310vn6nFIsOCC0H-C2infYgwm8SWW&index=11


Todos os valores, na verdade, são formados por bits e eles ficam na nossa memória RAM. 
> Um pente de memória RAM de 8gb (64,000,000,000bits).

Cada tipo primitivo utiliza uma quantidade fixa de bits para representar um valor na RAM. 
O tipo 'int' usa 4 bytes para representar números. Isto é, para representar números, o 'int' utiliza 32 dígitos binários (uns e zeros): 00000000000000000000000000000000

Com 32 bits, podemos representar um total de 4 bilhões e alguns milhões (2^32).
Porém, para acomodar tanto números NEGATIVOS quanto POSITIVOS, esse valor é "partido ao meio".
Consequentemente, uma variável do tipo 'int' pode armazenar, aproximadamente, cerca de 2 bilhões e 100 milhões:
int num = 2100000000;
// ou
int num = -2100000000;

Se a gente ultrapassar muito esse valor, teremos erro:
int num = 2800000000; // error

->> Esse erro ocorre porque o valor '2800000000' exige mais bits para ser representado.
E para resolver essa questão, temos o tipo 'long'. O 'long' utiliza 8 bytes (64 bits) para armazenar valores, então, se precisarmos armazenar o número '2800000000', usaremos o tipo 'long' e não o 'int'

Além disso, temos o 'byte' e o 'short'. Não vou me prolongar muito na explicação, então vou abordar apenas o tipo 'byte'.
O 'byte' utiliza apenas 1 byte (8 bits - 00000000) para representar um valor. Portanto, variáveis do tipo 'byte' são usadas para armazenar valores muito pequenos, por exemplo:
byte numzinho = 100 

Se tentarmos armazenar o valor de 200 numa variável do tipo 'byte', teremos um erro, já que o 200 requer mais bits para ser representado

FONTE: Comentário do vídeo

Resumo

#### ✅ Tipos Primitivos em Java

Java possui **8 tipos primitivos**, que são a base para representar dados simples:

```
| Tipo      | Tamanho      | Exemplo de uso                          |
|-----------|--------------|-----------------------------------------|
| `byte`    | 8 bits       | Armazena números pequenos (-128 a 127)  |
| `short`   | 16 bits      | Números inteiros maiores que `byte`     |
| `int`     | 32 bits      | Mais usado para números inteiros        |
| `long`    | 64 bits      | Números inteiros muito grandes          |
| `float`   | 32 bits      | Números decimais com menos precisão     |
| `double`  | 64 bits      | Números decimais com mais precisão      |
| `char`    | 16 bits      | Um único caractere (ex: 'A', '9')       |
| `boolean` | 1 bit (lógico) | Verdadeiro ou falso (`true` ou `false`) |
```
---

## 📝 Convenções de Variáveis em Java

Java é **case-sensitive** e segue algumas convenções de nomeação (não obrigatórias, mas boas práticas):

- **camelCase** para nomes de variáveis e métodos:
  ```java
  int idadeDoUsuario;
  boolean isAtivo;
  ```

- **UPPER_CASE** para constantes:
  ```java
  final int MAX_TENTATIVAS = 3;
  ```

- **Nomes claros e significativos** (evitar `x`, `y`, `z`, a não ser em exemplos matemáticos):
  ```java
  double salarioMensal;
  ```

- **Não usar palavras reservadas** como nome de variável (`int`, `class`, `public`, etc).


FONTE: CHATGPT


[Voltar ao Índice](#indice)

---


## <a name="parte12">12 - 011 - Tipos primitivos pt 02 - declaração e tamanho em memória</a>

https://www.youtube.com/watch?v=veDgI_zZ7uk&list=PL62G310vn6nFIsOCC0H-C2infYgwm8SWW&index=12

Declaração de variáveis primitivas: Como declarar e inicializar variáveis dos tipos byte, short, int, long, float, double, char e boolean.​
Universidade Java

Tamanho em memória: Discussão sobre o espaço que cada tipo primitivo ocupa na memória, por exemplo:

byte: 1 byte (8 bits)

short: 2 bytes (16 bits)

int: 4 bytes (32 bits)

long: 8 bytes (64 bits)

float: 4 bytes (32 bits)

double: 8 bytes (64 bits)

char: 2 bytes (16 bits)

boolean: 1 bit (valor lógico true ou false)​

Importância da escolha do tipo adequado: Explicação sobre como a escolha correta do tipo primitivo pode impactar na performance e no uso eficiente da memória.​

📌 Observações
A aula enfatiza a importância de entender os tipos primitivos para uma programação eficiente e eficaz em Java.​

FONTE: CHATGPT

https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html

[Voltar ao Índice](#indice)

---


## <a name="parte13">13 - 012 - Tipos primitivos pt 03 - casting</a>

https://www.youtube.com/watch?v=74hd4o7V328&list=PL62G310vn6nFIsOCC0H-C2infYgwm8SWW&index=13

## 🧠 CAST de Tipos Primitivos em Java

### ✅ O que é *Cast*?

O **casting** (ou conversão de tipos) é o processo de **converter um valor de um tipo primitivo para outro**. Existem dois tipos de cast em Java:

- **Casting implícito (widening cast):** Quando convertendo de um tipo menor para um tipo maior.
- **Casting explícito (narrowing cast):** Quando convertendo de um tipo maior para um tipo menor. Nesse caso, você precisa informar a conversão de forma explícita.

---

### 📈 Casting Implícito (Widening)

Não precisa de código adicional. Acontece quando não há risco de perda de dados.

```java
int num = 10;
long numeroMaior = num; // int -> long (OK)
double numeroDecimal = numeroMaior; // long -> double (OK)

System.out.println(numeroDecimal); // Saída: 10.0
```

#### ✅ Por que funciona?
O tipo `long` pode armazenar todos os valores possíveis de um `int`, e o `double` pode armazenar todos os valores possíveis de um `long`.

---

### 📉 Casting Explícito (Narrowing)

Precisa de conversão manual porque há risco de perda de dados.

```java
double valorDecimal = 10.99;
int valorInteiro = (int) valorDecimal; // double -> int

System.out.println(valorInteiro); // Saída: 10
```

#### ⚠️ Cuidado!
Nesse exemplo, **o valor após o ponto é perdido**.

---

### 🎯 Exemplo com perda de dados

```java
int valorGrande = 130;
byte valorPequeno = (byte) valorGrande; // int -> byte

System.out.println(valorPequeno); // Saída: -126
```

> `byte` vai de -128 a 127. Como `130` está fora desse intervalo, o valor é "reciclado" e vira -126.

---

### 🧪 Comparação entre tipos e conversão

| De         | Para       | Precisa de Cast? | Risco de perda? |
|------------|------------|------------------|-----------------|
| byte       | short      | Não              | Não             |
| int        | long       | Não              | Não             |
| long       | int        | Sim              | Sim             |
| double     | float      | Sim              | Sim             |
| float      | double     | Não              | Não             |
| char       | int        | Não              | Não             |
| int        | char       | Sim              | Sim             |

---

### 💡 Dica de ouro

Sempre que você estiver **reduzindo o tamanho do tipo**, pense:  
> “Estou avisando ao Java que **eu assumo o risco de perda de dados**”.

---

FONTE: CHATGPT

[Voltar ao Índice](#indice)

---


## <a name="parte14">14 - 013 - Tipos primitivos pt 04 - Strings</a>

https://www.youtube.com/watch?v=13VfcFXwsjw&list=PL62G310vn6nFIsOCC0H-C2infYgwm8SWW&index=14

iturn0image0turn0image1turn0image3turn0image5Claro! Aqui está um resumo em formato Markdown da aula **"13 - Tipos Primitivos pt 04 - Strings"** do curso Maratona Java do DevDojo, complementado com explicações e exemplos práticos:

---

# Aula 13 – Tipos Primitivos pt 04: Strings

📺 **Link do vídeo:** [Assista no YouTube](https://www.youtube.com/watch?v=13VfcFXwsjw)

### 🧠 Conteúdo Abordado

Nesta aula, o instrutor William Suane introduz o tipo `String` em Java, destacando que, embora não seja um tipo primitivo, é amplamente utilizado e possui características especiais. Os principais pontos abordados incluem:

- **Declaração e inicialização de Strings:**
  ```java
  String nome = "DevDojo";
  ```
 
Aqui, a variável `nome` é uma referência a um objeto do tipo `String` contendo o valor `"DevDojo".

- **Imutabilidade das Strings:**
 Em Java, as Strings são objetos imutáveis. Isso significa que, uma vez criada, uma `String` não pode ser alterada. Qualquer operação que pareça modificar uma `String` na verdade cria uma nova instânci.

- **Concatenação de Strings:**
 A aula demonstra como concatenar Strings utilizando o operador `+:
  ```java
  String saudacao = "Olá, ";
  String nome = "Mundo!";
  String mensagem = saudacao + nome;
  System.out.println(mensagem); // Saída: Olá, Mundo!
  ```


- **Uso de caracteres especiais:**
 Para incluir caracteres especiais em Strings, utiliza-se a barra invertida (`\`) como caractere de escap:
  ```java
  String texto = "Ele disse: \"Java é incrível!\"";
  System.out.println(texto); // Saída: Ele disse: "Java é incrível!"
  ```


---

### 📚 Complemento: Métodos Comuns da Classe String

Além dos conceitos abordados na aula, é importante conhecer alguns métodos úteis da classe `String`:

- **`length()`**: Retorna o comprimento da Strig.
  ```java
  String texto = "Java";
  int tamanho = texto.length(); // tamanho = 4
  ```


- **`toUpperCase()` e `toLowerCase()`**: Convertem a String para letras maiúsculas ou minúsculas, respectivamene.
  ```java
  String original = "DevDojo";
  String maiuscula = original.toUpperCase(); // "DEVDOJO"
  String minuscula = original.toLowerCase(); // "devdojo"
  ```


- **`substring(int beginIndex, int endIndex)`**: Retorna uma nova String que é uma subsequência da originl.
  ```java
  String texto = "Maratona Java";
  String parte = texto.substring(9, 13); // "Java"
  ```


- **`equals(String anotherString)`**: Compara o conteúdo de duas Strins.
  ```java
  String a = "Java";
  String b = "java";
  boolean iguais = a.equals(b); // false
  ```


- **`equalsIgnoreCase(String anotherString)`**: Compara o conteúdo de duas Strings, ignorando diferenças entre maiúsculas e minúsculs.
  ```java
  boolean iguaisIgnorandoCase = a.equalsIgnoreCase(b); // true
  ```


- **`trim()`**: Remove espaços em branco do início e do fim da Strig.
  ```java
  String texto = "  DevDojo  ";
  String ajustado = texto.trim(); // "DevDojo"
  ```


---

## 🔍 Observações Importantes
- Embora `String` não seja um tipo primitivo, é tratado de forma especial em Java devido à sua ampla utilizaão.
- A imutabilidade das Strings é uma característica que oferece segurança e facilita o uso em ambientes concorrentes, mas pode impactar a performance em operações intensivas de concatenação. Nesses casos, é recomendável utilizar classes como `StringBuilder` ou `StringBuffr`.

---


[Voltar ao Índice](#indice)

---


## <a name="parte15">15 - 014 - Tipos primitivos pt 05 - Exercício</a>

https://www.youtube.com/watch?v=Q0REhCVBvAg&list=PL62G310vn6nFIsOCC0H-C2infYgwm8SWW&index=15



[Voltar ao Índice](#indice)

---


## <a name="parte16">16 - 015 - Operadores pt 01 - Aritiméticos</a>

https://www.youtube.com/watch?v=1Fsvlted69g&list=PL62G310vn6nFIsOCC0H-C2infYgwm8SWW&index=16

# Aula 15 – Operadores pt 01: Aritméticos

## 🧠 Conteúdo Abordado

Nesta aula, o instrutor William Suane introduz os operadores aritméticos em Java, que são utilizados para realizar operações matemáticas básicas. Os principais operadores abordados incluem:

- **Adição (`+`)**: Soma dois valores.
- **Subtração (`-`)**: Subtrai o segundo valor do primeiro.
- **Multiplicação (`*`)**: Multiplica dois valores.
- **Divisão (`/`)**: Divide o primeiro valor pelo segundo.
- **Módulo (`%`)**: Retorna o resto da divisão do primeiro valor pelo segundo.

## 📝 Exemplos Práticos

```java
int a = 10;
int b = 3;

int soma = a + b;          // 13
int subtracao = a - b;     // 7
int multiplicacao = a * b; // 30
int divisao = a / b;       // 3
int modulo = a % b;        // 1

System.out.println("Soma: " + soma);
System.out.println("Subtração: " + subtracao);
System.out.println("Multiplicação: " + multiplicacao);
System.out.println("Divisão: " + divisao);
System.out.println("Módulo: " + modulo);
```

## ⚠️ Observações Importantes

- **Divisão entre inteiros**: Ao dividir dois números inteiros, o resultado também será um número inteiro, descartando qualquer parte decimal.
- **Divisão por zero**: Tentar dividir um número inteiro por zero resultará em uma exceção (`ArithmeticException`).
- **Uso do módulo**: O operador `%` é útil para determinar se um número é par ou ímpar, entre outras aplicações.

---

## 📚 Complemento: Precedência de Operadores

Em expressões com múltiplos operadores, a ordem de execução segue a precedência dos operadores:

1. Multiplicação (`*`), Divisão (`/`) e Módulo (`%`)
2. Adição (`+`) e Subtração (`-`)

Operadores com a mesma precedência são avaliados da esquerda para a direita.

### 🧪 Exemplo de Precedência

```java
int resultado = 10 + 5 * 2; // Resultado: 20
```

Neste exemplo, a multiplicação é realizada antes da adição.

Para alterar a ordem de execução, utilize parênteses:

```java
int resultado = (10 + 5) * 2; // Resultado: 30
```


[Voltar ao Índice](#indice)

---


## <a name="parte17">17 - 016 - Operadores pt 02 - Relacionais</a>

# Aula 16 – Operadores pt 02: Relacionais

📺 **Link do vídeo:** [Assista no YouTube](https://www.youtube.com/watch?v=U390IaCtOUk)

## 🧠 Conteúdo Abordado

Nesta aula, o instrutor William Suane apresenta os **operadores relacionais** em Java, que são utilizados para comparar dois valores e retornam um resultado booleano (`true` ou `false`).

### 🔎 Operadores Relacionais em Java

| Operador | Descrição         | Exemplo (`a = 10`, `b = 20`) |
|----------|-------------------|------------------------------|
| `==`     | Igual a           | `a == b` → `false`           |
| `!=`     | Diferente de      | `a != b` → `true`            |
| `>`      | Maior que         | `a > b` → `false`            |
| `<`      | Menor que         | `a < b` → `true`             |
| `>=`     | Maior ou igual a  | `a >= b` → `false`           |
| `<=`     | Menor ou igual a  | `a <= b` → `true`            |

Esses operadores são frequentemente utilizados em estruturas de controle, como `if`, `else if`, `while` e `for`, para tomar decisões baseadas em comparações.

### 📝 Exemplos Práticos

```java
int idade = 18;

if (idade >= 18) {
    System.out.println("Você é maior de idade.");
} else {
    System.out.println("Você é menor de idade.");
}
```

```java
int numero1 = 10;
int numero2 = 20;

System.out.println(numero1 == numero2); // false
System.out.println(numero1 != numero2); // true
System.out.println(numero1 > numero2);  // false
System.out.println(numero1 < numero2);  // true
```

---

## 📚 Complemento: Comparação de Strings

Em Java, para comparar o conteúdo de duas strings, deve-se utilizar o método `.equals()`, pois o operador `==` verifica se as referências apontam para o mesmo objeto na memória.

```java
String nome1 = "Java";
String nome2 = "Java";

System.out.println(nome1 == nome2);       // true (pode ser true devido ao pool de strings)
System.out.println(nome1.equals(nome2));  // true

String nome3 = new String("Java");
System.out.println(nome1 == nome3);       // false
System.out.println(nome1.equals(nome3));  // true
```

---

## ⚠️ Observações Importantes

- **Resultado Booleano:** Todos os operadores relacionais retornam um valor do tipo `boolean`.

- **Comparação de Tipos Diferentes:** Ao comparar tipos diferentes, o Java realiza a promoção de tipos para fazer a comparação.

- **Uso em Estruturas de Controle:** São amplamente utilizados em estruturas como `if`, `while`, `for`, entre outras, para controlar o fluxo do programa com base em condições.


[Voltar ao Índice](#indice)

---


## <a name="parte18">18 - 017 - Operadores pt 03 - Lógicos AND</a>


# Aula 17 – Operadores pt 03: Lógicos AND (`&&`)

📺 **Link do vídeo:** [Assista no YouTube](https://www.youtube.com/watch?v=cT6sw-Pw4l0)

## 🧠 Conteúdo Abordado

Nesta aula, o instrutor William Suane apresenta o operador lógico **AND (`&&`)** em Java, que é utilizado para combinar duas expressões booleanas. O resultado será `true` apenas se **ambas** as expressões forem verdadeiras.

### 🔎 Operador Lógico AND (`&&`)

- **Definição:** O operador `&&` retorna `true` se **ambas** as expressões forem verdadeiras; caso contrário, retorna `false`.

- **Curto-circuito:** O operador `&&` é conhecido por seu comportamento de curto-circuito. Isso significa que, se a primeira expressão for `false`, a segunda expressão **não será avaliada**, pois o resultado final já será `false`.

## 📝 Exemplos Práticos

```java
int idade = 25;
float salario = 3500.0f;

boolean isAprovado = idade >= 18 && salario >= 3000;
System.out.println("Aprovado? " + isAprovado); // true
```

```java
int idade = 16;
float salario = 4000.0f;

boolean isAprovado = idade >= 18 && salario >= 3000;
System.out.println("Aprovado? " + isAprovado); // false
```

## ⚠️ Observações Importantes

- **Avaliação Condicional:** Devido ao comportamento de curto-circuito, é possível evitar erros em certas situações. Por exemplo:

```java
int x = 0;
if (x != 0 && (10 / x) > 1) {
    System.out.println("Condição verdadeira");
}
```

Neste exemplo, a segunda condição `(10 / x) > 1` **não será avaliada** se `x != 0` for `false`, evitando assim uma divisão por zero.

## 📚 Complemento: Operadores Lógicos em Java

Além do operador `&&`, Java possui outros operadores lógicos:

- `||` (OR lógico): Retorna `true` se **pelo menos uma** das expressões for verdadeira.
- `!` (NOT lógico): Inverte o valor lógico da expressão.
- `^` (XOR lógico): Retorna `true` se **apenas uma** das expressões for verdadeira.

### 🧪 Exemplo com `||`:

```java
boolean temCarteira = true;
boolean temIdade = false;

if (temCarteira || temIdade) {
    System.out.println("Pode dirigir");
} else {
    System.out.println("Não pode dirigir");
}
```

[Voltar ao Índice](#indice)

---


## <a name="parte19">19 - 018 - Operadores pt 04 - Lógicos OR</a>


# Aula 18 – Operadores pt 04: Lógicos OR (`||`)

📺 **Link do vídeo:** [Assista no YouTube](https://www.youtube.com/watch?v=ELcO4DN7lxw)

## 🧠 Conteúdo Abordado

Nesta aula, o instrutor William Suane apresenta o operador lógico **OR (`||`)** em Java, que é utilizado para combinar duas expressões booleanas. O resultado será `true` se **pelo menos uma** das expressões for verdadeira.

### 🔎 Operador Lógico OR (`||`)

- **Definição:** O operador `||` retorna `true` se **pelo menos uma** das expressões for verdadeira; retorna `false` somente se **ambas** forem falsas.

- **Curto-circuito:** O operador `||` possui comportamento de curto-circuito. Isso significa que, se a primeira expressão for `true`, a segunda expressão **não será avaliada**, pois o resultado final já será `true`.

## 📝 Exemplos Práticos

```java
int idade = 16;
float salario = 4000.0f;

boolean isAprovado = idade >= 18 || salario >= 3000;
System.out.println("Aprovado? " + isAprovado); // true
```

```java
int idade = 16;
float salario = 2500.0f;

boolean isAprovado = idade >= 18 || salario >= 3000;
System.out.println("Aprovado? " + isAprovado); // false
```

## ⚠️ Observações Importantes

- **Avaliação Condicional:** Devido ao comportamento de curto-circuito, é possível evitar erros em certas situações. Por exemplo:

```java
String texto = null;
if (texto != null || texto.length() > 0) {
    System.out.println("Texto válido");
}
```

Neste exemplo, a segunda condição `texto.length() > 0` **não será avaliada** se `texto != null` for `true`, evitando assim um `NullPointerException`.

## 📚 Complemento: Operadores Lógicos em Java

Além do operador `||`, Java possui outros operadores lógicos:

- `&&` (AND lógico): Retorna `true` se **ambas** as expressões forem verdadeiras.
- `!` (NOT lógico): Inverte o valor lógico da expressão.
- `^` (XOR lógico): Retorna `true` se **apenas uma** das expressões for verdadeira.

### 🧪 Exemplo com `&&`:

```java
boolean temCarteira = true;
boolean temIdade = false;

if (temCarteira && temIdade) {
    System.out.println("Pode dirigir");
} else {
    System.out.println("Não pode dirigir");
}
```


[Voltar ao Índice](#indice)

---


## <a name="parte20">20 - 019 - Operadores pt 05 - Atribuição</a>

# Aula 19 – Operadores pt 05: Atribuição

📺 **Link do vídeo:** [Assista no YouTube](https://www.youtube.com/watch?v=EFrq1WxsL1k)

## 🧠 Conteúdo Abordado

Nesta aula, o instrutor William Suane apresenta os **operadores de atribuição** em Java, que são utilizados para atribuir valores a variáveis. Existem dois tipos principais:

### 🔹 Atribuição Simples (`=`)

- **Definição:** Atribui o valor da expressão à direita para a variável à esquerda.
- **Exemplo:**

  ```java
  int idade = 25;
  String nome = "João";
  double salario = 3500.50;
  ```

### 🔹 Atribuição Composta

- **Definição:** Combina um operador aritmético com a atribuição, simplificando expressões.
- **Operadores Comuns:**

  | Operador | Equivalente a     | Exemplo             |
  |----------|-------------------|---------------------|
  | `+=`     | `x = x + y`       | `x += y;`           |
  | `-=`     | `x = x - y`       | `x -= y;`           |
  | `*=`     | `x = x * y`       | `x *= y;`           |
  | `/=`     | `x = x / y`       | `x /= y;`           |
  | `%=`     | `x = x % y`       | `x %= y;`           |

- **Exemplo:**

  ```java
  int x = 10;
  x += 5; // x agora é 15
  x *= 2; // x agora é 30
  ```

## ⚠️ Observações Importantes

- **Tipo de Dados:** O tipo da expressão à direita deve ser compatível com o tipo da variável à esquerda.
- **Atribuição Múltipla:** É possível realizar atribuições encadeadas:

  ```java
  int a, b, c;
  a = b = c = 100;
  ```

  Neste exemplo, todas as variáveis `a`, `b` e `c` receberão o valor `100`.

## 📚 Complemento: Operadores de Atribuição Bit a Bit

Além dos operadores mencionados, Java possui operadores de atribuição bit a bit:

| Operador | Descrição                 | Exemplo             |
|----------|---------------------------|---------------------|
| `&=`     | AND bit a bit e atribui   | `x &= y;`           |
| `|=`     | OR bit a bit e atribui    | `x |= y;`           |
| `^=`     | XOR bit a bit e atribui   | `x ^= y;`           |
| `<<=`    | Desloca bits à esquerda   | `x <<= 2;`          |
| `>>=`    | Desloca bits à direita    | `x >>= 2;`          |
| `>>>=`   | Desloca bits à direita sem sinal | `x >>>= 2;`    |

Esses operadores são úteis em operações de baixo nível, como manipulação de bits e desenvolvimento de sistemas embarcados.


[Voltar ao Índice](#indice)

---


## <a name="parte21">21 - 020 - Estruturas Condicionais pt 01 - IF</a>

# Aula 20 – Estruturas Condicionais pt 01: IF

📺 **Link do vídeo:** [Assista no YouTube](https://www.youtube.com/watch?v=gk1_Pn8GZA4)

## 🧠 Conteúdo Abordado

Nesta aula, o instrutor William Suane apresenta a estrutura condicional **`if`** em Java, que permite executar blocos de código com base em condições booleanas.

### 🔹 Estrutura do `if`

- **Definição:** O `if` é utilizado para verificar se uma condição é verdadeira. Se for, o bloco de código dentro do `if` é executado.

- **Sintaxe:**

  ```java
  if (condição) {
      // bloco de código a ser executado se a condição for verdadeira
  }
  ```

### 🔹 Exemplo Prático

```java
int idade = 18;

if (idade >= 18) {
    System.out.println("Você é maior de idade.");
}
```

Neste exemplo, a mensagem será exibida apenas se a variável `idade` for maior ou igual a 18.

## ⚠️ Observações Importantes

- **Avaliação de Condições:** A condição dentro do `if` deve resultar em um valor booleano (`true` ou `false`).

- **Uso de Chaves `{}`:** Embora não seja obrigatório usar chaves `{}` quando há apenas uma instrução dentro do `if`, é uma boa prática utilizá-las para melhorar a legibilidade e evitar erros.

  ```java
  // Sem chaves - válido, mas não recomendado
  if (idade >= 18)
      System.out.println("Maior de idade.");

  // Com chaves - recomendado
  if (idade >= 18) {
      System.out.println("Maior de idade.");
  }
  ```

## 📚 Complemento: Estruturas Condicionais em Java

Além do `if`, Java oferece outras estruturas condicionais:

- **`if-else`:** Executa um bloco de código se a condição for verdadeira e outro bloco se for falsa.

  ```java
  if (condição) {
      // bloco se condição for verdadeira
  } else {
      // bloco se condição for falsa
  }
  ```

- **`if-else if-else`:** Permite verificar múltiplas condições em sequência.

  ```java
  if (condição1) {
      // bloco se condição1 for verdadeira
  } else if (condição2) {
      // bloco se condição2 for verdadeira
  } else {
      // bloco se nenhuma condição anterior for verdadeira
  }
  ```

- **`switch`:** Ideal para verificar a igualdade de uma variável contra múltiplos valores.

  ```java
  switch (variável) {
      case valor1:
          // bloco para valor1
          break;
      case valor2:
          // bloco para valor2
          break;
      default:
          // bloco se nenhum caso anterior for correspondente
  }
  ```


[Voltar ao Índice](#indice)

---


## <a name="parte22">22 - 021 - Estruturas Condicionais pt 02 - ELSE IF</a>

# Aula 21 – Estruturas Condicionais pt 02: ELSE IF

📺 **Link do vídeo:** [Assista no YouTube](https://www.youtube.com/watch?v=exxeNsgcg3c)

## 🧠 Conteúdo Abordado

Nesta aula, o instrutor William Suane apresenta a estrutura condicional **`else if`** em Java, que permite verificar múltiplas condições em sequência. Essa estrutura é útil quando há mais de duas possibilidades a serem avaliadas.

### 🔹 Estrutura do `if-else if-else`

- **Definição:** Permite testar várias condições em sequência. A primeira condição verdadeira terá seu bloco de código executado, e as demais serão ignoradas.

- **Sintaxe:**

  ```java
  if (condição1) {
      // bloco de código se condição1 for verdadeira
  } else if (condição2) {
      // bloco de código se condição2 for verdadeira
  } else {
      // bloco de código se nenhuma das condições anteriores for verdadeira
  }
  ```

### 🔹 Exemplo Prático

```java
int nota = 85;

if (nota >= 90) {
    System.out.println("Excelente");
} else if (nota >= 75) {
    System.out.println("Bom");
} else if (nota >= 60) {
    System.out.println("Regular");
} else {
    System.out.println("Reprovado");
}
```

Neste exemplo, a variável `nota` é avaliada em diferentes faixas, e a mensagem correspondente é exibida com base na condição satisfeita.

## ⚠️ Observações Importantes

- **Ordem das Condições:** As condições devem ser organizadas da mais restritiva para a mais abrangente para evitar que condições mais gerais sejam avaliadas antes das específicas.

- **Avaliação Sequencial:** Assim que uma condição é satisfeita, as demais não são avaliadas. Portanto, a ordem das condições é crucial.

## 📚 Complemento: Estrutura `if-else if` em Java

- A estrutura `if-else if` é conhecida como "if-else-if ladder" em Java. Ela permite que o programa escolha entre várias alternativas com base em diferentes condições.

- É uma alternativa ao uso de múltiplas estruturas `if-else` aninhadas, proporcionando um código mais limpo e legível.


[Voltar ao Índice](#indice)

---


## <a name="parte23">23 - 022 - Estruturas Condicionais pt 03 - Operador ternário</a>


# Aula 22 – Estruturas Condicionais pt 03: Operador Ternário

📺 **Link do vídeo:** [Assista no YouTube](https://www.youtube.com/watch?v=gU-qCpBC5jk)

## 🧠 Conteúdo Abordado

Nesta aula, o instrutor William Suane apresenta o **operador ternário** em Java, uma forma concisa de escrever expressões condicionais simples, substituindo estruturas `if-else` em uma única linha.

### 🔹 Sintaxe do Operador Ternário

```java
condição ? expressão_se_verdadeiro : expressão_se_falso;
```

- **condição**: Uma expressão que retorna `true` ou `false`.
- **expressão_se_verdadeiro**: Executada se a condição for verdadeira.
- **expressão_se_falso**: Executada se a condição for falsa.

### 🔹 Exemplo Prático

```java
int idade = 18;
String mensagem = (idade >= 18) ? "Você é maior de idade." : "Você é menor de idade.";
System.out.println(mensagem);
```

Neste exemplo, a variável `mensagem` recebe um valor com base na condição `idade >= 18`.

### 🔹 Comparação com `if-else`

```java
// Usando if-else
if (idade >= 18) {
    mensagem = "Você é maior de idade.";
} else {
    mensagem = "Você é menor de idade.";
}

// Usando operador ternário
mensagem = (idade >= 18) ? "Você é maior de idade." : "Você é menor de idade.";
```

Ambas as abordagens produzem o mesmo resultado, mas o operador ternário oferece uma sintaxe mais enxuta.

## ⚠️ Observações Importantes

- **Legibilidade**: O operador ternário é ideal para condições simples. Para lógica mais complexa, o uso de `if-else` é recomendado para manter a clareza do código.
- **Tipo de Retorno**: As expressões `expressão_se_verdadeiro` e `expressão_se_falso` devem retornar valores compatíveis com o tipo da variável que receberá o resultado.
- **Aninhamento**: É possível aninhar operadores ternários, mas isso pode comprometer a legibilidade do código.

### 🔹 Exemplo de Aninhamento

```java
int nota = 85;
String resultado = (nota >= 90) ? "Excelente" :
                   (nota >= 75) ? "Bom" :
                   (nota >= 60) ? "Regular" : "Reprovado";
System.out.println("Desempenho: " + resultado);
```

Neste exemplo, múltiplas condições são avaliadas em sequência para determinar o desempenho com base na nota.

## 📚 Complemento: Quando Usar o Operador Ternário

- **Atribuições Simples**: Ideal para atribuir valores a variáveis com base em uma condição.

  ```java
  int numero = 10;
  String paridade = (numero % 2 == 0) ? "Par" : "Ímpar";
  ```

- **Retorno de Métodos**: Pode ser utilizado para retornar valores diretamente de métodos.

  ```java
  public String verificarIdade(int idade) {
      return (idade >= 18) ? "Maior de idade" : "Menor de idade";
  }
  ```

- **Evitar Uso Excessivo**: Para condições complexas ou múltiplas, prefira estruturas `if-else` para manter a legibilidade.


[Voltar ao Índice](#indice)

---


## <a name="parte24">24 - 023 - Estruturas Condicionais pt 04 - Tabela Verdade e exercício</a>

# Aula 23 – Estruturas Condicionais pt 04: Tabela Verdade e Exercício

📺 **Link do vídeo:** [Assista no YouTube](https://www.youtube.com/watch?v=Y3ODYE3npgo)

## 🧠 Conteúdo Abordado

Nesta aula, o instrutor William Suane apresenta a **tabela verdade** dos operadores lógicos `&&` (E lógico) e `||` (OU lógico) em Java, além de propor um exercício prático para fixar o conhecimento.

### 🔹 Tabela Verdade dos Operadores Lógicos

#### Operador `&&` (E lógico)

| Condição 1 | Condição 2 | Resultado |
|------------|------------|-----------|
| false      | false      | false     |
| false      | true       | false     |
| true       | false      | false     |
| true       | true       | true      |

- **Comportamento:** O resultado é `true` apenas se **ambas** as condições forem verdadeiras.

#### Operador `||` (OU lógico)

| Condição 1 | Condição 2 | Resultado |
|------------|------------|-----------|
| false      | false      | false     |
| false      | true       | true      |
| true       | false      | true      |
| true       | true       | true      |

- **Comportamento:** O resultado é `true` se **pelo menos uma** das condições for verdadeira.

### 🔹 Exercício Proposto

**Objetivo:** Determinar se um funcionário pode receber auxílio com base em seu salário e dependentes.

**Critérios:**

- **Salário Baixo:** Salário menor que R$ 2000.00
- **Muitos Dependentes:** Mais de 2 dependentes

**Implementação:**

```java
public class Auxilio {
    public static void main(String[] args) {
        double salario = 1900.0;
        int dependentes = 3;

        boolean salarioBaixo = salario < 2000.0;
        boolean muitosDependentes = dependentes > 2;

        if (salarioBaixo && muitosDependentes) {
            System.out.println("Funcionário deve receber auxílio.");
        } else {
            System.out.println("Funcionário não se enquadra para o auxílio.");
        }
    }
}
```

**Explicação:**

- As variáveis `salarioBaixo` e `muitosDependentes` armazenam os resultados das condições.
- O `if` verifica se **ambas** as condições são verdadeiras usando o operador `&&`.
- Se ambas forem verdadeiras, o funcionário tem direito ao auxílio.

## ⚠️ Observações Importantes

- **Avaliação Curta-Circuito:**
  - No operador `&&`, se a primeira condição for `false`, a segunda **não é avaliada**, pois o resultado já será `false`.
  - No operador `||`, se a primeira condição for `true`, a segunda **não é avaliada**, pois o resultado já será `true`.

- **Boa Prática:**
  - Utilizar variáveis booleanas intermediárias (`salarioBaixo`, `muitosDependentes`) melhora a legibilidade e facilita a manutenção do código.



[Voltar ao Índice](#indice)

---


## <a name="parte25">25 - 024 - Estruturas Condicionais pt 05 - Resolução do exercícios</a>

# Aula 24 – Estruturas Condicionais pt 05: Resolução do Exercício

📺 **Link do vídeo:** [Assista no YouTube](https://www.youtube.com/watch?v=W-ng6Dqa-E4)

## 🧠 Conteúdo Abordado

Nesta aula, o instrutor William Suane apresenta a resolução do exercício proposto na aula anterior, utilizando estruturas condicionais em Java para determinar se um funcionário deve receber auxílio com base em seu salário e número de dependentes.

### 🔹 Relembrando o Exercício

**Objetivo:** Determinar se um funcionário deve receber auxílio.

**Critérios:**

- **Salário Baixo:** Salário menor que R$ 2000.00
- **Muitos Dependentes:** Mais de 2 dependentes

### 🔹 Implementação em Java

```java
public class Auxilio {
    public static void main(String[] args) {
        double salario = 1900.0;
        int dependentes = 3;

        boolean salarioBaixo = salario < 2000.0;
        boolean muitosDependentes = dependentes > 2;

        if (salarioBaixo && muitosDependentes) {
            System.out.println("Funcionário deve receber auxílio.");
        } else {
            System.out.println("Funcionário não se enquadra para o auxílio.");
        }
    }
}
```

**Explicação:**

- As variáveis `salarioBaixo` e `muitosDependentes` armazenam os resultados das condições.
- O `if` verifica se **ambas** as condições são verdadeiras usando o operador `&&`.
- Se ambas forem verdadeiras, o funcionário tem direito ao auxílio.

### 🔹 Utilizando o Operador Ternário

Para tornar o código mais conciso, é possível utilizar o operador ternário:

```java
public class Auxilio {
    public static void main(String[] args) {
        double salario = 1900.0;
        int dependentes = 3;

        String resultado = (salario < 2000.0 && dependentes > 2) 
            ? "Funcionário deve receber auxílio." 
            : "Funcionário não se enquadra para o auxílio.";

        System.out.println(resultado);
    }
}
```

**Explicação:**

- O operador ternário avalia a condição `(salario < 2000.0 && dependentes > 2)`.
- Se verdadeira, retorna "Funcionário deve receber auxílio."
- Caso contrário, retorna "Funcionário não se enquadra para o auxílio."

## ⚠️ Observações Importantes

- **Avaliação Curta-Circuito:**
  - No operador `&&`, se a primeira condição for `false`, a segunda **não é avaliada**, pois o resultado já será `false`.
  - No operador `||`, se a primeira condição for `true`, a segunda **não é avaliada**, pois o resultado já será `true`.

- **Boas Práticas:**
  - Utilizar variáveis booleanas intermediárias (`salarioBaixo`, `muitosDependentes`) melhora a legibilidade e facilita a manutenção do código.
  - O operador ternário é ideal para condições simples. Para lógica mais complexa, prefira estruturas `if-else` para manter a clareza do código.



[Voltar ao Índice](#indice)

---


## <a name="parte26">26 - 025 - Estruturas Condicionais pt 06 - Switch</a>

# Aula 25 – Estruturas Condicionais pt 06: Switch

📺 **Link do vídeo:** [Assista no YouTube](https://www.youtube.com/watch?v=AYMtqJSrQTU)

## 🧠 Conteúdo Abordado

Nesta aula, o instrutor William Suane apresenta a estrutura condicional `switch` em Java, que permite executar diferentes blocos de código com base no valor de uma variável, oferecendo uma alternativa mais organizada ao uso de múltiplos `if-else`.

### 🔹 Sintaxe do `switch`

```java
switch (expressão) {
    case valor1:
        // código a ser executado
        break;
    case valor2:
        // código a ser executado
        break;
    // outros casos
    default:
        // código a ser executado se nenhum caso for satisfeito
}
```

- **expressão**: Pode ser do tipo `byte`, `short`, `char`, `int`, `String` ou `enum`.
- **case**: Cada `case` compara o valor da expressão com um valor constante.
- **break**: Impede o *fall-through*, ou seja, evita que a execução continue nos próximos casos.
- **default**: Executado quando nenhum `case` corresponde ao valor da expressão.

### 🔹 Exemplo Prático

```java
public class DiaDaSemana {
    public static void main(String[] args) {
        int dia = 3;
        switch (dia) {
            case 1:
                System.out.println("Domingo");
                break;
            case 2:
                System.out.println("Segunda-feira");
                break;
            case 3:
                System.out.println("Terça-feira");
                break;
            case 4:
                System.out.println("Quarta-feira");
                break;
            case 5:
                System.out.println("Quinta-feira");
                break;
            case 6:
                System.out.println("Sexta-feira");
                break;
            case 7:
                System.out.println("Sábado");
                break;
            default:
                System.out.println("Dia inválido");
        }
    }
}
```

**Saída:**

```
Terça-feira
```

### 🔹 Uso com `String` (a partir do Java 7)

```java
public class DiaDaSemanaString {
    public static void main(String[] args) {
        String dia = "terça";
        switch (dia.toLowerCase()) {
            case "segunda":
                System.out.println("Dia 2");
                break;
            case "terça":
                System.out.println("Dia 3");
                break;
            case "quarta":
                System.out.println("Dia 4");
                break;
            case "quinta":
                System.out.println("Dia 5");
                break;
            case "sexta":
                System.out.println("Dia 6");
                break;
            case "sábado":
                System.out.println("Dia 7");
                break;
            case "domingo":
                System.out.println("Dia 1");
                break;
            default:
                System.out.println("Dia inválido");
        }
    }
}
```

**Saída:**

```
Dia 3
```

## ⚠️ Observações Importantes

- **Fall-through**: Se o `break` for omitido, a execução continuará nos próximos casos até encontrar um `break` ou o final do `switch`.
  
  ```java
  int numero = 2;
  switch (numero) {
      case 1:
          System.out.println("Um");
      case 2:
          System.out.println("Dois");
      case 3:
          System.out.println("Três");
      default:
          System.out.println("Número não identificado");
  }
  ```

  **Saída:**

  ```
  Dois
  Três
  Número não identificado
  ```

- **`default` opcional**: O bloco `default` é opcional, mas recomendado para tratar valores inesperados.
- **Valores únicos**: Cada `case` deve ter um valor constante e único.



[Voltar ao Índice](#indice)

---


## <a name="parte27">27 - 026 - Estruturas Condicionais pt 07 - Switch exercício</a>

# Aula 26 – Estruturas Condicionais pt 07: Switch Exercício

📺 **Link do vídeo:** [Assista no YouTube](https://www.youtube.com/watch?v=GDAgMb9amow)

## 🧠 Conteúdo Abordado

Nesta aula, o instrutor William Suane propõe um exercício prático para reforçar o entendimento da estrutura condicional `switch` em Java. O objetivo é aplicar o conhecimento adquirido na aula anterior, utilizando o `switch` para resolver problemas reais.

### 🔹 Descrição do Exercício

**Objetivo:** Criar um programa que, com base em um número de 1 a 7, exiba o dia da semana correspondente.

**Requisitos:**

- Utilizar a estrutura `switch`.
- Tratar casos onde o número não corresponde a um dia da semana válido.

### 🔹 Implementação em Java

```java
public class DiaDaSemana {
    public static void main(String[] args) {
        int dia = 3; // Você pode alterar este valor para testar outros casos

        switch (dia) {
            case 1:
                System.out.println("Domingo");
                break;
            case 2:
                System.out.println("Segunda-feira");
                break;
            case 3:
                System.out.println("Terça-feira");
                break;
            case 4:
                System.out.println("Quarta-feira");
                break;
            case 5:
                System.out.println("Quinta-feira");
                break;
            case 6:
                System.out.println("Sexta-feira");
                break;
            case 7:
                System.out.println("Sábado");
                break;
            default:
                System.out.println("Dia inválido");
        }
    }
}
```

**Explicação:**

- A variável `dia` representa o número do dia da semana.
- O `switch` avalia o valor de `dia` e executa o bloco correspondente.
- O `default` trata casos onde o valor de `dia` não está entre 1 e 7.

### 🔹 Testando o Programa

Altere o valor da variável `dia` para testar diferentes cenários:

- `dia = 1` → Saída: `Domingo`
- `dia = 5` → Saída: `Quinta-feira`
- `dia = 8` → Saída: `Dia inválido`

## ⚠️ Observações Importantes

- **Uso do `break`:** Cada `case` termina com um `break` para evitar o *fall-through*, onde múltiplos blocos seriam executados.
- **`default` opcional:** Embora opcional, é uma boa prática incluir o `default` para tratar valores inesperados.
- **Tipos compatíveis:** A expressão no `switch` pode ser dos tipos `byte`, `short`, `int`, `char`, `String` (a partir do Java 7) ou `enum`.


[Voltar ao Índice](#indice)

---


## <a name="parte28">28 - 027 - Estruturas de Repetição pt 01 - Laços de repetição while, do while, for</a>

# Aula 27 – Estruturas de Repetição pt 01: Laços de repetição while, do while, for

📺 **Link do vídeo:** [Assista no YouTube](https://www.youtube.com/watch?v=hEl67ZAU_Hg)

## 🧠 Conteúdo Abordado

Nesta aula, o instrutor William Suane apresenta as estruturas de repetição em Java: `while`, `do-while` e `for`. Essas estruturas permitem executar um bloco de código repetidamente, com base em uma condição.

### 🔹 Estrutura `while`

A estrutura `while` executa um bloco de código enquanto uma condição for verdadeira. A condição é verificada antes da execução do bloco.

**Sintaxe:**

```java
while (condição) {
    // código a ser executado
}
```

**Exemplo:**

```java
int i = 1;
while (i <= 5) {
    System.out.println("Valor de i: " + i);
    i++;
}
```

**Saída:**

```
Valor de i: 1
Valor de i: 2
Valor de i: 3
Valor de i: 4
Valor de i: 5
```

### 🔹 Estrutura `do-while`

A estrutura `do-while` é semelhante ao `while`, mas a condição é verificada após a execução do bloco. Isso garante que o bloco seja executado pelo menos uma vez.

**Sintaxe:**

```java
do {
    // código a ser executado
} while (condição);
```

**Exemplo:**

```java
int i = 1;
do {
    System.out.println("Valor de i: " + i);
    i++;
} while (i <= 5);
```

**Saída:**

```
Valor de i: 1
Valor de i: 2
Valor de i: 3
Valor de i: 4
Valor de i: 5
```

### 🔹 Estrutura `for`

A estrutura `for` é utilizada quando se sabe previamente o número de vezes que o bloco de código deve ser executado. Ela combina inicialização, condição e incremento em uma única linha.

**Sintaxe:**

```java
for (inicialização; condição; incremento) {
    // código a ser executado
}
```

**Exemplo:**

```java
for (int i = 1; i <= 5; i++) {
    System.out.println("Valor de i: " + i);
}
```

**Saída:**

```
Valor de i: 1
Valor de i: 2
Valor de i: 3
Valor de i: 4
Valor de i: 5
```

## ⚠️ Observações Importantes

- **`while`**: Verifica a condição antes de executar o bloco. Se a condição for falsa na primeira verificação, o bloco pode não ser executado nenhuma vez.
- **`do-while`**: Executa o bloco pelo menos uma vez, pois a condição é verificada após a execução.
- **`for`**: Ideal quando se sabe exatamente quantas vezes o loop deve ser executado.



[Voltar ao Índice](#indice)

---


## <a name="parte29">29 - 028 - Estruturas de Repetição pt 02 - Exercício for</a>

# Aula 28 – Estruturas de Repetição pt 02: Exercício com `for`

📺 **Link do vídeo:** [Assista no YouTube](https://www.youtube.com/watch?v=nvFAe05Ok3g)

## 🧠 Conteúdo Abordado

Nesta aula, o instrutor William Suane propõe um exercício prático para reforçar o entendimento da estrutura de repetição `for` em Java. O objetivo é aplicar o conhecimento adquirido na aula anterior, utilizando o `for` para resolver problemas reais.

### 🔹 Descrição do Exercício

**Objetivo:** Criar um programa que exiba todos os números pares de 0 a 100.

**Requisitos:**

- Utilizar a estrutura `for`.
- Exibir apenas números pares no intervalo de 0 a 100.

### 🔹 Implementação em Java

```java
public class NumerosPares {
    public static void main(String[] args) {
        for (int i = 0; i <= 100; i++) {
            if (i % 2 == 0) {
                System.out.println("Número par: " + i);
            }
        }
    }
}
```

**Explicação:**

- A variável `i` é inicializada com 0 e incrementada até 100.
- A condição `i % 2 == 0` verifica se o número é par.
- Se a condição for verdadeira, o número é exibido no console.

### 🔹 Alternativa com Incremento de 2

Uma forma mais eficiente de exibir apenas os números pares é incrementar a variável `i` de 2 em 2:

```java
public class NumerosPares {
    public static void main(String[] args) {
        for (int i = 0; i <= 100; i += 2) {
            System.out.println("Número par: " + i);
        }
    }
}
```

**Vantagens:**

- Elimina a necessidade de verificar se o número é par.
- Reduz o número de iterações, tornando o programa mais eficiente.

## ⚠️ Observações Importantes

- **Uso do `for`:** Ideal quando se sabe exatamente quantas vezes o loop deve ser executado.
- **Eficiência:** Incrementar de 2 em 2 é mais eficiente do que verificar se o número é par a cada iteração.
- **Legibilidade:** Escolher a abordagem que torna o código mais legível e fácil de entender.


[Voltar ao Índice](#indice)

---


## <a name="parte30">30 - 029 - Estruturas de Repetição pt 03 - Break</a>

# Aula 29 – Estruturas de Repetição pt 03: Break

📺 **Link do vídeo:** [Assista no YouTube](https://www.youtube.com/watch?v=bcv-cgpw7Ak)

## 🧠 Conteúdo Abordado

Nesta aula, o instrutor William Suane apresenta o uso da instrução `break` em Java, que é utilizada para interromper a execução de estruturas de repetição (`for`, `while`, `do-while`) ou de um bloco `switch`.

### 🔹 O que é o `break`?

O `break` é uma instrução de controle de fluxo que, quando executada, termina imediatamente a estrutura de controle mais próxima (`for`, `while`, `do-while` ou `switch`) e transfere o controle para a próxima instrução após essa estrutura.

### 🔹 Uso do `break` em loops

**Exemplo com `for`:**

```java
for (int i = 0; i < 10; i++) {
    if (i == 5) {
        break;
    }
    System.out.println("i: " + i);
}
```

**Saída:**

```
i: 0
i: 1
i: 2
i: 3
i: 4
```

**Exemplo com `while`:**

```java
int i = 0;
while (i < 10) {
    if (i == 5) {
        break;
    }
    System.out.println("i: " + i);
    i++;
}
```

**Saída:**

```
i: 0
i: 1
i: 2
i: 3
i: 4
```

**Exemplo com `do-while`:**

```java
int i = 0;
do {
    if (i == 5) {
        break;
    }
    System.out.println("i: " + i);
    i++;
} while (i < 10);
```

**Saída:**

```
i: 0
i: 1
i: 2
i: 3
i: 4
```

### 🔹 Uso do `break` em `switch`

```java
int dia = 3;
switch (dia) {
    case 1:
        System.out.println("Domingo");
        break;
    case 2:
        System.out.println("Segunda-feira");
        break;
    case 3:
        System.out.println("Terça-feira");
        break;
    default:
        System.out.println("Dia inválido");
}
```

**Saída:**

```
Terça-feira
```

### 🔹 Uso de `break` com rótulos (labeled break)

Em loops aninhados, o `break` afeta apenas o loop mais interno. Para sair de loops externos, utiliza-se rótulos:

```java
externo:
for (int i = 0; i < 3; i++) {
    for (int j = 0; j < 3; j++) {
        if (i == 1 && j == 1) {
            break externo;
        }
        System.out.println("i: " + i + ", j: " + j);
    }
}
```

**Saída:**

```
i: 0, j: 0
i: 0, j: 1
i: 0, j: 2
i: 1, j: 0
```

## ⚠️ Observações Importantes

- **Uso adequado:** Utilize o `break` para sair de loops ou `switch` quando uma condição específica for atendida.
- **Legibilidade:** Evite o uso excessivo de `break`, pois pode dificultar a leitura e manutenção do código.
- **Loops infinitos:** Em loops sem condição de término explícita, o `break` pode ser utilizado para definir uma condição de saída.


[Voltar ao Índice](#indice)

---


## <a name="parte31">31 - 030 - Estruturas de Repetição pt 04 - Exercício Break</a>

# Aula 30 – Estruturas de Repetição pt 04: Exercício com `break`

📺 **Link do vídeo:** [Assista no YouTube](https://www.youtube.com/watch?v=RaEO2YsqFII)

## 🧠 Conteúdo Abordado

Nesta aula, o instrutor William Suane propõe um exercício prático para reforçar o entendimento da instrução `break` em Java. O objetivo é aplicar o conhecimento adquirido na aula anterior, utilizando o `break` para controlar o fluxo de execução em estruturas de repetição.

### 🔹 Descrição do Exercício

**Objetivo:** Criar um programa que exiba os números de 1 a 50, mas interrompa a execução quando encontrar um número divisível por 25.

**Requisitos:**

- Utilizar a estrutura `for`.
- Exibir os números de 1 a 50.
- Interromper a execução ao encontrar um número divisível por 25.

### 🔹 Implementação em Java

```java
public class BreakExercicio {
    public static void main(String[] args) {
        for (int i = 1; i <= 50; i++) {
            if (i % 25 == 0) {
                System.out.println("Número divisível por 25 encontrado: " + i);
                break;
            }
            System.out.println("i = " + i);
        }
    }
}
```

**Explicação:**

- A variável `i` é inicializada com 1 e incrementada até 50.
- A condição `i % 25 == 0` verifica se o número é divisível por 25.
- Se a condição for verdadeira, o número é exibido e a execução é interrompida com o `break`.
- Caso contrário, o número é exibido normalmente.

### 🔹 Saída Esperada

```
i = 1
i = 2
...
i = 24
Número divisível por 25 encontrado: 25
```

## ⚠️ Observações Importantes

- **Uso do `break`:** A instrução `break` é utilizada para interromper a execução de loops (`for`, `while`, `do-while`) ou de um bloco `switch` quando uma condição específica é atendida.
- **Legibilidade:** Utilizar o `break` de forma adequada pode melhorar a legibilidade e eficiência do código, evitando execuções desnecessárias.
- **Loops Infinitos:** Em loops sem condição de término explícita, o `break` pode ser utilizado para definir uma condição de saída.


[Voltar ao Índice](#indice)

---


## <a name="parte32">32 - 031 - Estruturas de Repetição pt 05 - Continue</a>

# Aula 31 – Estruturas de Repetição pt 05: Continue

📺 **Link do vídeo:** [Assista no YouTube](https://www.youtube.com/watch?v=f65R-lQ4NpY)

## 🧠 Conteúdo Abordado

Nesta aula, o instrutor William Suane apresenta a instrução `continue` em Java, que é utilizada para pular a execução do restante do código dentro de um loop e iniciar a próxima iteração.

### 🔹 O que é o `continue`?

O `continue` é uma instrução de controle de fluxo que, quando executada dentro de um loop (`for`, `while` ou `do-while`), faz com que o loop pule o restante do código na iteração atual e prossiga para a próxima iteração.

### 🔹 Uso do `continue` em loops

**Exemplo com `for`:**

```java
for (int i = 0; i < 10; i++) {
    if (i == 5) {
        continue;
    }
    System.out.println("i: " + i);
}
```

**Saída:**

```
i: 0
i: 1
i: 2
i: 3
i: 4
i: 6
i: 7
i: 8
i: 9
```

**Exemplo com `while`:**

```java
int i = 0;
while (i < 10) {
    i++;
    if (i == 5) {
        continue;
    }
    System.out.println("i: " + i);
}
```

**Saída:**

```
i: 1
i: 2
i: 3
i: 4
i: 6
i: 7
i: 8
i: 9
i: 10
```

**Exemplo com `do-while`:**

```java
int i = 0;
do {
    i++;
    if (i == 5) {
        continue;
    }
    System.out.println("i: " + i);
} while (i < 10);
```

**Saída:**

```
i: 1
i: 2
i: 3
i: 4
i: 6
i: 7
i: 8
i: 9
i: 10
```

### 🔹 Uso do `continue` em loops aninhados

Em loops aninhados, o `continue` afeta apenas o loop mais interno. Para controlar loops externos, utiliza-se rótulos:

```java
externo:
for (int i = 0; i < 3; i++) {
    for (int j = 0; j < 3; j++) {
        if (i == 1 && j == 1) {
            continue externo;
        }
        System.out.println("i: " + i + ", j: " + j);
    }
}
```

**Saída:**

```
i: 0, j: 0
i: 0, j: 1
i: 0, j: 2
i: 1, j: 0
i: 2, j: 0
i: 2, j: 1
i: 2, j: 2
```

## ⚠️ Observações Importantes

- **Uso adequado:** Utilize o `continue` para pular determinadas iterações com base em condições específicas.
- **Legibilidade:** Evite o uso excessivo de `continue`, pois pode dificultar a leitura e manutenção do código.
- **Loops infinitos:** Certifique-se de que o uso de `continue` não interfira na lógica de término do loop, evitando loops infinitos.


[Voltar ao Índice](#indice)

---


## <a name="parte33">33 - 032 - Arrays pt 01</a>

# Aula 32 – Arrays pt 01

📺 **Link do vídeo:** [Assista no YouTube](https://www.youtube.com/watch?v=fvw4bmihZHA)

## 🧠 Conteúdo Abordado

Nesta aula, o instrutor William Suane introduz o conceito de arrays em Java, abordando sua declaração, inicialização e acesso aos elementos.

### 🔹 O que são Arrays?

Arrays são estruturas de dados que armazenam múltiplos valores do mesmo tipo em uma única variável. Eles são úteis quando precisamos trabalhar com coleções de dados homogêneos.

### 🔹 Declaração e Inicialização de Arrays

**Forma 1: Declaração e atribuição separadas**

```java
int[] numeros; // declaração
numeros = new int[5]; // inicialização com tamanho 5
```

**Forma 2: Declaração e inicialização conjunta**

```java
int[] numeros = new int[5];
```

**Forma 3: Inicialização com valores definidos**

```java
int[] numeros = {1, 2, 3, 4, 5};
```

### 🔹 Acessando Elementos de um Array

Os elementos de um array são acessados por índices, que começam em 0.

```java
System.out.println(numeros[0]); // Acessa o primeiro elemento
```

### 🔹 Iterando sobre Arrays

Podemos utilizar loops para percorrer os elementos de um array.

**Exemplo com `for`:**

```java
for (int i = 0; i < numeros.length; i++) {
    System.out.println(numeros[i]);
}
```

**Exemplo com `for-each`:**

```java
for (int numero : numeros) {
    System.out.println(numero);
}
```

### 🔹 Tamanho do Array

O tamanho de um array é acessado através da propriedade `length`.

```java
int tamanho = numeros.length;
System.out.println("Tamanho do array: " + tamanho);
```

## ⚠️ Observações Importantes

- **Tipo homogêneo:** Arrays armazenam elementos do mesmo tipo.
- **Tamanho fixo:** Após a inicialização, o tamanho do array não pode ser alterado.
- **Índices:** Os índices começam em 0 e vão até `length - 1`.



[Voltar ao Índice](#indice)

---


## <a name="parte34">34 - 033 - Arrays pt 02</a>

# Aula 33 – Arrays pt 02

📺 **Link do vídeo:** [Assista no YouTube](https://www.youtube.com/watch?v=S8Eaq6uxnd8)

## 🧠 Conteúdo Abordado

Nesta aula, o instrutor William Suane aprofunda o estudo sobre arrays em Java, abordando conceitos como:

- Acessando elementos de arrays
- Iterando sobre arrays com diferentes estruturas de repetição
- Utilizando a propriedade `length` para determinar o tamanho do array
- Práticas recomendadas ao trabalhar com arrays

### 🔹 Acessando Elementos de um Array

Os elementos de um array são acessados por índices, que começam em 0.

```java
int[] numeros = {10, 20, 30, 40, 50};
System.out.println(numeros[0]); // Saída: 10
System.out.println(numeros[4]); // Saída: 50
```

### 🔹 Iterando sobre Arrays

Podemos utilizar diferentes estruturas de repetição para percorrer os elementos de um array.

**Usando o loop `for`:**

```java
for (int i = 0; i < numeros.length; i++) {
    System.out.println("Elemento na posição " + i + ": " + numeros[i]);
}
```

**Usando o loop `while`:**

```java
int i = 0;
while (i < numeros.length) {
    System.out.println("Elemento na posição " + i + ": " + numeros[i]);
    i++;
}
```

**Usando o loop `do-while`:**

```java
int i = 0;
do {
    System.out.println("Elemento na posição " + i + ": " + numeros[i]);
    i++;
} while (i < numeros.length);
```

### 🔹 Propriedade `length`

A propriedade `length` retorna o tamanho do array, ou seja, o número de elementos que ele pode armazenar.

```java
System.out.println("Tamanho do array: " + numeros.length); // Saída: 5
```

### 🔹 Práticas Recomendadas

- **Evite acessar índices fora do intervalo:** Certifique-se de que os índices utilizados estão dentro do intervalo válido (0 a `length - 1`) para evitar `ArrayIndexOutOfBoundsException`.
- **Utilize loops apropriados:** Escolha a estrutura de repetição que melhor se adequa à lógica do seu programa.
- **Inicialize arrays corretamente:** Ao declarar arrays, certifique-se de inicializá-los antes de acessar seus elementos.


[Voltar ao Índice](#indice)

---


## <a name="parte35">35 - 034 - Arrays pt 03</a>

# Aula 33 – Arrays pt 02

📺 **Link do vídeo:** [Assista no YouTube](https://www.youtube.com/watch?v=S8Eaq6uxnd8)

## 🧠 Conteúdo Abordado

Nesta aula, o instrutor William Suane aprofunda o estudo sobre arrays em Java, abordando conceitos como:

- Acessando elementos de arrays
- Iterando sobre arrays com diferentes estruturas de repetição
- Utilizando a propriedade `length` para determinar o tamanho do array
- Práticas recomendadas ao trabalhar com arrays

### 🔹 Acessando Elementos de um Array

Os elementos de um array são acessados por índices, que começam em 0.

```java
int[] numeros = {10, 20, 30, 40, 50};
System.out.println(numeros[0]); // Saída: 10
System.out.println(numeros[4]); // Saída: 50
```

### 🔹 Iterando sobre Arrays

Podemos utilizar diferentes estruturas de repetição para percorrer os elementos de um array.

**Usando o loop `for`:**

```java
for (int i = 0; i < numeros.length; i++) {
    System.out.println("Elemento na posição " + i + ": " + numeros[i]);
}
```

**Usando o loop `while`:**

```java
int i = 0;
while (i < numeros.length) {
    System.out.println("Elemento na posição " + i + ": " + numeros[i]);
    i++;
}
```

**Usando o loop `do-while`:**

```java
int i = 0;
do {
    System.out.println("Elemento na posição " + i + ": " + numeros[i]);
    i++;
} while (i < numeros.length);
```

### 🔹 Propriedade `length`

A propriedade `length` retorna o tamanho do array, ou seja, o número de elementos que ele pode armazenar.

```java
System.out.println("Tamanho do array: " + numeros.length); // Saída: 5
```

### 🔹 Práticas Recomendadas

- **Evite acessar índices fora do intervalo:** Certifique-se de que os índices utilizados estão dentro do intervalo válido (0 a `length - 1`) para evitar `ArrayIndexOutOfBoundsException`.
- **Utilize loops apropriados:** Escolha a estrutura de repetição que melhor se adequa à lógica do seu programa.
- **Inicialize arrays corretamente:** Ao declarar arrays, certifique-se de inicializá-los antes de acessar seus elementos.


[Voltar ao Índice](#indice)

---


## <a name="parte36">36 - 035 - Arrays pt 04 - Foreach</a>

# Aula 35 – Arrays pt 04: Foreach

📺 **Link do vídeo:** [Assista no YouTube](https://www.youtube.com/watch?v=cl47iLWalUw)

## 🧠 Conteúdo Abordado

Nesta aula, o instrutor William Suane apresenta o loop `foreach` (também conhecido como "enhanced for loop") em Java, uma forma simplificada e mais legível de iterar sobre arrays e coleções.

---

## 🔹 O que é o `foreach`?

O `foreach` é uma estrutura de repetição introduzida no Java 5 que permite iterar sobre elementos de arrays ou coleções sem a necessidade de utilizar índices. Embora utilize a palavra-chave `for`, sua estrutura é diferente do `for` tradicional — por isso é conhecido como **"foreach"**.

---

## 🔹 Sintaxe do `foreach`

```java
for (Tipo elemento : arrayOuColecao) {
    // Bloco de código a ser executado para cada elemento
}
```

- `Tipo`: tipo do elemento dentro do array ou coleção.
- `elemento`: variável temporária que armazena o valor atual.
- `arrayOuColecao`: estrutura de dados a ser percorrida.

---

## 🔹 Exemplo 1: `foreach` com array de inteiros

```java
int[] numeros = {1, 2, 3, 4, 5};

// foreach para imprimir cada número
for (int numero : numeros) {
    System.out.println(numero);
}
```

**Saída:**

```
1
2
3
4
5
```

---

## 🔹 Exemplo 2: `foreach` com array de Strings

```java
String[] nomes = {"Ana", "Bruno", "Carlos"};

// foreach para imprimir cada nome
for (String nome : nomes) {
    System.out.println(nome);
}
```

**Saída:**

```
Ana
Bruno
Carlos
```

---

## ✅ Vantagens do `foreach`

- Código mais limpo e legível.
- Evita erros de acesso por índice.
- Ideal para percorrer todos os elementos de forma simples.

---

## ⚠️ Limitações do `foreach`

- Não permite acesso ao índice dos elementos.
- Não serve para modificar os elementos diretamente (em arrays de tipos primitivos).
- Só percorre os dados do início ao fim.

---



[Voltar ao Índice](#indice)

---


## <a name="parte37">37 - 036 - Arrays Multidimensionais pt 01</a>

# Aula 36 – Arrays Multidimensionais pt 01

📺 **Vídeo:** [Arrays Multidimensionais pt 01 - DevDojo](https://www.youtube.com/watch?v=EalQ6X_RtJk&list=PL62G310vn6nFIsOCC0H-C2infYgwm8SWW&index=37)

## 🧠 O que são Arrays Multidimensionais?

Em Java, arrays multidimensionais são estruturas que armazenam dados em mais de uma dimensão — como uma **tabela (matriz)** com linhas e colunas. O mais comum é o array bidimensional, ou seja, com duas dimensões.

---

## 🧱 Declaração de um Array Bidimensional

```java
int[][] dias = new int[2][2];
```

- Isso cria um array com **2 linhas** e **2 colunas**.
- Cada elemento do array `dias[i][j]` pode ser acessado e manipulado individualmente.

---

## 🛠️ Atribuindo valores

```java
dias[0][0] = 1;
dias[0][1] = 2;
dias[1][0] = 3;
dias[1][1] = 4;
```

---

## 🔁 Acessando elementos com `for` aninhado

```java
for (int i = 0; i < dias.length; i++) {
    for (int j = 0; j < dias[i].length; j++) {
        System.out.println("dias[" + i + "][" + j + "] = " + dias[i][j]);
    }
}
```

**Saída esperada:**

```
dias[0][0] = 1
dias[0][1] = 2
dias[1][0] = 3
dias[1][1] = 4
```

---

## 💡 Dicas da Aula

- `dias.length` retorna o número de **linhas**.
- `dias[i].length` retorna o número de **colunas da linha i**.
- Java permite arrays de arrays com **tamanhos diferentes** em cada linha.

### Exemplo de array com colunas irregulares:

```java
int[][] irregular = new int[2][];
irregular[0] = new int[2]; // 2 colunas na linha 0
irregular[1] = new int[3]; // 3 colunas na linha 1
```

---

## ✅ Vantagens de usar arrays multidimensionais

- Organizam dados em estrutura de grade (matriz).
- Úteis para tabelas, mapas, jogos, horários, etc.
- Podem ser aninhados com laços para iteração completa.

---

## 📌 Exercício proposto (extra)

Crie uma matriz `3x3` que armazene os números de 1 a 9 e imprima o conteúdo formatado.

```java
public class MatrizExemplo {
    public static void main(String[] args) {
        int[][] matriz = new int[3][3];
        int contador = 1;

        for (int i = 0; i < matriz.length; i++) {
            for (int j = 0; j < matriz[i].length; j++) {
                matriz[i][j] = contador++;
            }
        }

        // Impressão formatada
        for (int[] linha : matriz) {
            for (int valor : linha) {
                System.out.print(valor + " ");
            }
            System.out.println();
        }
    }
}
```

**Saída:**

```
1 2 3
4 5 6
7 8 9
```

---

🧠 **Conclusão:** Arrays multidimensionais são extremamente úteis para representar dados tabulares e devem ser bem compreendidos para manipulação de estruturas complexas em Java.

---


[Voltar ao Índice](#indice)

---


## <a name="parte38">38 - 037 - Arrays Multidimensionais pt 02 - Foreach</a>

# Aula 37 – Arrays Multidimensionais pt 02 - Foreach

📺 **Vídeo:** [Arrays Multidimensionais pt 02 - Foreach](https://www.youtube.com/watch?v=TGq3754CsN4&list=PL62G310vn6nFIsOCC0H-C2infYgwm8SWW&index=38)

## 🧠 O que foi abordado na aula?

Nesta aula, o professor explica como percorrer **arrays multidimensionais** utilizando o **laço `foreach`**, que facilita a leitura de elementos em arrays sem precisar controlar os índices manualmente.

---

## 🔁 Relembrando o `foreach`

O `foreach` é um **laço de repetição** utilizado para iterar diretamente sobre os elementos de um array ou coleção, sem a necessidade de índices.

### Sintaxe:

```java
for (tipo variavel : array) {
    // Ações com a variavel
}
```

---

## 🧱 Exemplo com array multidimensional

```java
public class AulaForeachMultidimensional {
    public static void main(String[] args) {
        int[][] arrayMultidimensional = {
            {1, 2, 3},
            {4, 5, 6},
            {7, 8, 9}
        };

        for (int[] linha : arrayMultidimensional) {
            for (int valor : linha) {
                System.out.print(valor + " ");
            }
            System.out.println();
        }
    }
}
```

### 🖨️ Saída:

```
1 2 3 
4 5 6 
7 8 9 
```

---

## ✅ Vantagens do uso de `foreach`

- Código mais limpo e legível.
- Elimina erros comuns com índices.
- Ideal para leitura e exibição de dados.

---

## ⚠️ Limitações

- Não permite acesso direto ao índice dos elementos.
- Não é possível alterar os elementos diretamente do array original (para arrays de tipos primitivos).

---

## 🧪 Exercício sugerido

Crie um array bidimensional de nomes de frutas e imprima todas as frutas usando `foreach`.

```java
public class ExercicioFrutas {
    public static void main(String[] args) {
        String[][] frutas = {
            {"Maçã", "Banana"},
            {"Laranja", "Uva"},
            {"Melancia", "Manga"}
        };

        for (String[] linha : frutas) {
            for (String fruta : linha) {
                System.out.print(fruta + " | ");
            }
            System.out.println();
        }
    }
}
```

**Saída:**

```
Maçã | Banana | 
Laranja | Uva | 
Melancia | Manga | 
```

---

## 🧠 Conclusão

Usar `foreach` com arrays multidimensionais deixa o código muito mais enxuto e prático para leitura e exibição de dados. Apesar de suas limitações, é uma ferramenta poderosa especialmente em situações onde o índice não é necessário.



[Voltar ao Índice](#indice)

---


## <a name="parte39">39 - 038 - Arrays Multidimensionais pt 03 - Inicialização</a>

# Aula 38 – Arrays Multidimensionais pt 03 - Inicialização

📺 **Vídeo:** [Arrays Multidimensionais pt 03 - Inicialização](https://www.youtube.com/watch?v=vp8bQZomKLo&list=PL62G310vn6nFIsOCC0H-C2infYgwm8SWW&index=39)

## 🧠 O que foi abordado na aula?

Nesta aula, o professor do DevDojo explica as formas de **inicialização de arrays multidimensionais em Java**, com foco na clareza e praticidade do código. Ele mostra como criar e atribuir valores a esses arrays de forma explícita ou separando a alocação da atribuição.

---

## 🔢 O que é um Array Multidimensional?

Um array multidimensional é uma estrutura de dados composta por **arrays dentro de arrays**. Em Java, arrays 2D são representados como `tipo[][]`, sendo o tipo mais comum `int[][]`, `String[][]`, etc.

---

## ✅ Formas de inicialização

### 1. Inicialização direta (em linha)

```java
int[][] numeros = {
    {1, 2, 3},
    {4, 5},
    {6, 7, 8, 9}
};
```

- Aqui o array já é criado e preenchido com valores.
- Permite criar "linhas" com diferentes quantidades de colunas (vetores irregulares).

### 2. Inicialização separada (alocação + atribuição)

```java
int[][] numeros = new int[3][];
numeros[0] = new int[]{1, 2, 3};
numeros[1] = new int[]{4, 5};
numeros[2] = new int[]{6, 7, 8, 9};
```

- Primeiro é alocado o array de arrays (`3` linhas).
- Depois, cada linha é instanciada individualmente com o número de colunas desejado.

---

## 🔍 Exemplo prático com `String`

```java
public class ExemploArrayMultidimensional {
    public static void main(String[] args) {
        String[][] nomes = {
            {"Ana", "Carlos"},
            {"Bruno"},
            {"Letícia", "Rafael", "Marcos"}
        };

        for (String[] grupo : nomes) {
            for (String nome : grupo) {
                System.out.print(nome + " ");
            }
            System.out.println();
        }
    }
}
```

### 🖨️ Saída:

```
Ana Carlos 
Bruno 
Letícia Rafael Marcos 
```

---

## 🧪 Dicas e boas práticas

- **Declare e inicialize em uma linha** sempre que possível para melhorar a legibilidade.
- Lembre-se que os arrays internos (colunas) podem ter tamanhos diferentes.
- Para arrays de grandes dimensões, mantenha o código organizado com indentação adequada.

---

## 🧠 Conclusão

Inicializar corretamente arrays multidimensionais em Java é essencial para a estruturação de dados mais complexos. A linguagem oferece flexibilidade para criar arrays regulares (matrizes) e irregulares (vetores de vetores). Entender como e quando usar cada forma de inicialização ajuda a escrever um código mais limpo e eficiente.



[Voltar ao Índice](#indice)

---


## <a name="parte40">40 - 039 - Orientação Objetos pt 01 - Introdução classes pt 01</a>

# Aula 39 – Orientação a Objetos pt 01: Introdução a Classes (Parte 1)

📺 **Vídeo:** [Orientação Objetos pt 01 - Introdução classes pt 01](https://www.youtube.com/watch?v=EyuPFLuvD7Q&list=PL62G310vn6nFIsOCC0H-C2infYgwm8SWW&index=40)

## 🧠 O que foi abordado na aula?

Nesta aula, foi feita uma introdução à **Programação Orientada a Objetos (POO)** em Java, com foco na **definição de classes** e **objetos**, que são os blocos fundamentais dessa abordagem.

O professor explica:
- O que é uma classe;
- Como criar uma classe;
- Como instanciar objetos a partir de uma classe.

---

## 📦 O que é uma Classe?

Uma **classe** é uma estrutura que define um **tipo de objeto**, incluindo seus **atributos (variáveis)** e **comportamentos (métodos)**.

```java
public class Carro {
    String modelo;
    String cor;
    int ano;
}
```

Essa classe `Carro` define o modelo genérico de um carro, com seus atributos básicos.

---

## 🧍 O que é um Objeto?

Um **objeto** é uma instância de uma classe. Após definir a estrutura com a classe, você pode criar objetos a partir dela:

```java
public class TesteCarro {
    public static void main(String[] args) {
        Carro carro1 = new Carro();
        carro1.modelo = "Fusca";
        carro1.cor = "Azul";
        carro1.ano = 1975;

        System.out.println("Modelo: " + carro1.modelo);
        System.out.println("Cor: " + carro1.cor);
        System.out.println("Ano: " + carro1.ano);
    }
}
```

### 🖨️ Saída:
```
Modelo: Fusca
Cor: Azul
Ano: 1975
```

---

## ✍️ Atributos

Os **atributos** são as variáveis que descrevem o estado de um objeto. No exemplo acima: `modelo`, `cor`, e `ano` são atributos da classe `Carro`.

---

## 🚀 Instanciando Objetos

Para criar um objeto a partir de uma classe, usamos a palavra-chave `new`:

```java
Carro meuCarro = new Carro();
```

---

## 📚 Detalhes Adicionais

- Uma **classe** é como uma planta (blueprint).
- Um **objeto** é como a construção feita a partir dessa planta.
- Você pode criar vários objetos a partir de uma mesma classe.
- Por padrão, os atributos de uma classe têm valores padrão (como `null` para Strings e `0` para inteiros), caso não sejam atribuídos manualmente.

---

## 🧠 Conclusão

A introdução às classes é o primeiro passo na jornada de **Programação Orientada a Objetos** em Java. Entender como declarar classes e instanciar objetos é essencial para construir programas organizados, reutilizáveis e com maior coesão.

Na próxima aula, o professor continuará com o aprofundamento em classes, adicionando **métodos** e **comportamentos**.



[Voltar ao Índice](#indice)

---


## <a name="parte41">41 - 040 - Orientação Objetos - Introdução classes pt 02</a>

# Aula 40 – Orientação a Objetos: Introdução a Classes (Parte 2)

📺 **Vídeo:** [Orientação Objetos - Introdução classes pt 02](https://www.youtube.com/watch?v=uB7KvSz6WiA&list=PL62G310vn6nFIsOCC0H-C2infYgwm8SWW&index=41)

## 🧠 O que foi abordado na aula?

Nesta continuação da introdução a **classes em Java**, o professor explora:
- Declaração de **métodos**;
- Diferença entre **atributos** e **comportamentos**;
- A importância de **modularizar comportamentos** dentro de métodos;
- Criação de uma classe com atributos e métodos;
- Instanciação de objetos que utilizam esses métodos.

---

## 🧱 Exemplo prático de uma classe com métodos

```java
public class Carro {
    String modelo;
    String cor;
    int ano;

    void ligar() {
        System.out.println("O carro está ligado!");
    }

    void exibirDetalhes() {
        System.out.println("Modelo: " + modelo);
        System.out.println("Cor: " + cor);
        System.out.println("Ano: " + ano);
    }
}
```

### 🧪 Classe de Teste

```java
public class TesteCarro {
    public static void main(String[] args) {
        Carro carro1 = new Carro();
        carro1.modelo = "Gol";
        carro1.cor = "Branco";
        carro1.ano = 2020;

        carro1.ligar();
        carro1.exibirDetalhes();
    }
}
```

### ✅ Saída esperada:
```
O carro está ligado!
Modelo: Gol
Cor: Branco
Ano: 2020
```

---

## 📌 Conceitos reforçados na aula

- **Atributos**: representam o estado do objeto;
- **Métodos**: representam ações/comportamentos do objeto;
- Os métodos são declarados com `void` (quando não retornam valor), seguidos pelo nome e, opcionalmente, parâmetros;
- Os métodos ajudam a **organizar melhor o código** e **reutilizar comportamentos**.

---

## 🎯 Boas práticas

- Nomear métodos com verbos (ex: `ligar`, `exibirDetalhes`);
- Separar responsabilidades: cada método deve realizar uma única tarefa;
- Criar métodos para evitar repetições de código no `main`.

---

## 🧠 Conclusão

Nessa etapa, além dos atributos, aprendemos como **dar vida aos objetos** com métodos. O uso de métodos é essencial na Programação Orientada a Objetos, pois define o **comportamento das classes**, permitindo que elas interajam com outras partes do programa de maneira mais clara, organizada e reutilizável.

Na próxima aula, o foco será na criação de **métodos com retorno**, introduzindo mais dinamismo à lógica dos objetos.



[Voltar ao Índice](#indice)

---


## <a name="parte42">42 - 041 - Orientação Objetos - Coesão</a>

# Aula 41 – Orientação a Objetos: Coesão

📺 **Vídeo:** [Orientação Objetos - Coesão](https://www.youtube.com/watch?v=dJLYPP1ExYY&list=PL62G310vn6nFIsOCC0H-C2infYgwm8SWW&index=42)

## 🧠 O que é Coesão?

**Coesão** é um dos princípios fundamentais da **Programação Orientada a Objetos (POO)** e se refere ao grau em que os elementos de uma classe estão relacionados entre si e com sua **finalidade**.

- Uma classe coesa possui **atributos e métodos que fazem sentido juntos**, ou seja, **trabalham por um mesmo objetivo**.
- **Alta coesão** resulta em classes **simples, compreensíveis e reutilizáveis**.
- **Baixa coesão** significa que a classe está assumindo muitas responsabilidades diferentes e provavelmente precisa ser **refatorada**.

---

## ✅ Exemplo de Alta Coesão

```java
public class Impressora {
    void imprimirDocumento(String texto) {
        System.out.println("Imprimindo: " + texto);
    }

    void limparCabecote() {
        System.out.println("Limpando cabeçote de impressão...");
    }

    void nivelTinta() {
        System.out.println("Verificando nível de tinta...");
    }
}
```

Essa classe está coesa porque todos os métodos têm relação com a **função de uma impressora**.

---

## ❌ Exemplo de Baixa Coesão

```java
public class Util {
    void imprimirDocumento(String texto) {
        System.out.println("Imprimindo: " + texto);
    }

    void calcularSalario(double horas, double valorHora) {
        double salario = horas * valorHora;
        System.out.println("Salário: " + salario);
    }

    void enviarEmail(String destinatario) {
        System.out.println("Enviando email para: " + destinatario);
    }
}
```

A classe acima tem métodos **sem relação entre si** – está lidando com impressão, cálculo de salário e envio de e-mail. Isso **quebra o princípio da coesão**.

---

## 📌 Por que Coesão é importante?

- Facilita a **manutenção** do código;
- Aumenta a **clareza** e legibilidade da classe;
- Permite a **reutilização** mais eficiente;
- Reduz o **acoplamento** entre diferentes partes do sistema;
- Favorece o uso de **boas práticas de design**.

---

## 🎯 Dica do professor

Pense sempre: **"Minha classe tem uma responsabilidade clara?"**

Se a resposta for **não**, considere **dividir em múltiplas classes**, cada uma com seu propósito.

---

## 🧠 Conclusão

A **coesão** é um princípio essencial na hora de construir boas classes na Programação Orientada a Objetos. Manter a coesão ajuda a criar sistemas mais organizados, fáceis de manter e evoluir.


[Voltar ao Índice](#indice)

---


## <a name="parte43">43 - 042 - Orientação Objetos - Exercício Classes</a>

# Aula 42 – Orientação a Objetos: Exercício Classes

📺 **Vídeo:** [Orientação Objetos - Exercício Classes](https://www.youtube.com/watch?v=JbL4SAFORco&list=PL62G310vn6nFIsOCC0H-C2infYgwm8SWW&index=43)

## 🧠 Objetivo da Aula

Nesta aula, é proposto um exercício prático para reforçar os conceitos de **criação de classes**, **instanciação de objetos**, **atributos** e **métodos** em Java, com base nos princípios de **orientação a objetos** aprendidos anteriormente.

---

## 🧱 Estrutura do Exercício

O exercício consiste em criar uma classe que represente uma pessoa, contendo **atributos**, **métodos** e a **utilização dessa classe no método `main`**.

---

## 💡 Exemplo: Classe `Pessoa`

```java
public class Pessoa {
    String nome;
    int idade;

    void apresentar() {
        System.out.println("Olá, meu nome é " + nome + " e eu tenho " + idade + " anos.");
    }
}
```

---

## 🚀 Utilizando a Classe no `main`

```java
public class Main {
    public static void main(String[] args) {
        Pessoa pessoa1 = new Pessoa();
        pessoa1.nome = "João";
        pessoa1.idade = 30;

        Pessoa pessoa2 = new Pessoa();
        pessoa2.nome = "Maria";
        pessoa2.idade = 25;

        pessoa1.apresentar();
        pessoa2.apresentar();
    }
}
```

### 🖨️ Saída:
```
Olá, meu nome é João e eu tenho 30 anos.
Olá, meu nome é Maria e eu tenho 25 anos.
```

---

## 🧱 Conceitos Reforçados

- Criação de **classes** com atributos e métodos.
- Uso do operador `new` para **instanciar objetos**.
- Acesso a atributos e métodos de objetos com o operador `.`.
- Separação clara de **responsabilidades**: a classe `Pessoa` representa uma entidade do mundo real.

---

## 📌 Boas Práticas

- A classe deve representar bem o seu conceito do mundo real.
- Os nomes dos métodos e atributos devem ser **claros e descritivos**.
- Cada classe deve ser **coesa**, ou seja, focada em uma única responsabilidade.

---

## ✅ Desafio

Tente adaptar esse exemplo para outras entidades, como `Carro`, `Aluno`, `Produto`, entre outros. Crie novos métodos e pratique o uso de diferentes tipos de dados.

---

## 🧠 Conclusão

Esse exercício ajuda a fixar os conceitos de orientação a objetos e preparar o terreno para conceitos mais avançados como **encapsulamento, herança e polimorfismo**.


[Voltar ao Índice](#indice)

---


## <a name="parte44">44 - 043 - Orientação Objetos - Referência de objetos</a>

# Aula 43 – Orientação a Objetos: Referência de Objetos

📺 **Vídeo:** [Orientação Objetos - Referência de objetos](https://www.youtube.com/watch?v=g_SGuMYHgI0&list=PL62G310vn6nFIsOCC0H-C2infYgwm8SWW&index=44)

## 🧠 Objetivo da Aula

Esta aula aborda como funciona a **referência de objetos** em Java. O foco é entender que quando atribuímos um objeto a outro, **ambos passam a apontar para o mesmo espaço de memória**, e **alterações feitas por um se refletem no outro**.

---

## 🔄 Conceito: Referência

Em Java, variáveis de tipo objeto não armazenam o valor diretamente, mas sim uma **referência (endereço) para um espaço de memória** onde o objeto está armazenado.

---

## 💡 Exemplo: Referência Compartilhada

```java
public class Pessoa {
    String nome;
}

public class Main {
    public static void main(String[] args) {
        Pessoa pessoa1 = new Pessoa();
        pessoa1.nome = "João";

        Pessoa pessoa2 = pessoa1; // pessoa2 aponta para o mesmo objeto de pessoa1

        pessoa2.nome = "Maria";

        System.out.println(pessoa1.nome); // Maria
        System.out.println(pessoa2.nome); // Maria
    }
}
```

### 🖨️ Saída:
```
Maria
Maria
```

### 📌 Explicação:

- `pessoa2 = pessoa1` não cria uma nova cópia do objeto.
- Ambas variáveis (`pessoa1` e `pessoa2`) apontam para **o mesmo objeto na memória**.
- Alterar o atributo `nome` por meio de `pessoa2` também altera o que é visto por `pessoa1`.

---

## 🧪 Cuidado com Referências!

Se você quiser **copiar um objeto**, precisa instanciar um novo e copiar manualmente os valores de seus atributos, ou usar técnicas como:

- Construtores de cópia
- Métodos de clonagem

---

## 🔁 Comparando Referências

```java
Pessoa pessoa1 = new Pessoa();
Pessoa pessoa2 = new Pessoa();
Pessoa pessoa3 = pessoa1;

System.out.println(pessoa1 == pessoa2); // false
System.out.println(pessoa1 == pessoa3); // true
```

### ✅ Explicação:
- `==` verifica se duas variáveis referem-se **ao mesmo objeto** (mesmo endereço de memória), e **não o conteúdo**.

---

## 🧠 Conclusão

Compreender como as referências funcionam em Java é essencial para evitar bugs e comportamentos inesperados em programas orientados a objetos. 

Sempre que estiver manipulando objetos, lembre-se que **você está trabalhando com ponteiros para memória**, e não diretamente com os dados em si.



[Voltar ao Índice](#indice)

---


## <a name="parte45">45 - 044 - Orientação Objetos - Métodos pt 01</a>

# Aula 44 – Orientação a Objetos: Métodos (Parte 1)

🎥 **Vídeo:** [Orientação Objetos - Métodos pt 01](https://www.youtube.com/watch?v=ZM0AJhKjLYc&list=PL62G310vn6nFIsOCC0H-C2infYgwm8SWW&index=45)

## 📌 Objetivo da Aula

Introdução ao conceito de **métodos** em Java no contexto da **Programação Orientada a Objetos (POO)**. A aula demonstra como criar, declarar e utilizar métodos dentro de classes, com foco na reutilização e organização de código.

---

## 🧠 O que é um Método?

Um **método** é um bloco de código que realiza uma ação. Pode receber parâmetros (entradas) e pode retornar um valor (saída). Os métodos ajudam a manter o código organizado, reutilizável e mais fácil de manter.

---

## 🧱 Estrutura de um Método

```java
[modificadorDeAcesso] tipoDeRetorno nomeDoMetodo(parâmetros) {
    // corpo do método
}
```

### 🔹 Exemplos:

```java
public class Calculadora {

    // Método sem retorno (void) e sem parâmetros
    void exibirMensagem() {
        System.out.println("Bem-vindo à Calculadora!");
    }

    // Método com retorno e com parâmetros
    int somar(int a, int b) {
        return a + b;
    }
}
```

---

## 🚀 Usando Métodos

```java
public class Main {
    public static void main(String[] args) {
        Calculadora calc = new Calculadora();

        calc.exibirMensagem(); // Chamada de método sem retorno

        int resultado = calc.somar(10, 5); // Chamada com retorno
        System.out.println("Resultado: " + resultado);
    }
}
```

### 🖨️ Saída:
```
Bem-vindo à Calculadora!
Resultado: 15
```

---

## ✅ Boas Práticas (Best Practices)

- ✅ **Nomeie métodos de forma clara e descritiva.** Use verbos no infinitivo (ex: `calcularMedia`, `exibirMensagem`, `somarValores`).
- ✅ **Cada método deve ter uma responsabilidade única.** A coesão é essencial para a clareza do código.
- ✅ **Utilize parâmetros para tornar métodos reutilizáveis.**
- ✅ **Documente métodos** (com `JavaDoc`, por exemplo) para explicar o que eles fazem.
- ✅ **Evite duplicação de código** utilizando métodos sempre que a mesma lógica for repetida.

---

## ❌ Práticas a Evitar (Bad Practices)

- ❌ **Métodos muito longos** e que fazem muitas coisas (baixa coesão).
- ❌ **Usar nomes genéricos** como `fazerAlgo()` ou `coisa()`.
- ❌ **Ignorar o uso de retorno** quando ele pode ser útil para reutilização de resultados.
- ❌ **Misturar regras de negócio com exibição de dados** em um mesmo método (ex: `calcularResultadoEImprimirNaTela()`).
- ❌ **Criar métodos estáticos sem necessidade**, pois quebra o princípio de orientação a objetos.

---

## 🧠 Conclusão

Os **métodos** são componentes fundamentais para a construção de sistemas orientados a objetos. Eles promovem **organização, legibilidade, reutilização e coesão** no código. Aprender a usá-los corretamente é um passo essencial para escrever bons programas em Java.



[Voltar ao Índice](#indice)

---


## <a name="parte46">46 - 045 - Orientação Objetos - Métodos pt 02 - Parâmetros</a>

# Aula 45 – Orientação a Objetos: Métodos (Parte 2 - Parâmetros)

🎥 **Vídeo:** [Orientação Objetos - Métodos pt 02 - Parâmetros](https://www.youtube.com/watch?v=op6inGTMBiw&list=PL62G310vn6nFIsOCC0H-C2infYgwm8SWW&index=46)

## 🎯 Objetivo da Aula

Aprender como **parâmetros** funcionam dentro de **métodos** em Java. Entender como passá-los, usá-los e como isso torna os métodos mais reutilizáveis e dinâmicos. 

---

## 🧠 O que são Parâmetros?

Parâmetros são **variáveis declaradas na assinatura de um método**. Eles permitem a passagem de dados para dentro do método no momento da chamada, tornando-o mais flexível.

---

## 🧱 Sintaxe de um Método com Parâmetro

```java
[modificadorDeAcesso] tipoDeRetorno nomeDoMetodo(tipo parametro) {
    // corpo do método
}
```

---

## 💡 Exemplo Básico

```java
public class Saudacao {
    void exibirMensagem(String nome) {
        System.out.println("Olá, " + nome + "!");
    }
}
```

```java
public class Main {
    public static void main(String[] args) {
        Saudacao saudacao = new Saudacao();
        saudacao.exibirMensagem("Ana");
        saudacao.exibirMensagem("Carlos");
    }
}
```

### 🖨️ Saída:
```
Olá, Ana!
Olá, Carlos!
```

---

## 💡 Exemplo com Múltiplos Parâmetros

```java
public class Calculadora {
    int somar(int a, int b) {
        return a + b;
    }
}
```

```java
public class Main {
    public static void main(String[] args) {
        Calculadora calc = new Calculadora();
        int resultado = calc.somar(5, 10);
        System.out.println("Resultado: " + resultado);
    }
}
```

---

## 💡 Exemplo Complexo com Objeto como Parâmetro

```java
public class Produto {
    String nome;
    double preco;

    Produto(String nome, double preco) {
        this.nome = nome;
        this.preco = preco;
    }
}

public class Carrinho {
    void adicionarProduto(Produto produto) {
        System.out.println("Adicionado: " + produto.nome + " por R$" + produto.preco);
    }
}
```

```java
public class Main {
    public static void main(String[] args) {
        Produto p1 = new Produto("Notebook", 3500.00);
        Carrinho carrinho = new Carrinho();
        carrinho.adicionarProduto(p1);
    }
}
```

---

## ✅ Boas Práticas

- ✅ **Utilize nomes descritivos para os parâmetros**
  - Exemplo: `nome`, `idade`, `quantidade`.

- ✅ **Mantenha o método coeso**
  - Um método deve ter uma única responsabilidade clara.

- ✅ **Valide os parâmetros**
  - Principalmente se vierem de entradas do usuário.

- ✅ **Reduza o número de parâmetros**
  - Prefira objetos de transferência (DTOs) quando houver muitos parâmetros.

- ✅ **Documente o que cada parâmetro representa**
  - Comentários ou Javadoc ajudam na manutenção do código.

---

## ❌ Práticas a Evitar

- ❌ **Nomes genéricos ou confusos para parâmetros**
  - Exemplo: `x`, `y`, `data1`.

- ❌ **Métodos com muitos parâmetros**
  - Exemplo: `processar(int a, int b, int c, String nome, double taxa, boolean ativo)`

- ❌ **Alterar o valor dos parâmetros diretamente**
  - Especialmente se o parâmetro for um objeto mutável.

- ❌ **Ignorar validações**
  - Pode causar exceções ou lógica incorreta.

---

## 📌 Dica Extra

Se você estiver passando **muitos parâmetros** para um método, considere criar uma **classe auxiliar** para encapsular esses dados:

```java
public class PedidoInfo {
    String produto;
    int quantidade;
    double preco;
    // construtor, getters, setters
}
```

```java
public class PedidoService {
    void processarPedido(PedidoInfo info) {
        // lógica usando info.produto, info.quantidade, etc.
    }
}
```

---

## ✅ Conclusão

O uso de parâmetros é fundamental para a **flexibilidade** e **reutilização** dos métodos em Java. Compreender sua estrutura, boas práticas e evitar armadilhas comuns são passos importantes na evolução como desenvolvedor orientado a objetos.



[Voltar ao Índice](#indice)

---


## <a name="parte47">47 - 046 - Orientação Objetos - Métodos pt 03 - Retorno pt 01</a>

# Aula 46 – Orientação a Objetos: Métodos pt 03 - Retorno (Parte 1)

🎥 **Vídeo:** [Métodos pt 03 - Retorno pt 01](https://www.youtube.com/watch?v=FCnTsy2EzSw&list=PL62G310vn6nFIsOCC0H-C2infYgwm8SWW&index=47)

## 🎯 Objetivo da Aula

Compreender como os **métodos com retorno** funcionam em Java, como declarar e utilizar o valor retornado. A aula mostra como métodos podem retornar valores úteis para outras partes do código.

---

## 🧠 O que é o Retorno de um Método?

- Um método pode retornar um **valor** após sua execução.
- O tipo de retorno é declarado na **assinatura do método**.
- O comando `return` é usado para devolver o valor.

### Sintaxe:
```java
tipo nomeDoMetodo() {
    return valor;
}
```

---

## 💡 Exemplo Básico - Método que retorna um número

```java
public class Calculadora {
    int somar(int a, int b) {
        return a + b;
    }
}
```

```java
public class Main {
    public static void main(String[] args) {
        Calculadora calc = new Calculadora();
        int resultado = calc.somar(10, 5);
        System.out.println("Resultado da soma: " + resultado);
    }
}
```

---

## 💡 Exemplo Intermediário - Retorno de String

```java
public class Saudacao {
    String mensagemDeBoasVindas(String nome) {
        return "Bem-vindo, " + nome + "!";
    }
}
```

```java
public class Main {
    public static void main(String[] args) {
        Saudacao saudacao = new Saudacao();
        String msg = saudacao.mensagemDeBoasVindas("Maria");
        System.out.println(msg);
    }
}
```

---

## 💡 Exemplo Complexo - Retorno de Objeto

```java
public class Produto {
    String nome;
    double preco;

    Produto(String nome, double preco) {
        this.nome = nome;
        this.preco = preco;
    }
}

public class Estoque {
    Produto buscarProdutoMaisCaro() {
        return new Produto("Notebook Gamer", 7500.00);
    }
}
```

```java
public class Main {
    public static void main(String[] args) {
        Estoque estoque = new Estoque();
        Produto p = estoque.buscarProdutoMaisCaro();
        System.out.println("Produto: " + p.nome + ", Preço: R$" + p.preco);
    }
}
```

---

## ✅ Boas Práticas

- ✅ **Use o tipo de retorno correto** conforme a lógica do método.
- ✅ **Documente o retorno** (ex: com Javadoc).
- ✅ **Evite lógica excessiva dentro do método**, mantenha-o coeso.
- ✅ **Valide os dados antes de retornar**, quando necessário.
- ✅ **Prefira retornar objetos ao invés de múltiplos valores soltos**.

---

## ❌ Más Práticas a Evitar

- ❌ **Retornar valores irrelevantes** ou sempre fixos (ex: sempre `0` ou `null`).
- ❌ **Executar várias tarefas no método além do necessário** (falta de coesão).
- ❌ **Retornar dados modificados inesperadamente** (quebra de encapsulamento).
- ❌ **Deixar código duplicado em métodos semelhantes**.

---

## 📌 Dica Extra

Se um método **não precisar retornar nada**, use o tipo `void`:

```java
void imprimirMensagem(String msg) {
    System.out.println(msg);
}
```

Se quiser retornar algo depois de algum cálculo ou processo, troque o `void` pelo tipo necessário e use `return`.

---

## ✅ Conclusão

Entender o uso do `return` e métodos com retorno é fundamental para criar sistemas **modulares, reutilizáveis e fáceis de manter**. Eles ajudam a separar responsabilidades e permitem reutilizar lógicas complexas com simplicidade.



[Voltar ao Índice](#indice)

---


## <a name="parte48">48 - 047 - Orientação Objetos - Métodos pt 04 - Retorno pt 02</a>

# Aula 47 – Orientação a Objetos: Métodos pt 04 - Retorno (Parte 2)

🎥 **Vídeo:** [Métodos pt 04 - Retorno pt 02](https://www.youtube.com/watch?v=d0BO5mBBFK8&list=PL62G310vn6nFIsOCC0H-C2infYgwm8SWW&index=48)

## 🎯 Objetivo da Aula

Aprofundar o entendimento sobre métodos que retornam valores em Java, explorando diferentes tipos de retorno, boas práticas e erros comuns a serem evitados.

---

## 🧠 Conceitos Fundamentais

- **Tipo de Retorno:** O tipo especificado na assinatura do método deve corresponder ao tipo do valor retornado.
- **Uso do `return`:** A instrução `return` é utilizada para devolver um valor ao chamador do método.
- **Métodos `void`:** Métodos declarados com `void` não retornam valor e não precisam de uma instrução `return`, embora possam usá-la para sair antecipadamente do método.

---

## 💡 Exemplo Básico - Retorno de Valor Primitivo

```java
public class Calculadora {
    public int multiplicar(int a, int b) {
        return a * b;
    }
}
```

```java
public class Main {
    public static void main(String[] args) {
        Calculadora calc = new Calculadora();
        int resultado = calc.multiplicar(4, 5);
        System.out.println("Resultado: " + resultado);
    }
}
```

---

## 💡 Exemplo Intermediário - Retorno de Objeto

```java
public class Produto {
    String nome;
    double preco;

    Produto(String nome, double preco) {
        this.nome = nome;
        this.preco = preco;
    }
}

public class Estoque {
    public Produto obterProdutoMaisCaro() {
        return new Produto("Notebook", 3500.00);
    }
}
```

```java
public class Main {
    public static void main(String[] args) {
        Estoque estoque = new Estoque();
        Produto produto = estoque.obterProdutoMaisCaro();
        System.out.println("Produto: " + produto.nome + ", Preço: R$" + produto.preco);
    }
}
```

---

## 💡 Exemplo Avançado - Retorno de Coleção

```java
import java.util.ArrayList;
import java.util.List;

public class Carrinho {
    public List<String> listarProdutos() {
        List<String> produtos = new ArrayList<>();
        produtos.add("Mouse");
        produtos.add("Teclado");
        produtos.add("Monitor");
        return produtos;
    }
}
```

```java
public class Main {
    public static void main(String[] args) {
        Carrinho carrinho = new Carrinho();
        List<String> produtos = carrinho.listarProdutos();
        for (String produto : produtos) {
            System.out.println("Produto: " + produto);
        }
    }
}
```

---

## ✅ Boas Práticas

- **Correspondência de Tipos:** Certifique-se de que o tipo de retorno declarado corresponde ao tipo do valor retornado.
- **Clareza no Retorno:** Retorne valores significativos que façam sentido no contexto do método.
- **Documentação:** Utilize comentários ou Javadoc para descrever o que o método retorna.
- **Evite Retornar `null`:** Sempre que possível, evite retornar `null` para prevenir `NullPointerException`. Considere retornar objetos vazios ou usar `Optional`.
- **Consistência:** Mantenha consistência nos tipos de retorno em métodos similares.

---

## ❌ Práticas a Evitar

- **Retornar Tipos Incompatíveis:** Evite retornar um tipo diferente do declarado na assinatura do método, pois isso causará erros de compilação.
- **Retornar `null` Desnecessariamente:** Retornar `null` pode levar a erros em tempo de execução. Prefira retornar objetos vazios ou utilizar `Optional`.
- **Métodos com Múltiplos Pontos de Retorno Confusos:** Embora múltiplos `return` possam ser úteis, evite usá-los de forma que torne o código difícil de entender.
- **Ignorar o Valor Retornado:** Se um método retorna um valor, utilize-o. Ignorar o valor pode indicar que o método deveria ser `void`.

---

## 📌 Dica Extra

Para métodos que podem não ter um valor a retornar, considere o uso de `Optional`:

```java
import java.util.Optional;

public class UsuarioService {
    public Optional<Usuario> buscarUsuarioPorId(int id) {
        // Lógica para buscar o usuário
        if (/* usuário encontrado */) {
            return Optional.of(usuario);
        } else {
            return Optional.empty();
        }
    }
}
```

---

## ✅ Conclusão

Compreender e aplicar corretamente o conceito de retorno em métodos é essencial para escrever código Java limpo, eficiente e livre de erros. Utilize os exemplos e práticas descritas acima para aprimorar suas habilidades em programação orientada a objetos.


[Voltar ao Índice](#indice)

---


## <a name="parte49">49 - 048 - Orientação Objetos - Métodos pt 05 - Parâmetros tipo primitivo</a>

# Aula 48 – Orientação a Objetos: Métodos pt 05 - Parâmetros Tipo Primitivo

🎥 **Vídeo:** [Métodos pt 05 - Parâmetros tipo primitivo](https://www.youtube.com/watch?v=-izqpkaXKx0&list=PL62G310vn6nFIsOCC0H-C2infYgwm8SWW&index=49)

## 🎯 Objetivo da Aula

Compreender como os métodos em Java recebem e manipulam parâmetros de tipos primitivos, destacando o comportamento de passagem por valor e suas implicações.

---

## 🧠 Conceitos Fundamentais

- **Tipos Primitivos em Java:** `byte`, `short`, `int`, `long`, `float`, `double`, `char`, `boolean`.
- **Passagem por Valor:** Em Java, todos os parâmetros são passados por valor. Para tipos primitivos, isso significa que o método recebe uma cópia do valor original, e alterações dentro do método não afetam a variável original.

---

## 💡 Exemplo Básico - Passagem por Valor

```java
public class Exemplo {
    public static void incrementar(int numero) {
        numero++;
        System.out.println("Dentro do método: " + numero);
    }

    public static void main(String[] args) {
        int valor = 5;
        incrementar(valor);
        System.out.println("Fora do método: " + valor);
    }
}
```

**Saída:**
```
Dentro do método: 6
Fora do método: 5
```

*Explicação:* O método `incrementar` recebe uma cópia do valor de `valor`. Alterações em `numero` dentro do método não afetam `valor` fora dele.

---

## 💡 Exemplo Intermediário - Operações com Vários Parâmetros Primitivos

```java
public class Calculadora {
    public static int somar(int a, int b) {
        return a + b;
    }

    public static void main(String[] args) {
        int resultado = somar(10, 20);
        System.out.println("Resultado da soma: " + resultado);
    }
}
```

*Explicação:* O método `somar` recebe dois parâmetros primitivos, realiza a operação e retorna o resultado. Os valores originais não são modificados.

---

## 💡 Exemplo Avançado - Utilizando Tipos Primitivos em Cálculos Complexos

```java
public class ConversorTemperatura {
    public static double celsiusParaFahrenheit(double celsius) {
        return (celsius * 9/5) + 32;
    }

    public static void main(String[] args) {
        double celsius = 25.0;
        double fahrenheit = celsiusParaFahrenheit(celsius);
        System.out.println(celsius + "°C equivalem a " + fahrenheit + "°F");
    }
}
```

*Explicação:* O método `celsiusParaFahrenheit` realiza uma conversão utilizando um parâmetro primitivo do tipo `double`.

---

## ✅ Boas Práticas

- **Utilize Tipos Primitivos Quando Possível:** Eles são mais eficientes em termos de desempenho e uso de memória.
- **Evite Modificar Parâmetros Primitivos Dentro do Método:** Como são passados por valor, alterações não afetam o valor original, o que pode levar a confusões.
- **Documente o Comportamento dos Métodos:** Especifique claramente se o método modifica ou não os valores passados.
- **Escolha o Tipo Primitivo Adequado:** Utilize o tipo que melhor representa o dado e evita desperdício de memória.

---

## ❌ Práticas a Evitar

- **Não Presuma que Alterações em Parâmetros Primitivos Afetam o Valor Original:** Lembre-se que são passados por valor.
- **Evite Usar Tipos Primitivos em Contextos que Requerem Objetos:** Por exemplo, ao trabalhar com coleções genéricas, utilize as classes wrapper correspondentes (`Integer`, `Double`, etc.).
- **Não Utilize Tipos Primitivos para Representar Estados Complexos:** Prefira enums ou objetos para representar estados ou comportamentos mais complexos.

---

## 📌 Dica Extra

Ao trabalhar com coleções ou APIs que exigem objetos, utilize as classes wrapper correspondentes aos tipos primitivos:

```java
List<Integer> numeros = new ArrayList<>();
numeros.add(10); // Autoboxing de int para Integer
```

*Explicação:* O Java realiza automaticamente a conversão de tipos primitivos para suas classes wrapper correspondentes (autoboxing) quando necessário.

---

## ✅ Conclusão

Entender como os parâmetros de tipos primitivos são passados e manipulados em métodos é fundamental para evitar comportamentos inesperados e escrever código Java eficiente e claro.



[Voltar ao Índice](#indice)

---


## <a name="parte50">50 - 049 - Orientação Objetos - Métodos pt 06 - Parâmetros tipo referência</a>

# Aula 49 – Orientação a Objetos: Métodos pt 06 - Parâmetros Tipo Referência

🎥 **Vídeo:** [Métodos pt 06 - Parâmetros tipo referência](https://www.youtube.com/watch?v=C-tmxo4FcKs)

## 🎯 Objetivo da Aula

Compreender como os métodos em Java recebem e manipulam parâmetros de tipos referência (objetos), destacando o comportamento de passagem por valor de referências e suas implicações.

---

## 🧠 Conceitos Fundamentais

- **Tipos de Referência em Java:** Incluem todas as classes, interfaces, arrays e enumeradores.
- **Passagem por Valor de Referência:** Em Java, todos os parâmetros são passados por valor. No caso de objetos, o valor passado é a referência ao objeto, permitindo que métodos modifiquem o estado interno do objeto, mas não a referência em si.
- **Imutabilidade da Referência:** Alterar a referência dentro do método não afeta a referência original fora dele.

---

## 💡 Exemplo Básico - Modificando o Estado do Objeto

```java
public class Pessoa {
    String nome;
}

public class Exemplo {
    public static void alterarNome(Pessoa p) {
        p.nome = "João";
    }

    public static void main(String[] args) {
        Pessoa pessoa = new Pessoa();
        pessoa.nome = "Maria";
        alterarNome(pessoa);
        System.out.println(pessoa.nome); // Saída: João
    }
}
```

*Explicação:* O método `alterarNome` modifica o atributo `nome` do objeto `Pessoa`. Como a referência ao objeto é passada por valor, o método pode alterar o estado interno do objeto.

---

## 💡 Exemplo Intermediário - Tentando Alterar a Referência

```java
public class Pessoa {
    String nome;
}

public class Exemplo {
    public static void criarNovaPessoa(Pessoa p) {
        p = new Pessoa();
        p.nome = "Carlos";
    }

    public static void main(String[] args) {
        Pessoa pessoa = new Pessoa();
        pessoa.nome = "Ana";
        criarNovaPessoa(pessoa);
        System.out.println(pessoa.nome); // Saída: Ana
    }
}
```

*Explicação:* O método `criarNovaPessoa` atribui uma nova instância à variável `p`, mas essa alteração não afeta a variável `pessoa` no método `main`, pois a referência é passada por valor.

---

## 💡 Exemplo Avançado - Modificando Objetos em Coleções

```java
import java.util.ArrayList;
import java.util.List;

public class Exemplo {
    public static void adicionarElemento(List<String> lista) {
        lista.add("Novo Elemento");
    }

    public static void main(String[] args) {
        List<String> minhaLista = new ArrayList<>();
        minhaLista.add("Elemento 1");
        adicionarElemento(minhaLista);
        System.out.println(minhaLista); // Saída: [Elemento 1, Novo Elemento]
    }
}
```

*Explicação:* O método `adicionarElemento` modifica o conteúdo da lista, e essa modificação é refletida fora do método, pois a lista é um objeto e sua referência é passada por valor.

---

## ✅ Boas Práticas

- **Compreensão Clara da Passagem por Valor de Referência:** Entenda que, embora a referência seja passada por valor, o objeto referenciado pode ser modificado dentro do método.
- **Evite Alterar a Referência Dentro do Método:** Alterar a referência dentro do método não afeta a referência original e pode causar confusão.
- **Documente o Comportamento dos Métodos:** Especifique claramente se o método modifica ou não o estado dos objetos passados como parâmetros.
- **Utilize Objetos Imutáveis Quando Apropriado:** Para evitar efeitos colaterais indesejados, considere o uso de objetos imutáveis.

---

## ❌ Práticas a Evitar

- **Supor que a Referência Pode Ser Alterada Dentro do Método:** Lembre-se de que alterar a referência dentro do método não afeta a referência original.
- **Modificar Objetos Sem Necessidade:** Evite modificar o estado de objetos passados como parâmetros se isso não for necessário, para manter a previsibilidade do código.
- **Falta de Clareza no Comportamento do Método:** Métodos que modificam objetos passados como parâmetros devem deixar isso claro em sua documentação e nome.

---

## 📌 Dica Extra

Para evitar modificações indesejadas em objetos passados como parâmetros, considere criar cópias dos objetos dentro do método:

```java
public class Pessoa {
    String nome;

    public Pessoa(String nome) {
        this.nome = nome;
    }

    public Pessoa(Pessoa outra) {
        this.nome = outra.nome;
    }
}

public class Exemplo {
    public static void alterarNome(Pessoa p) {
        Pessoa copia = new Pessoa(p);
        copia.nome = "João";
        // Modificações em 'copia' não afetam o objeto original
    }
}
```

*Explicação:* Criar uma cópia do objeto dentro do método permite que modificações sejam feitas sem afetar o objeto original.

---

## ✅ Conclusão

Entender como os parâmetros de tipos referência são passados e manipulados em métodos é fundamental para evitar comportamentos inesperados e escrever código Java eficiente e claro.



[Voltar ao Índice](#indice)

---


## <a name="parte51">51 - 050 - Orientação Objetos - Métodos pt 07 - Parâmetros tipo referência pt 02</a>

# Aula 50 – Orientação a Objetos: Métodos pt 07 - Parâmetros Tipo Referência pt 02

🎥 **Vídeo:** [Métodos pt 07 - Parâmetros tipo referência pt 02](https://www.youtube.com/watch?v=OMuzOoHAEpg)

## 🎯 Objetivo da Aula

Aprofundar o entendimento sobre a passagem de parâmetros de tipo referência em métodos Java, destacando como alterações nos objetos passados como parâmetros afetam o estado desses objetos fora do método.

---

## 🧠 Conceitos Fundamentais

- **Passagem por Valor de Referência:** Em Java, os parâmetros são passados por valor. No caso de objetos, o valor passado é a referência ao objeto, permitindo que métodos modifiquem o estado interno do objeto, mas não a referência em si.
- **Imutabilidade da Referência:** Alterar a referência dentro do método não afeta a referência original fora dele.
- **Mutabilidade do Objeto:** Alterações no estado do objeto dentro do método são refletidas fora dele, pois ambos os métodos compartilham a mesma referência.

---

## 💡 Exemplo Básico - Modificando o Estado do Objeto

```java
public class Carro {
    String modelo;
}

public class Exemplo {
    public static void alterarModelo(Carro carro) {
        carro.modelo = "Fusca";
    }

    public static void main(String[] args) {
        Carro meuCarro = new Carro();
        meuCarro.modelo = "Civic";
        alterarModelo(meuCarro);
        System.out.println(meuCarro.modelo); // Saída: Fusca
    }
}
```

*Explicação:* O método `alterarModelo` modifica o atributo `modelo` do objeto `Carro`. Como a referência ao objeto é passada por valor, o método pode alterar o estado interno do objeto.

---

## 💡 Exemplo Intermediário - Tentando Alterar a Referência

```java
public class Carro {
    String modelo;
}

public class Exemplo {
    public static void criarNovoCarro(Carro carro) {
        carro = new Carro();
        carro.modelo = "Gol";
    }

    public static void main(String[] args) {
        Carro meuCarro = new Carro();
        meuCarro.modelo = "Civic";
        criarNovoCarro(meuCarro);
        System.out.println(meuCarro.modelo); // Saída: Civic
    }
}
```

*Explicação:* O método `criarNovoCarro` atribui uma nova instância à variável `carro`, mas essa alteração não afeta a variável `meuCarro` no método `main`, pois a referência é passada por valor.

---

## 💡 Exemplo Avançado - Modificando Objetos em Coleções

```java
import java.util.ArrayList;
import java.util.List;

public class Exemplo {
    public static void adicionarElemento(List<String> lista) {
        lista.add("Novo Elemento");
    }

    public static void main(String[] args) {
        List<String> minhaLista = new ArrayList<>();
        minhaLista.add("Elemento 1");
        adicionarElemento(minhaLista);
        System.out.println(minhaLista); // Saída: [Elemento 1, Novo Elemento]
    }
}
```

*Explicação:* O método `adicionarElemento` modifica o conteúdo da lista, e essa modificação é refletida fora do método, pois a lista é um objeto e sua referência é passada por valor.

---

## ✅ Boas Práticas

- **Compreensão Clara da Passagem por Valor de Referência:** Entenda que, embora a referência seja passada por valor, o objeto referenciado pode ser modificado dentro do método.
- **Evite Alterar a Referência Dentro do Método:** Alterar a referência dentro do método não afeta a referência original e pode causar confusão.
- **Documente o Comportamento dos Métodos:** Especifique claramente se o método modifica ou não o estado dos objetos passados como parâmetros.
- **Utilize Objetos Imutáveis Quando Apropriado:** Para evitar efeitos colaterais indesejados, considere o uso de objetos imutáveis.

---

## ❌ Práticas a Evitar

- **Supor que a Referência Pode Ser Alterada Dentro do Método:** Lembre-se de que alterar a referência dentro do método não afeta a referência original.
- **Modificar Objetos Sem Necessidade:** Evite modificar o estado de objetos passados como parâmetros se isso não for necessário, para manter a previsibilidade do código.
- **Falta de Clareza no Comportamento do Método:** Métodos que modificam objetos passados como parâmetros devem deixar isso claro em sua documentação e nome.

---

## 📌 Dica Extra

Para evitar modificações indesejadas em objetos passados como parâmetros, considere criar cópias dos objetos dentro do método:

```java
public class Carro {
    String modelo;

    public Carro(String modelo) {
        this.modelo = modelo;
    }

    public Carro(Carro outro) {
        this.modelo = outro.modelo;
    }
}

public class Exemplo {
    public static void alterarModelo(Carro carro) {
        Carro copia = new Carro(carro);
        copia.modelo = "Fusca";
        // Modificações em 'copia' não afetam o objeto original
    }
}
```

*Explicação:* Criar uma cópia do objeto dentro do método permite que modificações sejam feitas sem afetar o objeto original.

---

## ✅ Conclusão

Entender como os parâmetros de tipos referência são passados e manipulados em métodos é fundamental para evitar comportamentos inesperados e escrever código Java eficiente e claro.



[Voltar ao Índice](#indice)

---


## <a name="parte52">52 - 051 - Orientação Objetos - Métodos pt 08 - Referência this</a>

# Aula 51 – Orientação a Objetos: Métodos pt 08 - Referência `this`

📺 **Vídeo:** [Referência this](https://www.youtube.com/watch?v=0fVZlarZ-Lg&list=PL62G310vn6nFIsOCC0H-C2infYgwm8SWW&index=53)

## 🎯 Objetivo

Entender como funciona a palavra-chave `this` em Java, utilizada para referenciar o próprio objeto dentro de métodos e construtores. A aula mostra como usar `this` para resolver ambiguidades, chamar construtores sobrecarregados e aplicar em métodos encadeados (method chaining).

---

## 🔹 O que é `this`?

A palavra-chave `this` é uma referência ao objeto atual da classe. Ela é usada para:

- Diferenciar variáveis de instância de parâmetros com o mesmo nome.
- Chamar outro construtor dentro da mesma classe (`this(...)`).
- Retornar o próprio objeto, permitindo encadeamento de métodos.

---

## 💡 Exemplo Básico – Resolvendo Ambiguidade

```java
public class Produto {
    String nome;

    public void setNome(String nome) {
        this.nome = nome; // "this.nome" se refere à variável de instância
    }

    public void imprimir() {
        System.out.println(this.nome);
    }
}
```

### Explicação:
Sem `this`, o Java entende que `nome = nome` se refere ao parâmetro da função, causando erro lógico. Com `this.nome`, deixamos claro que estamos acessando o atributo do objeto.

---

## 💡 Exemplo Intermediário – Chamando outro Construtor

```java
public class Pessoa {
    String nome;
    int idade;

    public Pessoa(String nome) {
        this(nome, 0); // chama o outro construtor com idade 0
    }

    public Pessoa(String nome, int idade) {
        this.nome = nome;
        this.idade = idade;
    }
}
```

### Explicação:
Utilizando `this(...)`, chamamos outro construtor da mesma classe, evitando repetição de código e garantindo consistência de inicialização.

---

## 💡 Exemplo Avançado – Method Chaining (Encadeamento de Métodos)

```java
public class Carro {
    String modelo;
    int ano;

    public Carro setModelo(String modelo) {
        this.modelo = modelo;
        return this;
    }

    public Carro setAno(int ano) {
        this.ano = ano;
        return this;
    }

    public void mostrar() {
        System.out.println("Modelo: " + this.modelo + ", Ano: " + this.ano);
    }
}
```

### Uso:
```java
Carro carro = new Carro();
carro.setModelo("Fusca").setAno(1975).mostrar();
```

### Explicação:
Ao retornar `this`, é possível encadear chamadas de métodos em uma única linha de código, o que melhora a legibilidade em alguns contextos.

---

## ✅ Boas Práticas

- Utilize `this` para deixar o código claro quando há ambiguidade entre parâmetros e atributos.
- Prefira `this(...)` para reusar lógica de construtores.
- Encadeie métodos (`method chaining`) quando isso deixar o código mais legível.
- Use `this` em contextos onde você deseja destacar explicitamente que está lidando com atributos do objeto.

---

## ❌ Piores Práticas

- ❌ Usar `this` em métodos `static` (isso gera erro, pois não há objeto associado).
- ❌ Criar parâmetros com os mesmos nomes dos atributos e esquecer de usar `this`, o que causa erros de lógica.
- ❌ Usar encadeamento de métodos em excesso, o que pode dificultar a leitura se os métodos forem muitos ou complexos.
- ❌ Criar muitos construtores com lógica duplicada ao invés de usar `this(...)`.

---

## 📌 Dica Extra

`this` também pode ser passado como argumento para outros métodos ou classes, representando o próprio objeto atual. Exemplo:

```java
public class Teste {
    public void mostrar() {
        util(this); // passa o objeto atual
    }

    public void util(Teste obj) {
        System.out.println("Objeto recebido!");
    }
}
```

---

## 🧠 Conclusão

A referência `this` é essencial para escrever código orientado a objetos limpo e bem estruturado em Java. Ela evita ambiguidades, melhora a clareza e permite padrões como method chaining e reutilização de construtores.



[Voltar ao Índice](#indice)

---


## <a name="parte53">53 - 052 - Orientação Objetos - Métodos pt 09 - Varargs</a>

# Aula 52 – Orientação a Objetos: Métodos pt 09 - Varargs

🎥 **Vídeo:** [Métodos pt 09 - Varargs](https://www.youtube.com/watch?v=T0E4Ewwz1IY&list=PL62G310vn6nFIsOCC0H-C2infYgwm8SWW&index=53)

## 🎯 Objetivo da Aula

Compreender o uso de **Varargs** (argumentos de comprimento variável) em Java, que permitem a criação de métodos capazes de receber um número variável de argumentos, proporcionando maior flexibilidade e legibilidade ao código.

---

## 🧠 Conceitos Fundamentais

- **Varargs** (introduced in Java 5) permitem que métodos aceitem um número variável de argumentos do mesmo tipo, utilizando a sintaxe `tipo... nomeParametro`.
- Internamente, o compilador Java trata os varargs como arrays, permitindo iteração e manipulação como em arrays comuns.
- Um método pode ter **apenas um parâmetro varargs**, e este deve ser o **último** na lista de parâmetros.

---

## 💡 Exemplo Básico – Método com Varargs

```java
public class ExemploVarargs {
    public static void imprimirNomes(String... nomes) {
        for (String nome : nomes) {
            System.out.println(nome);
        }
    }

    public static void main(String[] args) {
        imprimirNomes("Ana", "Bruno", "Carlos");
    }
}
```

### Explicação:
O método `imprimirNomes` pode receber qualquer número de argumentos do tipo `String`. No exemplo, são passados três nomes, mas poderia ser nenhum ou muitos mais.

---

## 💡 Exemplo Intermediário – Varargs com Outros Parâmetros

```java
public class ExemploVarargs {
    public static void exibirInformacoes(String titulo, int... numeros) {
        System.out.println("Título: " + titulo);
        for (int numero : numeros) {
            System.out.println("Número: " + numero);
        }
    }

    public static void main(String[] args) {
        exibirInformacoes("Números Importantes", 10, 20, 30);
    }
}
```

### Explicação:
O método `exibirInformacoes` possui um parâmetro fixo (`titulo`) e um varargs (`numeros`). O varargs deve ser sempre o último parâmetro na assinatura do método.

---

## 💡 Exemplo Avançado – Uso de Varargs com Tipos Genéricos

```java
public class ExemploVarargs {
    @SafeVarargs
    public static <T> void imprimirElementos(T... elementos) {
        for (T elemento : elementos) {
            System.out.println(elemento);
        }
    }

    public static void main(String[] args) {
        imprimirElementos(1, 2, 3);
        imprimirElementos("A", "B", "C");
    }
}
```

### Explicação:
Utilizando varargs com tipos genéricos, é possível criar métodos mais flexíveis. A anotação `@SafeVarargs` é usada para suprimir avisos de segurança relacionados ao uso de varargs com generics.

---

## ✅ Boas Práticas

- **Colocar o parâmetro varargs como o último na lista de parâmetros** para evitar ambiguidades na chamada do método.
- **Usar varargs quando o número de argumentos pode variar**, proporcionando maior flexibilidade e legibilidade.
- **Adicionar a anotação `@SafeVarargs`** em métodos estáticos ou finais que utilizam varargs com tipos genéricos para evitar avisos de segurança.
- **Documentar claramente o comportamento do método** ao utilizar varargs, especialmente se o método aceitar zero argumentos.

---

## ❌ Práticas a Evitar

- ❌ **Ter mais de um parâmetro varargs** em um único método, o que não é permitido e causará erro de compilação.
- ❌ **Colocar o parâmetro varargs antes de outros parâmetros**, o que pode levar a ambiguidades na chamada do método.
- ❌ **Usar varargs em métodos de desempenho crítico**, pois cada chamada cria um novo array, o que pode impactar a performance.
- ❌ **Passar arrays diretamente para métodos varargs** sem considerar que o array será tratado como um único argumento, o que pode não ser o comportamento desejado.

---

## 📌 Dica Extra

Embora varargs sejam convenientes, em cenários onde o número de argumentos é grande ou indeterminado, considerar o uso de coleções como `List` pode ser mais apropriado, proporcionando maior controle e funcionalidade.

---

## ✅ Conclusão

O uso de varargs em Java permite a criação de métodos mais flexíveis e legíveis, capazes de lidar com um número variável de argumentos. Compreender suas regras e melhores práticas é essencial para evitar erros e garantir a eficiência do código.



[Voltar ao Índice](#indice)

---


## <a name="parte54">54 - 053 - Orientação Objetos - Métodos pt 10 - Exercise</a>

# Aula 53 – Orientação a Objetos: Métodos pt 10 - Exercise

🎥 **Vídeo:** [Métodos pt 10 - Exercise](https://www.youtube.com/watch?v=F2Y867f1J8U&list=PL62G310vn6nFIsOCC0H-C2infYgwm8SWW&index=54)

## 🎯 Objetivo da Aula

Fixar o conceito de **métodos** em Java através de exercícios práticos de criação de classes, definição de métodos, passagem de parâmetros e retorno de valores.

---

## 🧠 Conceitos Abordados

- Criação de métodos que recebem parâmetros.
- Métodos que retornam valores.
- Uso correto do `return`.
- Prática de boas práticas de escrita de métodos.
- Trabalho com encapsulamento e organização do código.

---

## 💡 Exemplo Básico – Exercício de Soma

```java
public class Calculadora {
    public int somar(int a, int b) {
        return a + b;
    }
}

public class TesteCalculadora {
    public static void main(String[] args) {
        Calculadora calc = new Calculadora();
        int resultado = calc.somar(5, 3);
        System.out.println("Resultado: " + resultado);
    }
}
```

### Explicação:
O método `somar` recebe dois inteiros como parâmetros e retorna a soma deles.

---

## 💡 Exemplo Intermediário – Exercício com Verificação

```java
public class Calculadora {
    public boolean ehPar(int numero) {
        return numero % 2 == 0;
    }
}

public class TesteCalculadora {
    public static void main(String[] args) {
        Calculadora calc = new Calculadora();
        boolean resultado = calc.ehPar(10);
        System.out.println("É par? " + resultado);
    }
}
```

### Explicação:
O método `ehPar` verifica se um número é par e retorna um valor booleano (`true` ou `false`).

---

## 💡 Exemplo Avançado – Classe com Múltiplos Métodos

```java
public class CalculadoraAvancada {
    public int somar(int a, int b) {
        return a + b;
    }

    public int subtrair(int a, int b) {
        return a - b;
    }

    public int multiplicar(int a, int b) {
        return a * b;
    }

    public double dividir(int a, int b) {
        if (b == 0) {
            throw new IllegalArgumentException("Divisor não pode ser zero.");
        }
        return (double) a / b;
    }
}

public class TesteCalculadoraAvancada {
    public static void main(String[] args) {
        CalculadoraAvancada calc = new CalculadoraAvancada();
        System.out.println("Soma: " + calc.somar(10, 5));
        System.out.println("Subtração: " + calc.subtrair(10, 5));
        System.out.println("Multiplicação: " + calc.multiplicar(10, 5));
        System.out.println("Divisão: " + calc.dividir(10, 5));
    }
}
```

### Explicação:
Aqui temos vários métodos operando de formas diferentes dentro da mesma classe, cada um com sua responsabilidade bem definida.

---

## ✅ Boas Práticas

- **Nomear métodos de forma clara e descritiva**, como `somar`, `subtrair`, `ehPar`.
- **Cada método deve ter uma única responsabilidade**, seguindo o princípio da responsabilidade única.
- **Validar dados de entrada** (ex: divisão por zero) para evitar erros de execução.
- **Separar lógica de cálculo e exibição de dados**, ou seja, deixar o método apenas calcular e não imprimir.
- **Adicionar comentários em métodos mais complexos** para facilitar a manutenção.

---

## ❌ Práticas a Evitar

- ❌ **Métodos fazendo múltiplas tarefas**, como calcular e imprimir ao mesmo tempo.
- ❌ **Nomes de métodos genéricos ou confusos**, como `doStuff` ou `process`.
- ❌ **Ignorar validações básicas**, como não tratar divisões por zero.
- ❌ **Métodos muito longos**, que dificultam a leitura e manutenção do código.
- ❌ **Excesso de responsabilidade**: métodos que fazem diversas operações diferentes.

---

## 📌 Dica Extra

Ao praticar a criação de métodos:
- **Teste seu método** em diferentes cenários para garantir que funciona corretamente.
- **Pense na manutenção**: alguém (ou até você mesmo) terá que entender esse código no futuro.
- **Priorize legibilidade** sobre "economia" de linhas.

---

## ✅ Conclusão

A prática com exercícios de métodos é fundamental para entender não apenas como criar funções, mas também como estruturar melhor o código, tornando-o mais reutilizável, testável e limpo. Métodos bem escritos são a base de sistemas robustos e de fácil manutenção.



[Voltar ao Índice](#indice)

---


## <a name="parte55">55 - 054 - Orientação Objetos - Modificador de acesso private, get e set pt 01</a>

# Aula 54 – Orientação a Objetos: Modificador de acesso private, get e set pt 01

🎥 **Vídeo:** [Modificador de acesso private, get e set pt 01](https://www.youtube.com/watch?v=QDzjgS0r39c&list=PL62G310vn6nFIsOCC0H-C2infYgwm8SWW&index=55)

## 🎯 Objetivo da Aula

Introduzir o conceito de **modificadores de acesso** em Java, focando no uso do `private` para proteger atributos e no uso dos métodos **getters** e **setters** para acessar ou modificar esses atributos de forma controlada.

---

## 🧠 Conceitos Abordados

- **Modificador `private`**: torna o atributo ou método acessível apenas dentro da própria classe.
- **Getter** (`get`): método público para acessar o valor de um atributo privado.
- **Setter** (`set`): método público para modificar o valor de um atributo privado.
- **Encapsulamento**: proteger o acesso direto aos dados da classe, mantendo o controle sobre eles.

---

## 💡 Exemplo Básico – Definindo Atributos Privados

```java
public class Pessoa {
    private String nome;
    private int idade;

    public String getNome() {
        return nome;
    }

    public void setNome(String nome) {
        this.nome = nome;
    }

    public int getIdade() {
        return idade;
    }

    public void setIdade(int idade) {
        if (idade >= 0) {
            this.idade = idade;
        }
    }
}

public class TestePessoa {
    public static void main(String[] args) {
        Pessoa pessoa = new Pessoa();
        pessoa.setNome("Maria");
        pessoa.setIdade(30);

        System.out.println("Nome: " + pessoa.getNome());
        System.out.println("Idade: " + pessoa.getIdade());
    }
}
```

### Explicação:
- Atributos `nome` e `idade` são `private`.
- Métodos `getNome` e `setNome`, `getIdade` e `setIdade` permitem acesso controlado a esses atributos.
- No `setIdade`, existe uma **validação** para garantir que não se atribua uma idade negativa.

---

## 💡 Exemplo Complexo – Validação mais sofisticada

```java
public class ContaBancaria {
    private double saldo;

    public double getSaldo() {
        return saldo;
    }

    public void depositar(double valor) {
        if (valor > 0) {
            saldo += valor;
        } else {
            System.out.println("Valor de depósito inválido!");
        }
    }

    public void sacar(double valor) {
        if (valor > 0 && valor <= saldo) {
            saldo -= valor;
        } else {
            System.out.println("Saque inválido!");
        }
    }
}

public class TesteConta {
    public static void main(String[] args) {
        ContaBancaria conta = new ContaBancaria();
        conta.depositar(500);
        conta.sacar(200);
        System.out.println("Saldo atual: R$ " + conta.getSaldo());
    }
}
```

### Explicação:
- `saldo` é protegido.
- Métodos públicos controlam a alteração do saldo (depositar e sacar) com **regras de negócio**.

---

## ✅ Boas Práticas

- ✅ Sempre use `private` para atributos, aplicando **encapsulamento**.
- ✅ Crie **getters e setters** claros e objetivos para atributos que precisam ser acessados de fora da classe.
- ✅ No **setter**, faça validações sempre que possível para proteger os dados da classe.
- ✅ Nomeie getters e setters seguindo o padrão: `getNomeAtributo()` e `setNomeAtributo()`.
- ✅ Use métodos que garantam a consistência dos dados internos da classe.

---

## ❌ Práticas a Evitar

- ❌ Deixar atributos `public`, quebrando o encapsulamento.
- ❌ Criar getters e setters sem necessidade real para atributos que não precisam ser expostos.
- ❌ Não validar entradas nos setters, permitindo estados inválidos.
- ❌ Fazer lógica complexa demais dentro de um getter ou setter — eles devem ser simples.

---

## 📌 Dica Extra

- Se você quiser criar getters e setters rapidamente no Eclipse ou IntelliJ, pode usar **atalhos automáticos** como `Generate Getter and Setter`.
- Em projetos maiores, usar frameworks como **Lombok** pode ajudar a reduzir a verbosidade do código com anotações como `@Getter` e `@Setter`.

---

## ✅ Conclusão

Entender e aplicar corretamente os modificadores de acesso, além de criar getters e setters apropriados, é um passo fundamental para escrever códigos seguros, organizados e fáceis de manter em Java.


[Voltar ao Índice](#indice)

---


## <a name="parte56">56 - 055 - Orientação Objetos - Modificador de acesso private, get e set pt 02</a>

# Aula 55 – Orientação a Objetos: Modificador de acesso private, get e set pt 02

🎥 **Vídeo:** [Modificador de acesso private, get e set pt 02](https://www.youtube.com/watch?v=hJNlMh9ktQ4&list=PL62G310vn6nFIsOCC0H-C2infYgwm8SWW&index=56)

## 🎯 Objetivo da Aula

Aprofundar o conceito de **encapsulamento** usando `private`, `getters` e `setters` em Java, demonstrando como aplicar essas práticas em uma estrutura de classes mais realista e com exemplos de controle de acesso e validações internas.

---

## 🧠 Conceitos Abordados

- **Refinamento de encapsulamento**: Proteção total dos atributos sensíveis da classe.
- **Controle de entrada de dados**: Uso de validações nos setters.
- **Visibilidade seletiva**: Algumas informações podem ser apenas lidas (getter sem setter).
- **Design de API de classe**: Pensar quais atributos devem ser expostos e como.

---

## 💡 Exemplo Básico – Atributos com Getter e Setter

```java
public class Produto {
    private String nome;
    private double preco;

    public String getNome() {
        return nome;
    }

    public void setNome(String nome) {
        if (nome != null && !nome.isEmpty()) {
            this.nome = nome;
        }
    }

    public double getPreco() {
        return preco;
    }

    public void setPreco(double preco) {
        if (preco > 0) {
            this.preco = preco;
        }
    }
}

public class TesteProduto {
    public static void main(String[] args) {
        Produto produto = new Produto();
        produto.setNome("Notebook");
        produto.setPreco(3000);

        System.out.println("Produto: " + produto.getNome());
        System.out.println("Preço: R$" + produto.getPreco());
    }
}
```

### Explicação:
- O atributo `nome` só é alterado se não for nulo ou vazio.
- O atributo `preco` só aceita valores positivos.

---

## 💡 Exemplo Complexo – Encapsulamento Avançado

```java
public class Aluno {
    private String nome;
    private double[] notas;

    public Aluno(String nome, int quantidadeProvas) {
        this.nome = nome;
        this.notas = new double[quantidadeProvas];
    }

    public String getNome() {
        return nome;
    }

    public void setNota(int indice, double nota) {
        if (indice >= 0 && indice < notas.length && nota >= 0 && nota <= 10) {
            notas[indice] = nota;
        } else {
            System.out.println("Nota inválida ou índice inválido!");
        }
    }

    public double calcularMedia() {
        double total = 0;
        for (double nota : notas) {
            total += nota;
        }
        return total / notas.length;
    }
}

public class TesteAluno {
    public static void main(String[] args) {
        Aluno aluno = new Aluno("Carlos", 3);
        aluno.setNota(0, 8.5);
        aluno.setNota(1, 7.0);
        aluno.setNota(2, 9.0);

        System.out.println("Média de " + aluno.getNome() + ": " + aluno.calcularMedia());
    }
}
```

### Explicação:
- O acesso direto ao array de notas é proibido.
- As notas são controladas por métodos seguros que garantem valores válidos.

---

## ✅ Boas Práticas

- ✅ Sempre encapsule atributos com `private`.
- ✅ Crie **getters** e **setters** apenas quando realmente necessários.
- ✅ Adicione **validação** nos setters para garantir integridade dos dados.
- ✅ Pense nas operações que a classe deve oferecer e crie métodos que façam sentido para a regra de negócio.
- ✅ Proteja a lógica interna da classe contra estados inválidos.

---

## ❌ Práticas a Evitar

- ❌ Expor atributos diretamente com `public`.
- ❌ Permitir que atributos sejam modificados sem qualquer validação.
- ❌ Gerar métodos `get` e `set` automáticos para todos os atributos sem necessidade (não usar getters/setters indiscriminadamente).
- ❌ Deixar a lógica de validação espalhada fora da classe.

---

## 📌 Dica Extra

- Getter e Setter não precisam ser obrigatoriamente criados para todos os atributos.
- Pense bem sobre a **responsabilidade da classe** e o que realmente precisa ser acessado ou modificado de fora.
- Getter ou Setter podem ser omitidos para reforçar o **princípio da imutabilidade** em certos casos.

---

## ✅ Conclusão

Usar `private`, `getters` e `setters` da maneira correta promove segurança, organização e robustez no seu código. Além disso, permite que as classes sejam usadas de maneira previsível e consistente.


[Voltar ao Índice](#indice)

---


## <a name="parte57">57 - 056 - Orientação Objetos - Modificador de acesso private, get e set pt 03</a>

# Aula 56 – Orientação a Objetos: Modificador de acesso private, get e set pt 03

🎥 **Vídeo:** [Modificador de acesso private, get e set pt 03](https://www.youtube.com/watch?v=kuvg8JixRp4&list=PL62G310vn6nFIsOCC0H-C2infYgwm8SWW&index=57)

## 🎯 Objetivo da Aula

Finalizar o estudo sobre o uso do modificador de acesso `private`, `getters` e `setters`, reforçando a importância do **encapsulamento** para proteger os dados e criar APIs de classes mais controladas e seguras.

---

## 🧠 Conceitos Abordados

- **Encapsulamento completo**: restringir o acesso direto aos atributos da classe.
- **Proteção contra estados inválidos**: validando alterações dos atributos.
- **Getters e Setters customizados**: adaptando comportamento de leitura ou escrita dos dados.
- **Implementação de regras de negócio simples nos métodos de acesso**.

---

## 💡 Exemplo Básico – Validação no Setter

```java
public class ContaBancaria {
    private double saldo;

    public double getSaldo() {
        return saldo;
    }

    public void depositar(double valor) {
        if (valor > 0) {
            saldo += valor;
        }
    }

    public void sacar(double valor) {
        if (valor > 0 && saldo >= valor) {
            saldo -= valor;
        } else {
            System.out.println("Saque inválido!");
        }
    }
}

public class TesteConta {
    public static void main(String[] args) {
        ContaBancaria conta = new ContaBancaria();
        conta.depositar(1000);
        conta.sacar(500);

        System.out.println("Saldo atual: R$" + conta.getSaldo());
    }
}
```

### Explicação:
- O método `depositar` só permite valores positivos.
- O método `sacar` verifica se há saldo suficiente antes de sacar.
- O saldo nunca é alterado diretamente, protegendo a integridade da conta.

---

## 💡 Exemplo Complexo – Setter Inteligente com Ajustes

```java
public class Produto {
    private String nome;
    private double preco;
    private double desconto; // Desconto em percentual

    public Produto(String nome, double preco) {
        this.nome = nome;
        setPreco(preco); // Aplica validação inicial
    }

    public String getNome() {
        return nome;
    }

    public double getPreco() {
        return preco - (preco * desconto / 100);
    }

    public void setPreco(double preco) {
        if (preco > 0) {
            this.preco = preco;
        }
    }

    public void aplicarDesconto(double desconto) {
        if (desconto >= 0 && desconto <= 50) {
            this.desconto = desconto;
        } else {
            System.out.println("Desconto inválido! Máximo permitido: 50%");
        }
    }
}

public class TesteProduto {
    public static void main(String[] args) {
        Produto produto = new Produto("Smartphone", 2000);
        produto.aplicarDesconto(10);

        System.out.println("Preço com desconto: R$" + produto.getPreco());
    }
}
```

### Explicação:
- O preço retornado já considera o desconto aplicado.
- A validação impede descontos abusivos (> 50%).

---

## ✅ Boas Práticas

- ✅ Sempre proteger atributos sensíveis com `private`.
- ✅ Validar corretamente as alterações dos atributos usando setters.
- ✅ Utilizar getters para retornar informações tratadas, se necessário.
- ✅ Deixar a responsabilidade da integridade dos dados para dentro da classe.
- ✅ Pensar nas **regras de negócio** enquanto desenha os métodos de acesso.

---

## ❌ Práticas a Evitar

- ❌ Deixar atributos públicos (`public`) sem necessidade.
- ❌ Aceitar valores inválidos sem validação nos setters (ex: preço negativo, desconto acima do permitido).
- ❌ Escrever getters e setters desnecessariamente sem propósito claro.
- ❌ Permitir que objetos externos alterem o estado da classe diretamente.

---

## 📌 Dica Extra

- Setter não precisa ser obrigatório! Em casos onde o atributo é **imutável**, forneça apenas o getter.
- Getters podem realizar cálculos simples ou ajustes antes de devolver o valor, tornando o acesso mais seguro e controlado.

---

## ✅ Conclusão

Usar `private`, `getters` e `setters` de maneira adequada é essencial para proteger os dados internos das classes e para construir programas robustos, seguros e fáceis de manter.


[Voltar ao Índice](#indice)

---


## <a name="parte58">58 - 057 - Orientação Objetos - Sobrecarga de métodos</a>

# Aula 57 – Orientação a Objetos: Sobrecarga de métodos

🎥 **Vídeo:** [Sobrecarga de métodos](https://www.youtube.com/watch?v=UNPh61FYFrA&list=PL62G310vn6nFIsOCC0H-C2infYgwm8SWW&index=58)

## 🎯 Objetivo da Aula

Explicar o conceito de **Sobrecarga de Métodos** (*Method Overloading*) em Java, mostrando como criar vários métodos com o mesmo nome mas com **parâmetros diferentes**.

---

## 🧠 Conceitos Abordados

- **Sobrecarga de métodos** é quando dois ou mais métodos na mesma classe têm o **mesmo nome**, mas **assinaturas diferentes** (quantidade ou tipo de parâmetros diferente).
- Não é permitido diferenciar métodos apenas pelo **tipo de retorno**.
- Sobrecarga melhora a legibilidade e facilita o uso da classe, oferecendo múltiplas formas de executar uma operação.

---

## 💡 Exemplo Básico – Sobrecarga simples

```java
public class Calculadora {

    // Método que soma dois inteiros
    int somar(int a, int b) {
        return a + b;
    }

    // Método que soma três inteiros
    int somar(int a, int b, int c) {
        return a + b + c;
    }

    // Método que soma dois números double
    double somar(double a, double b) {
        return a + b;
    }
}

public class TesteCalculadora {
    public static void main(String[] args) {
        Calculadora calc = new Calculadora();
        
        System.out.println(calc.somar(2, 3));         // Chama somar(int, int)
        System.out.println(calc.somar(2, 3, 4));      // Chama somar(int, int, int)
        System.out.println(calc.somar(2.5, 3.5));     // Chama somar(double, double)
    }
}
```

---

## 💡 Exemplo Complexo – Sobrecarga aplicando tipos variados

```java
public class Impressora {

    void imprimir(String texto) {
        System.out.println("Texto: " + texto);
    }

    void imprimir(int numero) {
        System.out.println("Número inteiro: " + numero);
    }

    void imprimir(double numero) {
        System.out.println("Número decimal: " + numero);
    }

    void imprimir(boolean valor) {
        System.out.println("Valor booleano: " + valor);
    }
}

public class TesteImpressora {
    public static void main(String[] args) {
        Impressora impressora = new Impressora();
        
        impressora.imprimir("Olá Mundo!");
        impressora.imprimir(100);
        impressora.imprimir(45.67);
        impressora.imprimir(true);
    }
}
```

---

## ✅ Boas Práticas

- ✅ Criar sobrecargas quando realmente faz sentido semântico: o método representa a **mesma ação**, só que para dados diferentes.
- ✅ Manter **nomes claros** e seguir o padrão de **mesmo nome** para reforçar a ideia de operação semelhante.
- ✅ Manter a **consistência** no comportamento esperado dos métodos sobrecarregados.
- ✅ Documentar diferenças importantes entre versões do método, caso necessário.

---

## ❌ Práticas a Evitar

- ❌ Criar sobrecarga apenas para "encher código" sem necessidade real.
- ❌ Diferenciar métodos apenas pelo **tipo de retorno** — isso não é permitido em Java e causará erro de compilação.
- ❌ Tornar métodos sobrecarregados muito diferentes entre si no comportamento — isso confunde o usuário da classe.
- ❌ Criar muitas versões desnecessárias, poluindo a classe e dificultando a manutenção.

---

## 📌 Dica Extra

- A sobrecarga é especialmente útil quando queremos **oferecer flexibilidade** sem obrigar o usuário da classe a fornecer sempre todos os parâmetros.
- Métodos sobrecarregados podem também **chamar uns aos outros** para evitar repetição de código.

```java
void imprimir() {
    imprimir("Sem conteúdo!");
}
```

---

## ✅ Conclusão

Sobrecarga de métodos é uma ferramenta poderosa da programação orientada a objetos em Java, ajudando a criar APIs mais intuitivas e fáceis de usar. Quando usada com responsabilidade, melhora muito a **legibilidade**, a **manutenção** e a **eficiência** do código.


[Voltar ao Índice](#indice)

---


## <a name="parte59">59 - 058 - Orientação Objetos - Construtores pt 01</a>

# Aula 58 – Orientação a Objetos: Construtores pt 01

🎥 **Vídeo:** [Construtores pt 01](https://www.youtube.com/watch?v=zErSZzgYY_g&list=PL62G310vn6nFIsOCC0H-C2infYgwm8SWW&index=59)

## 🎯 Objetivo da Aula

Explicar o conceito e a utilização de **Construtores** em Java — métodos especiais utilizados para inicializar objetos.

---

## 🧠 Conceitos Abordados

- **Construtor** é um método especial chamado automaticamente quando criamos um objeto.
- Ele possui o **mesmo nome** da classe e **não tem tipo de retorno** (nem `void`).
- Usamos construtores para definir valores iniciais dos atributos de um objeto.
- Se nenhum construtor for definido, o Java fornece um **construtor padrão** (sem parâmetros).

---

## 💡 Exemplo Básico – Construtor sem parâmetros

```java
public class Carro {
    String modelo;
    int ano;

    // Construtor padrão
    Carro() {
        modelo = "Modelo não definido";
        ano = 2020;
    }
}

public class TesteCarro {
    public static void main(String[] args) {
        Carro carro1 = new Carro();
        System.out.println(carro1.modelo); // Modelo não definido
        System.out.println(carro1.ano);    // 2020
    }
}
```

---

## 💡 Exemplo Complexo – Construtor com parâmetros

```java
public class Carro {
    String modelo;
    int ano;

    // Construtor com parâmetros
    Carro(String modelo, int ano) {
        this.modelo = modelo;
        this.ano = ano;
    }
}

public class TesteCarro {
    public static void main(String[] args) {
        Carro carro1 = new Carro("Civic", 2022);
        Carro carro2 = new Carro("Corolla", 2023);
        
        System.out.println(carro1.modelo + " - " + carro1.ano); // Civic - 2022
        System.out.println(carro2.modelo + " - " + carro2.ano); // Corolla - 2023
    }
}
```

---

## ✅ Boas Práticas

- ✅ Sempre inicializar os atributos importantes no construtor.
- ✅ Usar **`this`** para deixar claro que você está se referindo ao atributo da instância.
- ✅ Criar construtores que facilitem o uso correto do objeto (evitando objetos com estado inválido).
- ✅ Se possível, fornecer tanto um **construtor padrão** quanto construtores com parâmetros, para dar flexibilidade.
- ✅ Documentar bem os construtores, especialmente quando houver vários.

---

## ❌ Práticas a Evitar

- ❌ Criar muitos construtores sem necessidade, complicando o uso da classe.
- ❌ Inicializar valores incorretos ou inválidos no construtor.
- ❌ Esquecer de usar `this` e acabar confundindo variável local com atributo de classe.
- ❌ Deixar atributos obrigatórios sem inicialização, causando possíveis `NullPointerException` mais tarde.

---

## 📌 Dica Extra

- Você pode criar múltiplos construtores na mesma classe, variando o número ou tipo de parâmetros (**Sobrecarga de Construtores**).
- Sempre pense no **estado mínimo válido** que o objeto precisa ter para funcionar corretamente.

```java
Carro carroDefault = new Carro(); // Sem parâmetros
Carro carroEspecifico = new Carro("Fiesta", 2021); // Com parâmetros
```

---

## ✅ Conclusão

Construtores tornam o processo de criação de objetos mais seguro e organizado, garantindo que os atributos essenciais sejam devidamente inicializados logo no nascimento do objeto.


[Voltar ao Índice](#indice)

---


## <a name="parte60">60 - 059 - Orientação Objetos - Construtores pt 02 - Sobrecarga</a>

# Aula 59 – Orientação a Objetos: Construtores pt 02 - Sobrecarga

🎥 **Vídeo:** [Construtores pt 02 - Sobrecarga](https://www.youtube.com/watch?v=rW11EAkxFnc&list=PL62G310vn6nFIsOCC0H-C2infYgwm8SWW&index=60)

## 🎯 Objetivo da Aula

Apresentar o conceito de **sobrecarga de construtores** em Java: a capacidade de criar múltiplos construtores na mesma classe, variando a quantidade e tipos de parâmetros.

---

## 🧠 Conceitos Abordados

- **Sobrecarga** significa ter **métodos** (ou **construtores**) com o **mesmo nome**, mas **diferentes listas de parâmetros** (tipo, quantidade ou ordem).
- Em Java, é possível ter vários construtores dentro da mesma classe para dar **flexibilidade** na criação dos objetos.
- Cada construtor pode inicializar o objeto de uma maneira diferente, dependendo dos dados fornecidos.

---

## 💡 Exemplo Básico – Sobrecarga de Construtores

```java
public class Carro {
    String modelo;
    int ano;

    // Construtor padrão
    Carro() {
        modelo = "Modelo padrão";
        ano = 2020;
    }

    // Construtor com 1 parâmetro
    Carro(String modelo) {
        this.modelo = modelo;
        this.ano = 2020;
    }

    // Construtor com 2 parâmetros
    Carro(String modelo, int ano) {
        this.modelo = modelo;
        this.ano = ano;
    }
}

public class TesteCarro {
    public static void main(String[] args) {
        Carro carro1 = new Carro();
        Carro carro2 = new Carro("Civic");
        Carro carro3 = new Carro("Corolla", 2023);

        System.out.println(carro1.modelo + " - " + carro1.ano); // Modelo padrão - 2020
        System.out.println(carro2.modelo + " - " + carro2.ano); // Civic - 2020
        System.out.println(carro3.modelo + " - " + carro3.ano); // Corolla - 2023
    }
}
```

---

## 💡 Exemplo Complexo – Usando Sobrecarga + Validação

```java
public class Produto {
    String nome;
    double preco;

    // Construtor padrão
    Produto() {
        this("Produto Genérico", 0.0);
    }

    // Construtor com 1 parâmetro
    Produto(String nome) {
        this(nome, 0.0);
    }

    // Construtor com 2 parâmetros
    Produto(String nome, double preco) {
        this.nome = nome;
        if (preco >= 0) {
            this.preco = preco;
        } else {
            this.preco = 0.0;
        }
    }
}

public class TesteProduto {
    public static void main(String[] args) {
        Produto p1 = new Produto();
        Produto p2 = new Produto("Notebook");
        Produto p3 = new Produto("Celular", 2500.00);

        System.out.println(p1.nome + " - " + p1.preco);
        System.out.println(p2.nome + " - " + p2.preco);
        System.out.println(p3.nome + " - " + p3.preco);
    }
}
```

---

## ✅ Boas Práticas

- ✅ Usar a **chamada de construtores** dentro de outro construtor (`this(...)`) para **reutilizar** código e evitar repetição.
- ✅ Criar construtores sobrecarregados apenas se fizer sentido para diferentes formas de inicializar o objeto.
- ✅ Manter a ordem lógica dos parâmetros para evitar confusão na criação dos objetos.
- ✅ Usar validações dentro do construtor quando necessário (ex: checar valores inválidos).

---

## ❌ Práticas a Evitar

- ❌ Criar muitos construtores sem necessidade real, complicando o entendimento da classe.
- ❌ Não reutilizar código, duplicando a lógica de inicialização entre construtores.
- ❌ Deixar estados inconsistentes por meio de inicializações parciais incorretas.
- ❌ Não documentar a intenção de cada construtor quando houver vários.

---

## 📌 Dica Extra

- É uma prática recomendada criar **um construtor principal** (o mais completo) e fazer os outros construtores chamarem este utilizando `this(...)`.
- Exemplo:

```java
Produto() {
    this("Produto Genérico", 0.0);
}

Produto(String nome) {
    this(nome, 0.0);
}

Produto(String nome, double preco) {
    this.nome = nome;
    this.preco = preco;
}
```

Assim o código fica **organizado, limpo** e **fácil de manter**!

---

## ✅ Conclusão

A **sobrecarga de construtores** torna a classe mais flexível e prática para diferentes cenários de criação de objetos, desde que usada com responsabilidade e organização.


[Voltar ao Índice](#indice)

---


## <a name="parte61">61 - 060 - Orientação Objetos - Blocos de inicialização</a>

# Aula 60 – Orientação a Objetos: Blocos de Inicialização

🎥 **Vídeo:** [Blocos de Inicialização](https://www.youtube.com/watch?v=HGB02nLvgKU&list=PL62G310vn6nFIsOCC0H-C2infYgwm8SWW&index=61)

## 🎯 Objetivo da Aula

Entender o que são **blocos de inicialização** em Java, como eles funcionam, quando são executados e para que servem no ciclo de vida de um objeto.

---

## 🧠 Conceitos Abordados

- **Blocos de inicialização** são usados para **executar código** sempre que uma **instância da classe é criada**.
- Existem dois tipos principais:
  - **Bloco de inicialização de instância** (`{}`): Executado toda vez que um objeto é instanciado.
  - **Bloco de inicialização estático** (`static {}`): Executado apenas **uma vez**, quando a classe é carregada pela primeira vez.

---

## 💡 Exemplo Básico – Bloco de Inicialização de Instância

```java
public class Pessoa {
    String nome;
    int idade;

    {
        System.out.println("Bloco de inicialização chamado!");
        nome = "Nome padrão";
        idade = 18;
    }

    public Pessoa() {
        System.out.println("Construtor chamado!");
    }
}

public class TestePessoa {
    public static void main(String[] args) {
        Pessoa p1 = new Pessoa();
        Pessoa p2 = new Pessoa();
    }
}
```

**Saída:**
```
Bloco de inicialização chamado!
Construtor chamado!
Bloco de inicialização chamado!
Construtor chamado!
```

---

## 💡 Exemplo Complexo – Bloco Estático + Bloco de Instância

```java
public class Carro {
    String modelo;
    static int totalDeCarros;

    static {
        System.out.println("Bloco estático chamado!");
        totalDeCarros = 0;
    }

    {
        System.out.println("Bloco de inicialização chamado!");
        modelo = "Modelo genérico";
        totalDeCarros++;
    }

    public Carro() {
        System.out.println("Construtor chamado!");
    }
}

public class TesteCarro {
    public static void main(String[] args) {
        Carro c1 = new Carro();
        Carro c2 = new Carro();
        System.out.println("Total de carros: " + Carro.totalDeCarros);
    }
}
```

**Saída:**
```
Bloco estático chamado!
Bloco de inicialização chamado!
Construtor chamado!
Bloco de inicialização chamado!
Construtor chamado!
Total de carros: 2
```

---

## ✅ Boas Práticas

- ✅ Use blocos de inicialização para configurar **valores padrão** ou **lógicas comuns** que não dependem dos argumentos do construtor.
- ✅ Em inicialização de variáveis estáticas importantes, utilize o **bloco estático** para garantir consistência.
- ✅ Deixe o código dos blocos **simples e legível** para evitar confusão.

---

## ❌ Práticas a Evitar

- ❌ Colocar **lógica complexa** ou **processamentos pesados** nos blocos de inicialização — isso dificulta a leitura e manutenção.
- ❌ Abusar de blocos de inicialização ao invés de usar **métodos próprios** ou **construtores** para lógicas específicas.
- ❌ Não misturar a responsabilidade de blocos com outras partes da classe (por exemplo, lógica de negócio dentro de bloco de inicialização).

---

## 📌 Dica Extra

- Se puder escolher, **prefira inicializar valores diretamente nos atributos** ou dentro do **construtor**. Use blocos de inicialização apenas para casos onde **múltiplos construtores** precisam de um comportamento comum.

Exemplo:
```java
private String nome = "Nome padrão";
```

ao invés de:

```java
{
    nome = "Nome padrão";
}
```

---

## ✅ Conclusão

Os **blocos de inicialização** são ferramentas poderosas para configurar o estado de objetos e classes, mas devem ser usados com moderação e clareza. Entender o **momento de execução** de cada tipo (estático e de instância) é fundamental para escrever códigos mais organizados e previsíveis.


[Voltar ao Índice](#indice)

---


## <a name="parte62">62 - 061 - Orientação Objetos - Modificador static</a>

# Aula 61 – Orientação a Objetos: Modificador `static`

🎥 **Vídeo:** [Modificador static](https://www.youtube.com/watch?v=WBBbsEdzzmA&list=PL62G310vn6nFIsOCC0H-C2infYgwm8SWW&index=63)

## 🎯 Objetivo da Aula

Entender como o **modificador `static`** funciona em Java, tanto para **atributos** quanto para **métodos**, e a diferença entre membros de instância e membros estáticos.

---

## 🧠 Conceitos Abordados

- **Atributos estáticos** (`static`) pertencem **à classe** e **não** a uma instância (objeto).
- **Métodos estáticos** podem ser chamados **sem criar objetos** da classe.
- Utilizamos o `static` para **compartilhar** valores ou comportamentos comuns a **todas as instâncias**.

---

## 💡 Exemplo Básico – Atributo `static`

```java
public class Carro {
    String modelo;
    static int velocidadeMaxima = 240;
}

public class TesteCarro {
    public static void main(String[] args) {
        System.out.println("Velocidade máxima: " + Carro.velocidadeMaxima);
    }
}
```
> **Observação**: `velocidadeMaxima` pode ser acessado diretamente pelo nome da classe.

---

## 💡 Exemplo Complexo – Método `static`

```java
public class Utilidade {
    public static int soma(int a, int b) {
        return a + b;
    }
}

public class TesteUtilidade {
    public static void main(String[] args) {
        int resultado = Utilidade.soma(10, 20);
        System.out.println("Resultado da soma: " + resultado);
    }
}
```
> **Métodos estáticos** são ideais para funções utilitárias que **não dependem de estado** de instância.

---

## ✅ Boas Práticas

- ✅ Use `static` para **atributos ou métodos que são iguais para todas as instâncias**.
- ✅ Métodos utilitários que **não precisam acessar atributos de instância** devem ser `static`.
- ✅ Nomeie variáveis/métodos estáticos de forma clara para indicar seu **uso compartilhado**.

---

## ❌ Práticas a Evitar

- ❌ Não use `static` indiscriminadamente — **nem tudo** precisa ser compartilhado entre instâncias.
- ❌ Evite acessar atributos de instância dentro de métodos `static` (não é permitido sem passar o objeto como referência).
- ❌ Não misture lógica de negócio com `static` sem necessidade — **separação de responsabilidades** é essencial.

---

## 📌 Dica Extra

Se você usa muito `static` em métodos dentro de uma classe, talvez esteja **violando o princípio da orientação a objetos**. Pode ser um sinal de que esse código deveria estar em uma **classe utilitária** ou ser refatorado.

Exemplo de má prática:

```java
public class Pessoa {
    static String nome;
}
```
> Aqui, cada pessoa deveria ter um **nome diferente**, logo, **não deveria ser estático**.

---

## ✅ Conclusão

O modificador `static` é uma ferramenta poderosa em Java para compartilhamento de dados e métodos, mas deve ser usado com critério. Ele promove economia de memória e facilita acesso a comportamentos comuns, porém, **um uso inadequado pode prejudicar a orientação a objetos**.



[Voltar ao Índice](#indice)

---


## <a name="parte63">63 - 062 - Orientação Objetos - Métodos estáticos</a>

# Aula 62 – Orientação a Objetos: Métodos Estáticos

🎥 **Vídeo:** [Métodos estáticos](https://www.youtube.com/watch?v=jowlUssbJmk&list=PL62G310vn6nFIsOCC0H-C2infYgwm8SWW&index=64)

## 🎯 Objetivo da Aula

Aprender a utilizar corretamente **métodos estáticos** (`static`) em Java, entender suas aplicações práticas, vantagens, desvantagens e diferenças em relação aos métodos de instância.

---

## 🧠 Conceitos Abordados

- Métodos `static` pertencem **à classe**, não ao objeto.
- Métodos `static` **não podem acessar diretamente atributos de instância**.
- Úteis para operações que **não dependem** do estado de um objeto.
- Normalmente usados em **classes utilitárias** (ex: `Math`, `Arrays`).

---

## 💡 Exemplo Básico – Método Estático

```java
public class Calculadora {
    public static int somar(int a, int b) {
        return a + b;
    }
}

public class TesteCalculadora {
    public static void main(String[] args) {
        int resultado = Calculadora.somar(5, 10);
        System.out.println("Resultado da soma: " + resultado);
    }
}
```
> Aqui, não é necessário criar uma instância de `Calculadora` para usar o método `somar`.

---

## 💡 Exemplo Complexo – Métodos Estáticos em Classe Utilitária

```java
public class Conversor {
    public static double celsiusParaFahrenheit(double celsius) {
        return (celsius * 1.8) + 32;
    }

    public static double fahrenheitParaCelsius(double fahrenheit) {
        return (fahrenheit - 32) / 1.8;
    }
}

public class TesteConversor {
    public static void main(String[] args) {
        double tempF = Conversor.celsiusParaFahrenheit(25);
        double tempC = Conversor.fahrenheitParaCelsius(77);

        System.out.println("25°C em Fahrenheit: " + tempF);
        System.out.println("77°F em Celsius: " + tempC);
    }
}
```
> Exemplo clássico de métodos utilitários que fazem conversão de valores.

---

## ✅ Boas Práticas

- ✅ Use `static` para métodos que **não precisam acessar ou modificar atributos de instância**.
- ✅ Centralize métodos `static` em **classes utilitárias** específicas (como `Conversor`, `Calculadora`).
- ✅ Documente bem o comportamento dos métodos `static`, pois eles podem ser usados **fora do contexto** de objetos.
- ✅ Nomeie as funções de maneira clara e objetiva.

---

## ❌ Práticas a Evitar

- ❌ Não use `static` em métodos que **precisem acessar atributos de instância**.
- ❌ Evite misturar métodos `static` com lógicas que deveriam ser orientadas a objetos.
- ❌ Não exagere no uso de `static`, senão sua aplicação pode se tornar procedural (perdendo os benefícios da OOP).
- ❌ Evite criar dependência entre métodos `static` e estados internos de objetos.

---

## 📌 Dica Extra

Se você precisar de **polimorfismo** (sobrescrever métodos em subclasses), **não use `static`**! Métodos estáticos **não são polimórficos** em Java.

---

## ✅ Conclusão

Métodos `static` são essenciais para construir funções independentes do estado de objetos, ideais para operações genéricas, cálculos e utilidades. Contudo, o excesso de métodos `static` pode prejudicar a boa modelagem orientada a objetos. Use com consciência!


[Voltar ao Índice](#indice)

---


## <a name="parte64">64 - 063 - Orientação Objetos - Bloco de inicialização estático</a>

# Bloco de Inicialização Estático em Java

Este documento resume os principais conceitos abordados na videoaula **"63 - Orientação a Objetos - Bloco de Inicialização Estático"** do curso de Java, disponível em: [https://www.youtube.com/watch?v=4YE1ewRK-rk](https://www.youtube.com/watch?v=4YE1ewRK-rk).

---

## 📘 O que é um Bloco de Inicialização Estático?

Em Java, um **bloco de inicialização estático** é um bloco de código precedido pela palavra-chave `static`, que é executado **uma única vez**, no momento em que a classe é carregada pela JVM (Java Virtual Machine). ([Static vs. Instance Initializer Block in Java | Baeldung](https://www.baeldung.com/java-static-instance-initializer-blocks?utm_source=chatgpt.com))

É utilizado para inicializar variáveis estáticas ou executar operações que precisam ocorrer apenas uma vez, independentemente de quantas instâncias da classe sejam criadas.

---

## 🧪 Exemplos Práticos

### Exemplo Básico

```java
public class ExemploBasico {
    static int contador;

    static {
        contador = 100;
        System.out.println("Bloco estático executado. Contador inicializado com " + contador);
    }

    public static void main(String[] args) {
        System.out.println("Valor do contador: " + contador);
    }
}
```

**Saída:**
```
Bloco estático executado. Contador inicializado com 100
Valor do contador: 100
```


Neste exemplo, o bloco estático é executado antes do método `main`, inicializando a variável `contador`. ([static block in java- Scaler Topics](https://www.scaler.com/topics/static-block-in-java/?utm_source=chatgpt.com))

---

### Exemplo Avançado

```java
public class Configuracao {
    static Properties propriedades;

    static {
        propriedades = new Properties();
        try (InputStream input = new FileInputStream("config.properties")) {
            propriedades.load(input);
            System.out.println("Configurações carregadas com sucesso.");
        } catch (IOException e) {
            System.err.println("Erro ao carregar configurações: " + e.getMessage());
        }
    }

    public static String getPropriedade(String chave) {
        return propriedades.getProperty(chave);
    }
}
```


Neste exemplo, o bloco estático é utilizado para carregar configurações de um arquivo externo no momento em que a classe `Configuracao` é carregada.

---

## ✅ Boas Práticas

- **Inicializações Simples:** Utilize blocos estáticos para inicializações simples e rápidas, como configuração de constantes ou carregamento de recursos essenciais.

- **Tratamento de Exceções:** Sempre trate possíveis exceções dentro do bloco estático para evitar falhas na inicialização da classe.

- **Ordem de Execução:** Se houver múltiplos blocos estáticos, eles serão executados na ordem em que aparecem no código.

---

## ❌ Más Práticas

- **Operações Pesadas:** Evite executar operações demoradas ou complexas dentro de blocos estáticos, pois isso pode impactar negativamente o tempo de carregamento da classe.

- **Dependências Externas:** Minimize dependências de recursos externos que podem não estar disponíveis no momento da inicialização.

- **Modificações Posteriores:** Não utilize blocos estáticos para modificar o estado de objetos que ainda não foram inicializados.

---

## 🧠 Conclusão

Blocos de inicialização estáticos são uma ferramenta poderosa em Java para configurar o ambiente de uma classe antes de sua utilização. Quando usados com cautela e seguindo as boas práticas, podem tornar o código mais eficiente e organizado.

---

*Referências:*

- [Static Blocks in Java - GeeksforGeeks](https://www.geeksforgeeks.org/static-blocks-in-java/)

- [Static vs. Instance Initializer Block in Java | Baeldung](https://www.baeldung.com/java-static-instance-initializer-blocks)

- [Essential Techniques for Optimizing Your Java Code with Static Blocks](https://medium.com/@tuananhbk1996/essential-techniques-for-optimizing-your-java-code-with-static-blocks-3a478f66a08d)



[Voltar ao Índice](#indice)

---


## <a name="parte65">65 - 064 - Orientação Objetos - Associação pt 01 - Arrays com Objetos</a>


## Conceito Principal
- **Associação**: Relacionamento entre objetos onde um objeto usa outro para realizar alguma operação.
- **Arrays com Objetos**: Permitem armazenar múltiplas instâncias de objetos em uma estrutura de dados linear.

---

## Exemplos Básicos

### 1. Classe `Aluno` (Objeto Associado)
```java
public class Aluno {
    private String nome;
    private int idade;

    // Construtor
    public Aluno(String nome, int idade) {
        this.nome = nome;
        this.idade = idade;
    }

    // Getters (boas práticas)
    public String getNome() { return nome; }
    public int getIdade() { return idade; }
}
```

### 2. Classe `Sala` (Usando Array de Objetos)
```java
public class Sala {
    private Aluno[] alunos; // Associação via array

    public Sala(int capacidade) {
        alunos = new Aluno[capacidade];
    }

    public void adicionarAluno(Aluno aluno, int indice) {
        alunos[indice] = aluno;
    }

    public void listarAlunos() {
        for (Aluno aluno : alunos) {
            if (aluno != null) {
                System.out.println(aluno.getNome());
            }
        }
    }
}
```

---

## Exemplo Complexo (Com Validações)
```java
public class Escola {
    private Sala[] salas;
    private int totalSalas;

    public Escola(int maxSalas) {
        salas = new Sala[maxSalas];
    }

    public void adicionarSala(Sala sala) {
        if (totalSalas < salas.length) {
            salas[totalSalas++] = sala;
        } else {
            System.out.println("Capacidade máxima de salas atingida!");
        }
    }

    public void mostrarAlunosPorSala() {
        for (int i = 0; i < totalSalas; i++) {
            System.out.println("Sala " + (i + 1) + ":");
            salas[i].listarAlunos();
        }
    }
}
```

---

## Melhores Práticas ✅

1. **Encapsulamento**:
    - Sempre usar `private` para atributos e fornecer getters/setters quando necessário.
    - Exemplo: `alunos` na classe `Sala` é privado.

2. **Inicialização Segura**:
    - Verificar limites do array antes de inserir (`if (indice >= 0 && indice < alunos.length)`).

3. **Nomenclatura Clara**:
    - Nomes descritivos como `listarAlunos()` em vez de `printAll()`.

4. **Tratamento de Nulos**:
    - Verificar `if (aluno != null)` ao iterar em arrays.

5. **Flexibilidade**:
    - Usar coleções dinâmicas (`ArrayList`) em vez de arrays fixos quando possível (tópico avançado).

---

## Práticas a Evitar ❌

1. **Acesso Direto a Atributos**:
   ```java
   // Ruim
   sala.alunos[0] = new Aluno("Nome", 20);

   // Bom
   sala.adicionarAluno(new Aluno("Nome", 20), 0);
   ```

2. **Tamanho Fixo sem Validação**:
    - Não verificar limites do array causa `ArrayIndexOutOfBoundsException`.

3. **Ignorar Nulos**:
    - Iterar arrays sem verificar nulos pode gerar `NullPointerException`.

4. **Acoplamento Direto**:
    - Expor o array interno (ex: método `getAlunos()` que retorna o array) permite modificações inseguras.

5. **Métodos Longos**:
    - Evitar lógica complexa diretamente nos métodos de associação (ex: validações deveriam estar em classes separadas).

---

## Observações da Aula
- Arrays de objetos são a forma mais simples de associação 1:N (um para muitos).
- Em aplicações reais, preferir coleções como `ArrayList` (será visto em aulas futuras).
- A associação permite modelar relações do mundo real (ex: Escola → Salas → Alunos).

### Link da Aula
[Assista aqui](https://www.youtube.com/watch?v=HOjV9M6pRQQ&list=PL62G310vn6nFIsOCC0H-C2infYgwm8SWW&index=66)

---


[Voltar ao Índice](#indice)

---


## <a name="parte66">66 - 065 - Orientação Objetos - Associação pt 02 - Associação unidirecional um para muitos</a>

# Resumo da Aula: Associação Unidirecional Um para Muitos

## Conceito Principal
**Associação Unidirecional 1:N**: Um objeto de uma classe contém/referencia múltiplos objetos de outra classe, sem que o inverso seja verdadeiro. A relação existe apenas em uma direção.

---

## Exemplo Básico: Professor → Alunos

### Classe `Aluno` (Classe Independente)
```java
public class Aluno {
    private String nome;
    
    public Aluno(String nome) {
        this.nome = nome;
    }
    
    public String getNome() {
        return nome;
    }
}
```

### Classe `Professor` (Classe Dono da Associação)
```java
public class Professor {
    private String nome;
    private List<Aluno> alunos; // Associação 1 para muitos

    public Professor(String nome) {
        this.nome = nome;
        this.alunos = new ArrayList<>(); // Boa prática: inicializar a coleção
    }

    public void adicionarAluno(Aluno aluno) {
        alunos.add(aluno);
    }

    public void listarAlunos() {
        System.out.println("Alunos do professor " + nome + ":");
        for (Aluno aluno : alunos) {
            System.out.println("- " + aluno.getNome());
        }
    }
}
```

---

## Exemplo Complexo: Departamento → Professores → Alunos

### Classe `Departamento`
```java
public class Departamento {
    private String nome;
    private List<Professor> professores;

    public Departamento(String nome) {
        this.nome = nome;
        this.professores = new ArrayList<>();
    }

    public void adicionarProfessor(Professor professor) {
        professores.add(professor);
    }

    public void relatorio() {
        System.out.println("Departamento: " + nome);
        System.out.println("Total professores: " + professores.size());
        System.out.println("--- Relação Professores/Alunos ---");
        
        for (Professor prof : professores) {
            prof.listarAlunos();
            System.out.println();
        }
    }
}
```

---

## Melhores Práticas ✅

1. **Uso de Collections**:
    - Prefira `List`/`ArrayList` em vez de arrays para flexibilidade (tamanho dinâmico).

2. **Encapsulamento Rigoroso**:
    - Métodos modificadores (`adicionarAluno()`) devem ser o único meio de alterar a associação.

3. **Inicialização no Construtor**:
    - Sempre inicializar coleções no construtor para evitar `NullPointerException`.

4. **Navegação Unidirecional**:
    - Mantenha a relação em uma só direção (ex: Professor conhece Alunos, mas Aluno NÃO conhece Professor).

5. **Imutabilidade Parcial**:
    - Para atributos básicos como `nome`, considere `final` se não precisarem ser alterados.

---

## Práticas a Evitar ❌

1. **Expor Coleções Internas**:
   ```java
   // RUIM (permite modificação externa incontrolada)
   public List<Aluno> getAlunos() {
       return alunos;
   }

   // ACEITÁVEL (cópia defensiva)
   public List<Aluno> getAlunos() {
       return new ArrayList<>(alunos);
   }
   ```

2. **Bidirecionalidade Acidental**:
    - Evite adicionar referência ao Professor na classe Aluno (isso mudaria para bidirecional).

3. **Validações Ausentes**:
    - Não verificar `null` em métodos como `adicionarAluno(Aluno aluno)`.

4. **Métodos "Gigantes"**:
    - Evite lógica complexa nas classes de associação (ex: regras de negócio devem ficar em serviços).

5. **Acoplamento Circular**:
    - Não fazer Departamentos conhecerem Alunos diretamente (deve ser via Professores).

---

## Exemplo Completo em Execução

```java
public class Main {
    public static void main(String[] args) {
        // Criando alunos
        Aluno a1 = new Aluno("Ana");
        Aluno a2 = new Aluno("Lucas");
        Aluno a3 = new Aluno("Carlos");

        // Criando professor e associando alunos
        Professor p1 = new Professor("Dr. Silva");
        p1.adicionarAluno(a1);
        p1.adicionarAluno(a2);

        Professor p2 = new Professor("Dra. Santos");
        p2.adicionarAluno(a3);

        // Criando departamento
        Departamento departamento = new Departamento("Ciência da Computação");
        departamento.adicionarProfessor(p1);
        departamento.adicionarProfessor(p2);

        // Gerando relatório
        departamento.relatorio();
    }
}
```

### Saída Esperada:
```
Departamento: Ciência da Computação
Total professores: 2
--- Relação Professores/Alunos ---
Alunos do professor Dr. Silva:
- Ana
- Lucas

Alunos do professor Dra. Santos:
- Carlos
```

---

## Diferença Chave para Aula Anterior
- Na associação com arrays (aula 64), o relacionamento era estático (tamanho fixo).
- Nesta aula (65), usando `List`, o relacionamento é dinâmico e mais aderente a cenários reais.

**Link da Aula**: [Assista aqui](https://www.youtube.com/watch?v=LFlZcO9qAh8&list=PL62G310vn6nFIsOCC0H-C2infYgwm8SWW&index=67)



[Voltar ao Índice](#indice)

---


## <a name="parte67">67 - 066 - Orientação Objetos - Associação pt 03 - Associação unidirecional muitos para um</a>

# Resumo da Aula: Associação Unidirecional Muitos para Um (N:1)

## Conceito Principal
**Associação Unidirecional N:1**: Múltiplos objetos de uma classe referenciam um único objeto de outra classe, sem que o inverso seja verdadeiro. Diferente da aula anterior (1:N), agora a "seta" aponta no sentido inverso.

---

## Exemplo Básico: Alunos → Escola

### Classe `Escola` (Classe Alvo)
```java
public class Escola {
    private String nome;
    
    public Escola(String nome) {
        this.nome = nome;
    }
    
    public String getNome() {
        return nome;
    }
}
```

### Classe `Aluno` (Classe que Referencia)
```java
public class Aluno {
    private String nome;
    private Escola escola; // Associação muitos-para-um

    public Aluno(String nome, Escola escola) {
        this.nome = nome;
        this.escola = escola;
    }

    public void imprimirDados() {
        System.out.println(nome + " estuda na " + escola.getNome());
    }
}
```

---

## Exemplo Complexo: Funcionários → Departamento → Empresa

### Classe `Empresa`
```java
public class Empresa {
    private String nome;
    
    public Empresa(String nome) {
        this.nome = nome;
    }
    
    public String getNome() {
        return nome;
    }
}
```

### Classe `Departamento`
```java
public class Departamento {
    private String nome;
    private Empresa empresa; // Associação N:1

    public Departamento(String nome, Empresa empresa) {
        this.nome = nome;
        this.empresa = empresa;
    }

    public void relatorio() {
        System.out.println(nome + " pertence à " + empresa.getNome());
    }
}
```

### Classe `Funcionario`
```java
public class Funcionario {
    private String nome;
    private Departamento departamento; // Associação N:1

    public Funcionario(String nome, Departamento departamento) {
        this.nome = nome;
        this.departamento = departamento;
    }

    public void mostrarVinculo() {
        System.out.printf("%s trabalha no %s na empresa %s\n",
            nome,
            departamento.getNome(),
            departamento.getEmpresa().getNome());
    }
}
```

---

## Melhores Práticas ✅

1. **Construção Segura**:
    - Exigir o objeto obrigatório no construtor:
      ```java
      public Aluno(String nome, Escola escola) {
          Objects.requireNonNull(escola); // Validação importante
          this.escola = escola;
      }
      ```

2. **Navegação Encadeada**:
    - Permite acessar informações hierárquicas:
      ```java
      funcionario.getDepartamento().getEmpresa().getNome();
      ```

3. **Imutabilidade das Referências**:
    - Considere `final` para referências que não devem mudar:
      ```java
      private final Escola escola;
      ```

4. **Separação de Responsabilidades**:
    - A classe `Funcionario` não deve conhecer diretamente `Empresa`, apenas `Departamento`.

5. **Uso de Interfaces**:
    - Se aplicável, usar interfaces para reduzir acoplamento:
      ```java
      private IEmpresa empresa;
      ```

---

## Práticas a Evitar ❌

1. **Referências Nulas sem Validação**:
   ```java
   // RUIM
   public void setEscola(Escola escola) {
       this.escola = escola; // Pode ser null
   }
   ```

2. **Bidirecionalidade Acidental**:
    - Evite adicionar `List<Aluno>` na classe `Escola` (transformaria em bidirecional).

3. **Exposição de Objetos Internos**:
   ```java
   // PERIGOSO (permite modificar o estado interno)
   public Escola getEscola() {
       return escola;
   }
   
   // MELHOR (retornar cópia ou imutável)
   public Escola getEscola() {
       return new Escola(escola.getNome());
   }
   ```

4. **Hierarquias Muito Profundas**:
    - Evite cadeias muito longas (`funcionario.getDepartamento().getEmpresa().getGrupo().getPais()`).

5. **Lógica Complexa nos Getters**:
    - Não adicione validações/computação pesada em métodos de acesso.

---

## Exemplo Completo em Execução

```java
public class Main {
    public static void main(String[] args) {
        // Exemplo Básico
        Escola escola1 = new Escola("Escola Municipal");
        Aluno aluno1 = new Aluno("João", escola1);
        Aluno aluno2 = new Aluno("Maria", escola1);
        aluno1.imprimirDados();
        aluno2.imprimirDados();

        // Exemplo Complexo
        Empresa empresaX = new Empresa("Tech Solutions");
        Departamento rh = new Departamento("RH", empresaX);
        Departamento ti = new Departamento("TI", empresaX);
        
        Funcionario f1 = new Funcionario("Carlos", ti);
        Funcionario f2 = new Funcionario("Ana", rh);
        
        f1.mostrarVinculo();
        f2.mostrarVinculo();
        ti.relatorio();
    }
}
```

### Saída Esperada:
```
João estuda na Escola Municipal
Maria estuda na Escola Municipal
Carlos trabalha no TI na empresa Tech Solutions
Ana trabalha no RH na empresa Tech Solutions
TI pertence à Tech Solutions
```

---

## Comparação com Padrões Anteriores
| Aula 65 (1:N)            | Aula 66 (N:1)            |
|--------------------------|--------------------------|
| Professor tem muitos Alunos | Muitos Alunos têm uma Escola |
| Dono da relação guarda coleção | Dono é referenciado por muitos |
| `List<Aluno>` no Professor | `Escola` no Aluno |

**Link da Aula**: [Assista aqui](https://www.youtube.com/watch?v=idIGsMoxfO0&list=PL62G310vn6nFIsOCC0H-C2infYgwm8SWW&index=68)

Este resumo mostra a inversão de perspectiva em relação à aula anterior, mantendo o foco no baixo acoplamento e alta coesão. O exemplo complexo demonstra como construir hierarquias de objetos de forma limpa e escalável.

[Voltar ao Índice](#indice)

---


## <a name="parte68">68 - 067 - Orientação Objetos - Associação pt 04 - Associação bidirecional</a>

# Resumo da Aula: Associação Bidirecional em Java

## Conceito Principal
**Associação Bidirecional**: Relação onde duas classes se referenciam mutuamente, exigindo sincronização cuidadosa para manter a consistência dos dados.

---

## Exemplo Básico: Aluno ↔ Turma (1:N)

### Classe `Aluno` (Implementação Corrigida)
```java
public class Aluno {
    private final String nome;
    private Turma turma;

    public Aluno(String nome) {
        this.nome = nome;
    }

    public void entrarNaTurma(Turma novaTurma) {
        if (this.turma == novaTurma) return;
        
        if (this.turma != null) {
            this.turma.getAlunos().remove(this);
        }
        
        this.turma = novaTurma;
        
        if (novaTurma != null && !novaTurma.getAlunos().contains(this)) {
            novaTurma.getAlunos().add(this);
        }
    }

    public void mostrarSituacao() {
        System.out.println(nome + " - Turma: " + (turma != null ? turma.getNome() : "Sem turma"));
    }
}
```

### Classe `Turma` (Implementação Corrigida)
```java
public class Turma {
    private final String nome;
    private final List<Aluno> alunos = new ArrayList<>();

    public Turma(String nome) {
        this.nome = nome;
    }

    public void adicionarAluno(Aluno aluno) {
        if (aluno == null || alunos.contains(aluno)) return;
        
        alunos.add(aluno);
        if (aluno.getTurma() != this) {
            aluno.entrarNaTurma(this);
        }
    }

    public void listarAlunos() {
        System.out.println("Alunos da " + nome + ":");
        alunos.forEach(Aluno::mostrarSituacao);
    }
}
```

---

## Exemplo Complexo: Departamento ↔ Professor ↔ Aluno

### Classe `Departamento`
```java
public class Departamento {
    private String nome;
    private List<Professor> professores = new ArrayList<>();

    public void adicionarProfessor(Professor prof) {
        if (!professores.contains(prof)) {
            professores.add(prof);
            if (prof.getDepartamento() != this) {
                prof.setDepartamento(this);
            }
        }
    }
}
```

### Classe `Professor`
```java
public class Professor {
    private String nome;
    private Departamento departamento;
    private List<Aluno> orientandos = new ArrayList<>();

    public void setDepartamento(Departamento depto) {
        if (this.departamento != depto) {
            this.departamento = depto;
            depto.adicionarProfessor(this);
        }
    }
}
```

---

## Melhores Práticas ✅

1. **Controle de Duplicação**:
    - Use `contains()` antes de adicionar a coleções
    - Exemplo: `if (!alunos.contains(aluno)) alunos.add(aluno);`

2. **Sincronização Bidirecional**:
    - Sempre atualize ambos os lados da relação
    - Verifique `if (aluno.getTurma() != this)` antes de atualizar

3. **Imutabilidade**:
    - Atributos básicos como `nome` devem ser `final`

4. **Null Safety**:
    - Sempre verifique `if (aluno != null)`

5. **Encapsulamento**:
    - Use `Collections.unmodifiableList()` para retornar coleções:
   ```java
   public List<Aluno> getAlunos() {
       return Collections.unmodifiableList(alunos);
   }
   ```

---

## Práticas a Evitar ❌

1. **Exposição Direta de Coleções**:
   ```java
   // RUIM
   public List<Aluno> getAlunos() { return alunos; }
   ```

2. **Atualização Incompleta**:
   ```java
   // PERIGOSO (atualiza só um lado)
   public void setTurma(Turma turma) { this.turma = turma; }
   ```

3. **Loops Infinitos**:
    - Não verificar a relação existente antes de atualizar

4. **Bidirecionalidade Desnecessária**:
    - Implemente apenas quando essencial para o domínio

---

## Exemplo Completo Funcional

```java
public class Main {
    public static void main(String[] args) {
        Turma turmaPOO = new Turma("POO-2023");
        Aluno aluno1 = new Aluno("Maria");
        Aluno aluno2 = new Aluno("João");

        // Associação correta sem duplicação
        turmaPOO.adicionarAluno(aluno1);
        aluno2.entrarNaTurma(turmaPOO);

        // Verificação
        turmaPOO.listarAlunos();
    }
}
```

### Saída Correta:
```
Alunos da POO-2023:
Maria - Turma: POO-2023
João - Turma: POO-2023
```

---

## Solução para Problemas Comuns

1. **Duplicação em Listas**:
    - Use `contains()` antes de `add()`
    - Considere `Set` se permitido (embora este exemplo use `ArrayList`)

2. **Referências Circulares**:
   ```java
   // Na classe Aluno
   public void entrarNaTurma(Turma novaTurma) {
       if (this.turma == novaTurma) return; // Importante!
       // ... resto do código
   }
   ```

3. **NullPointerException**:
   ```java
   public void adicionarAluno(Aluno aluno) {
       Objects.requireNonNull(aluno, "Aluno não pode ser nulo");
       // ... resto do código
   }
   ```

**Link da Aula**: [Assista aqui](https://www.youtube.com/watch?v=-RtaqvKlH7w&list=PL62G310vn6nFIsOCC0H-C2infYgwm8SWW&index=70)

> Esta implementação corrige os problemas de duplicação mantendo a associação bidirecional com `ArrayList`, seguindo as melhores práticas de OO.


As principais correções em relação ao problema de duplicação são:
1. Verificação `contains()` antes de adicionar à lista
2. Controle rigoroso do fluxo entre `entrarNaTurma()` e `adicionarAluno()`
3. Prevenção de loops com a condição `if (this.turma == novaTurma) return;`
4. Sincronização completa dos dois lados da associação

[Voltar ao Índice](#indice)

---


## <a name="parte69">69 - 068 - Orientação Objetos - Leitura de dados pelo console</a>

# Resumo: Leitura de Dados pelo Console em Java

## 📌 Visão Geral
A aula aborda como ler dados do console em Java usando a classe `Scanner`, que pertence ao pacote `java.util`. Essa técnica é útil para interações básicas com o usuário via terminal.

## 📋 Exemplos Básicos

### 1. Importação e Criação do Scanner
```java
import java.util.Scanner;

public class LeituraDados {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
    }
}
```

### 2. Lendo Diferentes Tipos de Dados
```java
System.out.print("Digite seu nome: ");
String nome = scanner.nextLine();

System.out.print("Digite sua idade: ");
int idade = scanner.nextInt();

System.out.print("Digite sua altura (ex: 1,75): ");
double altura = scanner.nextDouble();
```

## 🏗️ Exemplo Complexo (Validação de Entrada)
```java
import java.util.InputMismatchException;
import java.util.Scanner;

public class LeituraValidada {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int idade = 0;
        boolean entradaValida = false;

        while (!entradaValida) {
            try {
                System.out.print("Digite sua idade: ");
                idade = scanner.nextInt();
                entradaValida = true;
            } catch (InputMismatchException e) {
                System.out.println("Erro: Digite um número inteiro válido!");
                scanner.next(); // Limpa o buffer do scanner
            }
        }

        System.out.println("Idade registrada: " + idade);
        scanner.close();
    }
}
```

## ✅ Melhores Práticas
1. **Sempre fechar o Scanner**: Use `scanner.close()` quando não for mais necessário.
2. **Tratamento de exceções**: Capture `InputMismatchException` para entradas inválidas.
3. **Limpar o buffer**: Use `scanner.next()` após erros para evitar loops infinitos.
4. **Mensagens claras**: Sempre exiba instruções claras para o usuário.
5. **Validação de entrada**: Implemente lógica para garantir que os dados estão no formato esperado.

## ❌ Piores Práticas (Evitar)
1. **Não validar entradas**: Aceitar qualquer valor sem verificação pode causar erros.
2. **Ignorar exceções**: Não tratar `InputMismatchException` pode quebrar o programa.
3. **Não fechar o Scanner**: Pode causar vazamento de recursos.
4. **Misturar nextLine() com nextInt()/nextDouble()**: Pode causar comportamentos inesperados devido ao buffer.
    - ❌ Problema:
      ```java
      int idade = scanner.nextInt();
      String nome = scanner.nextLine(); // Vai capturar o "enter" anterior
      ```
    - ✅ Solução:
      ```java
      int idade = scanner.nextInt();
      scanner.nextLine(); // Consome o "enter"
      String nome = scanner.nextLine();
      ```

5. **Usar Scanner como variável global**: Pode levar a problemas de concorrência e dificulta o gerenciamento de recursos.

## 🔍 Observações Adicionais
- Para sistemas reais, considere usar frameworks mais robustos para entrada de dados.
- O Scanner é adequado para programas simples e aprendizado.
- Em aplicações com muitas entradas, considere criar métodos utilitários para leitura e validação.


Este resumo cobre os principais pontos da aula, incluindo exemplos práticos e dicas importantes para escrever código mais robusto ao trabalhar com entrada de dados pelo console em Java.

[Voltar ao Índice](#indice)

---


## <a name="parte70">70 - 069 - Orientação Objetos - Exercício leitura de dados do teclado</a>



[Voltar ao Índice](#indice)

---


## <a name="parte73">73 - 070 - Orientação Objetos - Associação pt 05 - Exercício Associação</a>

[/070-OrientacaoObjetos-Associacaopt05-ExercicioAssociacao](/070-OrientacaoObjetos-Associacaopt05-ExercicioAssociacao)


# Resumo: Associação em Java - Exercício Prático

## 📌 Visão Geral
A aula aborda o conceito de **Associação** em Java, que é um tipo de relação entre objetos onde um objeto "usa" outro, sem que um seja dono do outro (como em composição/agregação). O exercício prático demonstra como modelar relações entre classes usando associação.

---

## 📋 Exemplo Básico (Modelagem de Classes com Associação)

### Cenário: 
- **Seminário**, **Aluno**, **Professor** e **Local** são classes que se relacionam:
  - Um `Seminário` tem `Alunos`, um `Professor` e um `Local`.
  - Um `Aluno` pode estar em um `Seminário`.
  - Um `Professor` pode ministrar um ou mais `Seminários`.

### Código das Classes:
#### Classe `Local`
```java
public class Local {
    private String endereco;

    public Local(String endereco) {
        this.endereco = endereco;
    }

    // Getters e Setters
    public String getEndereco() {
        return endereco;
    }
}
```

#### Classe `Aluno`
```java
public class Aluno {
    private String nome;
    private Seminario seminario;

    public Aluno(String nome) {
        this.nome = nome;
    }

    // Associação com Seminário
    public void setSeminario(Seminario seminario) {
        this.seminario = seminario;
    }

    // Getters e Setters
}
```

#### Classe `Professor`
```java
public class Professor {
    private String nome;
    private List<Seminario> seminarios;

    public Professor(String nome) {
        this.nome = nome;
        this.seminarios = new ArrayList<>();
    }

    // Associação com Seminário (um professor pode ter muitos seminários)
    public void addSeminario(Seminario seminario) {
        this.seminarios.add(seminario);
    }
}
```

#### Classe `Seminario`
```java
public class Seminario {
    private String titulo;
    private List<Aluno> alunos;
    private Professor professor;
    private Local local;

    public Seminario(String titulo, Local local) {
        this.titulo = titulo;
        this.local = local;
        this.alunos = new ArrayList<>();
    }

    // Associação com Aluno (um seminário pode ter muitos alunos)
    public void addAluno(Aluno aluno) {
        this.alunos.add(aluno);
        aluno.setSeminario(this); // Bidirecional
    }

    // Getters e Setters
}
```

---

## 🏗️ Exemplo Complexo (Relação Bidirecional e Validação)
```java
public class TesteAssociacao {
    public static void main(String[] args) {
        Local local = new Local("Av. Java, 123");
        Professor professor = new Professor("João Silva");
        Seminario seminario = new Seminario("POO com Java", local);

        // Adiciona professor ao seminário
        seminario.setProfessor(professor);
        professor.addSeminario(seminario); // Bidirecional

        // Cria alunos e associa ao seminário
        Aluno aluno1 = new Aluno("Maria");
        Aluno aluno2 = new Aluno("Pedro");

        seminario.addAluno(aluno1);
        seminario.addAluno(aluno2);

        // Exibe informações
        System.out.println("Seminário: " + seminario.getTitulo());
        System.out.println("Local: " + seminario.getLocal().getEndereco());
        System.out.println("Professor: " + seminario.getProfessor().getNome());
        System.out.println("Alunos: " + seminario.getAlunos().stream()
            .map(Aluno::getNome)
            .collect(Collectors.joining(", ")));
    }
}
```

---

## ✅ Melhores Práticas
1. **Use nomes claros para associações**: Ex: `aluno.setSeminario(seminario)` é mais intuitivo que `aluno.setRelacao1(seminario)`.
2. **Mantenha a consistência em relações bidirecionais**: Se `A` conhece `B`, `B` também deve conhecer `A` (se necessário).
3. **Valide associações**: Evite adicionar `null` ou objetos inválidos em listas de associação.
4. **Prefira coleções (`List`, `Set`) para relações "1-N"**: Em vez de arrays, use estruturas dinâmicas.
5. **Encapsule a lógica de associação**: Ex: `seminario.addAluno(aluno)` deve atualizar ambos os lados (aluno e seminário).

---

## ❌ Piores Práticas (Evitar)
1. **Expor atributos sem encapsulamento**:
    - ❌ Ruim:
      ```java
      public class Seminario {
          public List<Aluno> alunos; // Expõe a lista diretamente
      }
      ```
    - ✅ Bom:
      ```java
      public class Seminario {
          private List<Aluno> alunos;
          public void addAluno(Aluno aluno) { ... }
      }
      ```

2. **Ignorar relações bidirecionais**:
    - ❌ Ruim (associação unilateral):
      ```java
      seminario.getAlunos().add(aluno); // Aluno não sabe que está no seminário
      ```

3. **Ciclos de dependência desnecessários**:
    - Evite criar estruturas onde `A` depende de `B`, `B` depende de `C` e `C` depende de `A`.

4. **Não inicializar coleções**:
    - ❌ Ruim:
      ```java
      private List<Aluno> alunos; // Pode causar NullPointerException
      ```
    - ✅ Bom:
      ```java
      private List<Aluno> alunos = new ArrayList<>();
      ```

5. **Métodos de associação sem validação**:
    - ❌ Ruim:
      ```java
      public void setProfessor(Professor professor) {
          this.professor = professor; // Aceita null ou professor inválido
      }
      ```

---

## 🔍 Observações Adicionais
- **Associação ≠ Herança**: Associação é "ter um", herança é "ser um".
- **Grau de acoplamento**: Associação aumenta o acoplamento, mas é essencial para modelagem OO.
- **Para relações mais fortes**, considere **Composição** (o objeto dono gerencia o ciclo de vida do outro).

Este resumo cobre o exercício prático de associação entre objetos em Java, incluindo exemplos, boas práticas e armadilhas comuns.

[Voltar ao Índice](#indice)

---


## <a name="parte74">74 - 071 - Orientação Objetos - Herança pt 01</a>

# Resumo: Herança em Java - Parte 1

## 📌 Visão Geral
A aula introduz o conceito de **Herança** em Java, um dos pilares da Orientação a Objetos que permite que uma classe (subclasse) herde atributos e métodos de outra classe (superclasse), promovendo reutilização de código e organização hierárquica.

---

## 📋 Exemplo Básico

### Superclasse `Pessoa`
```java
public class Pessoa {
    private String nome;
    private String cpf;

    public Pessoa(String nome, String cpf) {
        this.nome = nome;
        this.cpf = cpf;
    }

    public void imprimirDados() {
        System.out.println("Nome: " + nome);
        System.out.println("CPF: " + cpf);
    }
}
```

### Subclasse `Funcionario` (herda de `Pessoa`)
```java
public class Funcionario extends Pessoa {
    private double salario;

    public Funcionario(String nome, String cpf, double salario) {
        super(nome, cpf); // Chama o construtor da superclasse
        this.salario = salario;
    }

    @Override
    public void imprimirDados() {
        super.imprimirDados(); // Reusa o método da superclasse
        System.out.println("Salário: " + salario);
    }
}
```

### Uso
```java
Funcionario func = new Funcionario("João", "123.456.789-00", 2500.0);
func.imprimirDados();
```

---

## 🏗️ Exemplo Complexo (Herança Múltipla Nívels)

### Hierarquia: `Veiculo` → `VeiculoTerrestre` → `Carro`
```java
// Nível 1
public class Veiculo {
    private String marca;
    public Veiculo(String marca) {
        this.marca = marca;
    }
    public void ligar() {
        System.out.println("Veículo ligado");
    }
}

// Nível 2
public class VeiculoTerrestre extends Veiculo {
    private int rodas;
    public VeiculoTerrestre(String marca, int rodas) {
        super(marca);
        this.rodas = rodas;
    }
}

// Nível 3
public class Carro extends VeiculoTerrestre {
    private int portas;
    public Carro(String marca, int portas) {
        super(marca, 4); // Todos os carros têm 4 rodas
        this.portas = portas;
    }
    @Override
    public void ligar() {
        System.out.println("Carro ligado com chave");
    }
}
```

---

## ✅ Melhores Práticas

1. **Use `@Override`**: Sempre anote métodos sobrescritos para melhor legibilidade.
2. **Chame `super()` corretamente**: Inicialize a superclasse no construtor.
3. **Prefira composição sobre herança**: Herde apenas quando houver relação "é-um".
4. **Mantenha hierarquias rasas**: Evite mais de 3 níveis de herança.
5. **Use métodos protegidos**: Para métodos usados apenas por subclasses:
   ```java
   protected void metodoInterno() { ... }
   ```

---

## ❌ Piores Práticas (Evitar)

1. **Herança para reutilização apenas**:
    - ❌ Ruim: Herdar `ArrayList` só para usar seus métodos.
    - ✅ Melhor: Usar composição (`private List list = new ArrayList()`).

2. **Quebrar LSP (Princípio de Substituição de Liskov)**:
    - ❌ Ruim:
      ```java
      @Override
      public void ligar() {
          throw new UnsupportedOperationException(); // Subclasse não deveria invalidar superclasse
      }
      ```

3. **Acessar atributos diretamente**:
    - ❌ Ruim:
      ```java
      public class SubClasse extends SuperClasse {
          public void metodo() {
              System.out.println(super.atributo); // Deveria usar getter
          }
      }
      ```

4. **Herança múltipla simulada** (Java não suporta):
    - ❌ Ruim: Usar `default` em interfaces para simular herança múltiplia complexa.

5. **Classes/métodos `final` ignorados**:
    - Não tente herdar de classes marcadas como `final` como `String`.

---

## 🔍 Observações Adicionais

- **`super` vs `this`**:
    - `super` acessa a superclasse
    - `this` acessa a classe atual

- **Herança de Interfaces**: Uma classe pode implementar múltiplas interfaces.

- **Classes Abstratas**: Úteis quando a superclasse não deve ser instanciada diretamente:
  ```java
  public abstract class Animal {
      public abstract void emitirSom();
  }
  ```

Este resumo cobre os principais conceitos de herança em Java conforme abordado na aula, com exemplos práticos e boas práticas para aplicação correta do conceito.



[Voltar ao Índice](#indice)

---


## <a name="parte75">75 - 072 - Orientação Objetos - Herança pt 02 - Super</a>

# Resumo: Herança em Java - Parte 2 (Palavra-chave `super`)

## 📌 Visão Geral
Esta aula explora o uso avançado da palavra-chave `super` em herança Java, demonstrando como:
1. Acessar membros da superclasse
2. Invocar construtores parentais
3. Diferenciar membros com nomes duplicados
4. Construir hierarquias de objetos corretamente

## 📋 Exemplos Básicos

### 1. Chamada de Construtor Parental
```java
class Veiculo {
    private String placa;
    
    public Veiculo(String placa) {
        this.placa = placa;
    }
}

class Carro extends Veiculo {
    private int portas;
    
    public Carro(String placa, int portas) {
        super(placa);  // Obrigatório (Veiculo não tem construtor padrão)
        this.portas = portas;
    }
}
```

### 2. Acesso a Método da Superclasse
```java
class Instrumento {
    void afinar() {
        System.out.println("Afinando instrumento genérico");
    }
}

class Violao extends Instrumento {
    @Override
    void afinar() {
        super.afinar();  // Reutiliza comportamento parental
        System.out.println("Afinando cordas do violão");
    }
}
```

## 🏗️ Exemplo Complexo (Hierarquia de Inicialização)

```java
class Dispositivo {
    private String serial;
    
    public Dispositivo(String serial) {
        this.serial = serial;
        System.out.println("Construindo Dispositivo");
    }
}

class Smartphone extends Dispositivo {
    private String sistema;
    
    public Smartphone(String serial, String sistema) {
        super(serial);  // Chamada obrigatória primeiro
        this.sistema = sistema;
        System.out.println("Construindo Smartphone");
    }
    
    public void mostrarInfo() {
        System.out.println("S/N: " + super.serial);  // Erro: serial é private
        System.out.println("OS: " + this.sistema);
    }
}
```

## ✅ Melhores Práticas

1. **Ordem de Construção**:
   ```java
   public SubClasse() {
       super();  // Sempre deve ser a primeira instrução
       // Demais inicializações
   }
   ```

2. **Uso de `@Override`**:
   ```java
   @Override
   void metodo() {
       super.metodo();  // Clareza na sobrescrita
   }
   ```

3. **Encapsulamento Protegido**:
   ```java
   protected String serial;  // Acessível apenas na hierarquia
   ```

4. **Encadeamento Limpo**:
   ```java
   class A {
       A(int x) { ... }
   }
   
   class B extends A {
       B() {
           super(10);  // Explícito quando necessário
       }
   }
   ```

## ❌ Piores Práticas (Evitar)

1. **Ordem Incorreta**:
   ```java
   public SubClasse() {
       this.inicializar();  // ❌ Antes de super()
       super();            // Erro de compilação
   }
   ```

2. **Acesso Direto a Privados**:
   ```java
   super.atributoPrivado;  // ❌ Não compila
   ```

3. **Abuso de Herança**:
   ```java
   class StringUtils extends String {  // ❌ String é final
       // ...
   }
   ```

4. **Construtores Fantasmas**:
   ```java
   class Pai {
       Pai(int x) { ... }
   }
   
   class Filho extends Pai {
       Filho() { }  // ❌ Falta super(x)
   }
   ```

5. **Confusão This/Super**:
   ```java
   this.metodo();  // Pode ser sobrescrito
   super.metodo(); // Versão específica da superclasse
   ```

## 🔍 Observações Avançadas

1. **Herança Multinível**:
   ```java
   class A { void m() {} }
   class B extends A { @Override void m() {} }
   class C extends B { 
       void test() {
           super.m();  // Chama B.m()
       }
   }
   ```

2. **Inicialização com Parâmetros**:
   ```java
   class Database {
       Database(String url) { ... }
   }
   
   class MySQL extends Database {
       MySQL() {
           super("jdbc:mysql://localhost");  // Parâmetro fixo
       }
   }
   ```

3. **Padrão Template Method**:
   ```java
   abstract class Template {
       void execute() {
           init();
           run();
           end();
       }
       abstract void run();
   }
   ```

4. **Problema do Diamante**:
   ```java
   interface A { default void m() {} }
   interface B { default void m() {} }
   class C implements A, B {  // ❌ Conflito
       @Override
       public void m() {
           A.super.m();  // Solução explícita
       }
   }
   ```

5. **Serialização**:
   ```java
   class Parent implements Serializable { ... }
   class Child extends Parent {
       private void readObject(ObjectInputStream ois) 
           throws IOException, ClassNotFoundException {
           ois.defaultReadObject();
           super.validate();  // Pós-processamento
       }
   }
   ```


Este resumo cobre desde os usos básicos até padrões avançados com `super`, incluindo armadilhas comuns e soluções recomendadas para construção robusta de hierarquias de classes.

[Voltar ao Índice](#indice)

---


## <a name="parte76">76 - 073 - Orientação Objetos - Herança pt 03 - protected</a>

# Resumo: Modificador `protected` em Java - Herança Parte 3

## 📌 Visão Geral
A aula explora o modificador de acesso `protected`, que permite:
- Acesso às classes do mesmo pacote
- Acesso às subclasses (mesmo em pacotes diferentes)
- Um meio-termo entre `public` e `private`

## 📋 Exemplos Básicos

### 1. Uso Básico de `protected`
```java
package br.com.dev;
public class Pessoa {
    protected String nome;  // Acessível por subclasses
    
    protected void imprimir() {
        System.out.println("Nome: " + nome);
    }
}
```

### 2. Acesso em Subclasse (pacote diferente)
```java
package br.com.outro;
import br.com.dev.Pessoa;

public class Aluno extends Pessoa {
    public void mostrarDados() {
        System.out.println(this.nome);  // Acesso permitido
        this.imprimir();  // Método protected acessível
    }
}
```

## 🏗️ Exemplo Complexo (Hierarquia com `protected`)

```java
package br.com.veiculos;

public abstract class Veiculo {
    protected String modelo;
    protected int ano;
    
    protected abstract void ligar();
    
    protected void imprimirDetalhes() {
        System.out.println("Modelo: " + modelo);
    }
}

public class Carro extends Veiculo {
    public Carro(String modelo, int ano) {
        this.modelo = modelo;  // Acesso direto
        this.ano = ano;
    }
    
    @Override
    protected void ligar() {
        System.out.println("Ligando carro " + modelo);
    }
    
    public void mostrar() {
        this.ligar();  // Chama método protected
        super.imprimirDetalhes();  // Usando super
    }
}
```

## ✅ Melhores Práticas

1. **Use para membros de framework**:
   ```java
   protected void initialize() { // Para ser sobrescrito
       // Código padrão
   }
   ```

2. **Documente o contrato**:
   ```java
   /**
    * @protected Este método deve ser sobrescrito para configurar a view
    */
   protected void setupView() {...}
   ```

3. **Prefira `protected` a `public`** para métodos internos da hierarquia

4. **Para atributos constantes**:
   ```java
   protected static final int DEFAULT_SIZE = 10;
   ```

5. **Combine com abstract**:
   ```java
   public abstract class Animal {
       protected abstract void comer();
   }
   ```

## ❌ Piores Práticas (Evitar)

1. **Expor atributos sem necessidade**:
   ```java
   protected List<String> dadosInternos;  // ❌ Expõe implementação
   ```

2. **Usar em classes `final`** (contraditório):
   ```java
   public final class Util {
       protected static void helper() {}  // ❌ Nunca será herdado
   }
   ```

3. **Violar encapsulamento**:
   ```java
   public class Conta {
       protected double saldo;  // ❌ Perigoso expor diretamente
   }
   ```

4. **Ignorar pacotes**:
   ```java
   protected void metodo() {}  // ❌ Se a classe for package-private
   ```

5. **Confundir com default (package-private)**:
   ```java
   void metodo() {}       // Só mesmo pacote
   protected void m() {}  // Só mesmo pacote + subclasses
   ```

## 🔍 Observações Avançadas

1. **Herança cruzando pacotes**:
   ```java
   // Pacote A
   public class Pai {
       protected int x;
   }
   
   // Pacote B
   public class Filho extends Pai {
       void teste() {
           System.out.println(x);  // OK
           Pai p = new Pai();
           System.out.println(p.x);  // ❌ Erro (acesso via instância)
       }
   }
   ```

2. **Padrão Template Method**:
   ```java
   public abstract class Template {
       public final void process() {
           init();
           execute();
           end();
       }
       
       protected abstract void execute();  // Hook method
       protected void init() {}  // Opcional
   }
   ```

3. **Serialização protegida**:
   ```java
   public class Base implements Serializable {
       protected void readData(ObjectInputStream in) 
           throws IOException {
           // Leitura segura para subclasses
       }
   }
   ```

4. **Classes abstratas**:
   ```java
   public abstract class Figura {
       protected int lados;
       
       protected Figura(int lados) {
           this.lados = lados;
       }
   }
   ```

5. **Enums com comportamento protegido**:
   ```java
   public enum Nivel {
       BASIC {
           protected void show() { /* impl */ }
       };
       
       protected abstract void show();
   }
   ```

## ⚠️ Cuidados Especiais

1. **Visibilidade em tempo de design**:
   ```plantuml
   class Parent {
     #protectedField
     #protectedMethod()
   }
   
   class Child {
     .. usa ..
     -> Parent#protectedField
     -> Parent#protectedMethod()
   }
   ```

2. **Refatoração segura**:
    - Alterar de `private` para `protected` = compatível
    - Alterar de `protected` para `private` = quebra compatibilidade

3. **Testabilidade**:
   ```java
   @Test
   public void testProtectedMethod() throws Exception {
       Method method = Classe.class.getDeclaredMethod("metodoProtegido");
       method.setAccessible(true);  // Reflection para testes
   }
   ```


Este resumo cobre desde os conceitos fundamentais até padrões avançados de uso do modificador `protected`, incluindo os principais cuidados no design de hierarquias de classes em Java.

[Voltar ao Índice](#indice)

---


## <a name="parte77">77 - 074 - Orientação Objetos - Herança pt 04 - Construtores</a>

# Resumo: Herança e Construtores em Java - Parte 4

## 📌 Visão Geral
Esta aula aborda o comportamento de construtores em hierarquias de herança, destacando:
- A cadeia de chamadas de construtores
- O uso obrigatório de `super()`
- Padrões para inicialização segura
- Problemas comuns e suas soluções

## 📋 Exemplos Básicos

### 1. Chamada Implícita a super()
```java
class Animal {
    Animal() {
        System.out.println("Construtor Animal");
    }
}

class Cachorro extends Animal {
    Cachorro() {
        // super() chamado implicitamente
        System.out.println("Construtor Cachorro");
    }
}
```
**Saída:**
```
Construtor Animal
Construtor Cachorro
```

### 2. Construtor Parametrizado
```java
class Veiculo {
    private String placa;
    
    Veiculo(String placa) {
        this.placa = placa;
    }
}

class Carro extends Veiculo {
    Carro(String placa) {
        super(placa); // Obrigatório explícito
    }
}
```

## 🏗️ Exemplo Complexo (Inicialização em 3 Níveis)

```java
class Eletronico {
    private int voltagem;
    
    Eletronico(int voltagem) {
        this.voltagem = voltagem;
        System.out.println("Eletronico: " + voltagem + "V");
    }
}

class Computador extends Eletronico {
    private String modelo;
    
    Computador(int voltagem, String modelo) {
        super(voltagem);
        this.modelo = modelo;
        System.out.println("Computador: " + modelo);
    }
}

class Notebook extends Computador {
    private int bateria;
    
    Notebook() {
        super(110, "UltraBook"); // Chama Computador(int, String)
        this.bateria = 5000;
        System.out.println("Notebook: " + bateria + "mAh");
    }
}
```

## ✅ Melhores Práticas

1. **Encadeamento claro**:
   ```java
   public SubClasse(params) {
       super(paramsPai); // Sempre na primeira linha
       // Inicializações específicas
   }
   ```

2. **Construtores mínimos**:
   ```java
   public class Pai {
       // Um único construtor bem definido
       public Pai(parametrosEssenciais) { ... }
   }
   ```

3. **Factory Methods**:
   ```java
   public static CriarInstanciaPadrao() {
       return new SubClasse(valoresPadrao);
   }
   ```

4. **Validação em um nível**:
   ```java
   public Pai(int valor) {
       if (valor < 0) throw... // Valida aqui
   }
   ```

5. **Documentação clara**:
   ```java
   /**
    * @throws IllegalArgumentException se X ocorrer
    */
   public Pai(int x) { ... }
   ```

## ❌ Piores Práticas (Evitar)

1. **Ordem incorreta**:
   ```java
   public SubClasse() {
       inicializar(); // ❌ Antes de super()
       super();      // Erro de compilação
   }
   ```

2. **Construtores desnecessários**:
   ```java
   public class Pai {
       public Pai() {} // Vazio só para compilar
       public Pai(int x) { ... }
   }
   ```

3. **Lógica complexa em construtores**:
   ```java
   public Pai() {
       this.connection = new Connection(); // ❌ Injeção seria melhor
       this.config = loadConfigFile();    // ❌ Pode falhar
   }
   ```

4. **Ignorar exceções**:
   ```java
   public SubClasse() {
       try { super(); } catch(Exception e) {} // ❌ Esconde erros
   }
   ```

5. **Acoplamento temporal**:
   ```java
   public Pai() {
       init(); // ❌ Requer chamada adicional
   }
   ```

## 🔍 Casos Especiais

### 1. Classes sem construtor explícito
```java
class A { }
class B extends A { } // Ambos têm construtor padrão
```

### 2. Construtores privados
```java
class Singleton {
    private Singleton() {}
    public static Singleton getInstance() { ... }
}
```

### 3. Herança com classes internas
```java
class Externa {
    class Interna extends Pai {
        Interna() {
            Externa.this.super(); // Sintaxe especial
        }
    }
}
```

### 4. Serialização
```java
class Pai implements Serializable {
    public Pai() { ... } // Chamado na desserialização
}
```

### 5. Padrão Builder
```java
class Produto {
    private Produto(Builder b) { ... }
    
    static class Builder {
        Produto build() {
            return new Produto(this);
        }
    }
}
```

## ⚠️ Regras Fundamentais

1. **Primeira linha deve ser this() ou super()**
2. **Se nenhum construtor for definido, Java insere um padrão**
3. **Classes abstratas podem ter construtores (chamados pelas concretas)**
4. **Construtores não são herdados**
5. **Final fields devem ser inicializados em todos os construtores**


Este resumo cobre desde os conceitos básicos até padrões avançados de construção de objetos em hierarquias de herança, incluindo armadilhas comuns e melhores práticas para um design robusto.



[Voltar ao Índice](#indice)

---


## <a name="parte78">78 - 075 - Orientação Objetos - Herança pt 05 - Sequência de inicialização</a>

# Resumo: Sequência de Inicialização em Herança Java

## 📌 Visão Geral
A aula explica a ordem exata de execução durante a construção de objetos em hierarquias de herança, mostrando como Java inicializa:
1. Blocos estáticos
2. Atributos de classe
3. Construtores
4. Blocos de instância

## 📋 Exemplo Básico (Ordem Simples)

```java
class A {
    static { System.out.println("Bloco estático A"); }
    { System.out.println("Bloco instância A"); }
    A() { System.out.println("Construtor A"); }
}

class B extends A {
    static { System.out.println("Bloco estático B"); }
    { System.out.println("Bloco instância B"); }
    B() { System.out.println("Construtor B"); }
}

// Saída quando new B() é chamado:
// Bloco estático A
// Bloco estático B
// Bloco instância A
// Construtor A
// Bloco instância B
// Construtor B
```

## 🏗️ Exemplo Complexo (Inicialização Multinível)

```java
class Raiz {
    private static String staticRaiz = initStatic("Static Raiz");
    private String instanciaRaiz = initInstancia("Instância Raiz");
    
    static { System.out.println("Bloco estático Raiz"); }
    { System.out.println("Bloco instância Raiz"); }
    
    Raiz() { System.out.println("Construtor Raiz"); }
    
    static String initStatic(String msg) {
        System.out.println(msg);
        return msg;
    }
    
    String initInstancia(String msg) {
        System.out.println(msg);
        return msg;
    }
}

class Nivel1 extends Raiz {
    // Membros similares com "Nivel1"...
}

class Nivel2 extends Nivel1 {
    // Membros similares com "Nivel2"...
}

// Saída para new Nivel2() mostra a ordem completa
// de inicialização em 3 níveis de herança
```

## ✅ Melhores Práticas

1. **Organize inicializações complexas**:
   ```java
   private List<String> dados = new ArrayList<>(); // Inicialização direta
   ```

2. **Use métodos auxiliares para lógica complexa**:
   ```java
   private Connection conn = initConnection();
   private Connection initConnection() { ... }
   ```

3. **Documente dependências de inicialização**:
   ```java
   /**
    * @depends BancoDeDados.inicializar() 
    * deve ser chamado primeiro
    */
   ```

4. **Para inicialização lazy**:
   ```java
   private Data dataCarregada;
   public Data getData() {
       if (dataCarregada == null) {
           dataCarregada = carregarData();
       }
       return dataCarregada;
   }
   ```

## ❌ Piores Práticas (Evitar)

1. **Ordem dependente de inicialização**:
   ```java
   private static int A = B + 1; // ❌ B ainda não inicializado
   private static int B = 2;
   ```

2. **Blocos de instância após construtor**:
   ```java
   class X {
       X() { System.out.println(a); } // ❌ a ainda não existe
       { a = 10; }
       private int a;
   }
   ```

3. **Inicialização circular**:
   ```java
   class A { static final int X = B.Y + 1; }
   class B { static final int Y = A.X + 1; } // ❌ StackOverflow
   ```

4. **Construtores que chamam métodos sobrescritos**:
   ```java
   class Pai {
       Pai() { metodo(); } // ❌ Perigoso se sobrescrito
   }
   ```

## 🔍 Detalhes de Inicialização

### Ordem Completa:
1. Blocos `static` e atributos estáticos da superclasse
2. Blocos `static` e atributos estáticos da subclasse
3. Atributos de instância e blocos não-estáticos da superclasse
4. Construtor da superclasse
5. Atributos de instância e blocos não-estáticos da subclasse
6. Construtor da subclasse

### Exemplo com Threads:
```java
class Singleton {
    private static Singleton instance = new Singleton();
    public static int COUNT_A;
    public static int COUNT_B = 0;
    
    private Singleton() {
        COUNT_A++;
        COUNT_B++;
    }
    
    public static Singleton getInstance() {
        return instance;
    }
}
// Resultado: COUNT_A=1, COUNT_B=0 (devido à ordem)
```

### Inicialização de Interfaces:
```java
interface I {
    int VAL = new Random().nextInt(10);
}
// VAL é inicializado quando a interface é carregada
```

### Caso Especial - Herança + Interfaces:
```java
interface A { default void m() {} }
class B { public void m() {} }
class C extends B implements A {
    // Não precisa implementar m()
}
```

Este resumo cobre os principais aspectos da sequência de inicialização em Java, mostrando desde exemplos básicos até casos complexos com herança multinível, incluindo armadilhas comuns e boas práticas para um código robusto.

#### Sequência de Inicialização em Herança Java

##### Ordem de Execução:

``` 

// 0 - Bloco de inicialização estático da super classe é executado quando a JVM carregar classe pai
// 1 - Bloco de inicialização estático da subclasse é executado quando a JVM carregar classe filha
// 2 - Alocado espaço em memória pro objeto da superclasse
// 3 - Cada atributo de superclasse é criado e inicializado com valores default ou o quer for passado
// 4 - Bloco de inicialização da superclasse é executado na ordem em que aparece
// 5 - Construtor é executado da superclasse
// 6 - Alocado espaço em memória pro objeto da subclasse
// 7 - Cada atributo de subclasse é criado e inicializado com valores default ou o quer for passado
// 8 - Bloco de inicialização da subclasse é executado na ordem em que aparece
// 9 - Construtor é executado da subclasse

```
[Voltar ao Índice](#indice)

---


## <a name="parte79">79 - 076 - Orientação Objetos - Sobrescrita do método toString</a>

# Resumo: Sobrescrita do Método `toString()` em Java

## 📌 Visão Geral
A aula aborda a importância e implementação da sobrescrita do método `toString()` para:
- Representação textual significativa de objetos
- Depuração mais eficiente
- Saída legível em logs e interfaces

## 📋 Exemplo Básico

### Classe sem `toString()`
```java
class Pessoa {
    String nome;
    int idade;
}

// Saída padrão quando impressa: Pessoa@15db9742
```

### Classe com `toString()` sobrescrito
```java
@Override
public String toString() {
    return "Pessoa{nome='" + nome + "', idade=" + idade + "}";
}

// Saída: Pessoa{nome='João', idade=30}
```

## 🏗️ Exemplo Complexo (Composição de Objetos)

```java
class Endereco {
    String rua;
    int numero;
    
    @Override
    public String toString() {
        return rua + ", " + numero;
    }
}

class Cliente {
    String nome;
    Endereco endereco;
    List<String> telefones;
    
    @Override
    public String toString() {
        return "Cliente{" +
               "nome='" + nome + '\'' +
               ", endereco=" + endereco +
               ", telefones=" + telefones +
               '}';
    }
}

// Saída: Cliente{nome='Maria', endereco=Av. Java, 123, telefones=[1199999, 1188888]}
```

## ✅ Melhores Práticas

1. **Inclua todos os campos relevantes**:
   ```java
   @Override
   public String toString() {
       return "Produto{" +
              "id=" + id +
              ", nome='" + nome + '\'' +
              ", preco=" + preco +
              '}';
   }
   ```

2. **Mantenha formato consistente**:
    - Escolha um padrão (ex: JSON-style) e mantenha em todas as classes

3. **Use `StringBuilder` para objetos complexos**:
   ```java
   @Override
   public String toString() {
       StringBuilder sb = new StringBuilder("Pedido{");
       sb.append("itens=").append(itens);
       // outros campos
       return sb.append('}').toString();
   }
   ```

4. **Documente o formato**:
   ```java
   /**
    * @return String no formato "Nome(id)", ex: "ProdutoX(123)"
    */
   @Override
   public String toString() { ... }
   ```

5. **Para coleções, use `Arrays.toString()` ou similar**:
   ```java
   "telefones=" + Arrays.toString(telefones)
   ```

## ❌ Piores Práticas (Evitar)

1. **Expor dados sensíveis**:
   ```java
   @Override
   public String toString() {
       return "Usuario{" +
              "login='" + login + '\'' +
              ", senha='" + senha + '\'' + // ❌ Perigoso!
              '}';
   }
   ```

2. **Formato inconsistente**:
   ```java
   // Na classe A: "Nome: "+nome
   // Na classe B: "{nome:value}" 
   ```

3. **Alta complexidade computacional**:
   ```java
   @Override
   public String toString() {
       return calcularRelatorioComplexo(); // ❌ Pode ser pesado
   }
   ```

4. **Quebrar contrato do `toString()`**:
   ```java
   @Override
   public String toString() {
       return null; // ❌ Nunca retorne null
   }
   ```

5. **Depender de locale/formatação**:
   ```java
   @Override
   public String toString() {
       return "Preço: " + NumberFormat.getCurrencyInstance().format(preco); // ❌ Locale-dependent
   }
   ```

## 🔍 Observações Avançadas

1. **Geração automática**:
    - IDEs geram `toString()` automaticamente:
      ```java
      // Eclipse/IntelliJ generation
      @Override
      public String toString() {
          return "Cliente [nome=" + nome + ", idade=" + idade + "]";
      }
      ```

2. **Bibliotecas úteis**:
    - `ToStringBuilder` do Apache Commons:
      ```java
      public String toString() {
          return ToStringBuilder.reflectionToString(this);
      }
      ```

3. **Herança com `toString()`**:
   ```java
   @Override
   public String toString() {
       return super.toString() + " SubClasse{campo=" + campo + "}";
   }
   ```

4. **Para enumerações**:
   ```java
   @Override
   public String toString() {
       return name().toLowerCase(); // Formato customizado
   }
   ```

5. **Contrato oficial** (JavaDoc):
    - Deve retornar "texto representativo e informativo"
    - Recomendado sobrescrever para todas as classes

Este resumo cobre desde os conceitos básicos até técnicas avançadas de implementação do `toString()`, incluindo melhores práticas e armadilhas comuns, conforme apresentado na aula.

[Voltar ao Índice](#indice)

---


## <a name="parte80">80 - 077 - Orientação Objetos - Modificador final pt 01 - Tipo primitivo</a>

# Resumo: Modificador `final` em Java - Tipos Primitivos

## 📌 Visão Geral
A aula aborda o uso do modificador `final` com tipos primitivos, que:
- Transforma a variável em uma constante (valor não pode ser alterado após inicialização)
- Deve ser inicializada no momento da declaração ou no construtor (para variáveis de instância)
- Pode melhorar a legibilidade e segurança do código

## 📋 Exemplos Básicos

### 1. Constante primitiva
```java
final double PI = 3.14159;  // Deve ser inicializada
// PI = 3.15;  // ❌ Erro de compilação (não pode reatribuir)
```

### 2. Parâmetro final
```java
void calcular(final int valor) {
    // valor = 10;  // ❌ Erro (parâmetro final não pode ser modificado)
    System.out.println(valor * 2);
}
```

## 🏗️ Exemplo Complexo (Uso em Contextos Diferentes)

### 1. Bloco de inicialização
```java
class Circulo {
    final double RAIO;
    
    {  // Bloco de inicialização
        RAIO = 10.0;  // OK (antes do construtor)
    }
}
```

### 2. Switch com final
```java
final int opcao = 2;
switch(opcao) {
    case 1: System.out.println("Opção 1"); break;
    case 2: System.out.println("Opção 2"); break;  // ✔️ Uso válido
}
```

### 3. Final em estruturas de controle
```java
for(final int i = 0; i < 5; i++) {  // ❌ i++ viola o final
    System.out.println(i);
}
```

## ✅ Melhores Práticas

1. **Nomes em MAIÚSCULAS** para constantes:
   ```java
   final int MAX_TENTATIVAS = 3;
   ```

2. **Inicialização no construtor** para variáveis de instância:
   ```java
   class Pagamento {
       final double VALOR;
       
       Pagamento(double v) {
           this.VALOR = v;  // OK no construtor
       }
   }
   ```

3. **Use final para parâmetros** quando não devem ser modificados:
   ```java
   void processar(final int codigo) { ... }
   ```

4. **Final + static** para constantes globais:
   ```java
   public static final double VELOCIDADE_LUZ = 299792458;
   ```

5. **Documente o propósito**:
   ```java
   /** Tempo máximo em segundos antes do timeout */
   final int TIMEOUT = 30;
   ```

## ❌ Piores Práticas (Evitar)

1. **Reatribuição disfarçada**:
   ```java
   final int[] nums = {1, 2, 3};
   nums[0] = 10;  // ❌ Permitido (mas enganoso)
   ```

2. **Final sem inicialização** (variáveis locais):
   ```java
   final int x;  // ❌ Erro se não for inicializada antes do uso
   ```

3. **Uso desnecessário** em variáveis efêmeras:
   ```java
   for(final int j = 0; j < 10; j++) {  // ❌ j não precisa ser final
       // ...
   }
   ```

4. **Confundir imutabilidade**:
   ```java
   final List<String> nomes = new ArrayList<>();
   nomes.add("Novo");  // ❌ Permitido (aponta para o mesmo objeto)
   ```

5. **Nomes enganosos**:
   ```java
   final int temp = 30;  // ❌ Parece variável, mas é constante
   ```

## 🔍 Observações Avançadas

1. **Performance**: Variáveis `final` podem ser otimizadas pelo JVM

2. **Thread-safe**: Valores `final` são visíveis para todas threads após construção

3. **Métodos locais**:
   ```java
   void metodo() {
       final int y;  // Pode ser inicializada depois
       if(condicao) {
           y = 10;
       } else {
           y = 20;
       }
   }
   ```

4. **Lambda expressions**:
   ```java
   final int z = 5;
   Runnable r = () -> System.out.println(z);  // Só funciona com final/effectively final
   ```

5. **Pattern Matching** (Java 17+):
   ```java
   if(obj instanceof final String s) {  // s é final
       System.out.println(s.toLowerCase());
   }
   ```

6. **Record** (Java 16+):
   ```java
   record Ponto(final int x, final int y) {}  // Campos já são implicitamente final
   ```


Este resumo cobre desde os usos básicos até aplicações avançadas do `final` com tipos primitivos, incluindo melhores práticas e armadilhas comuns, conforme apresentado na aula.

[Voltar ao Índice](#indice)

---


## <a name="parte81">81 - 078 - Orientação Objetos - Modificador final pt 02 - Tipo referência</a>

# Resumo: Modificador `final` com Tipos Referência em Java

## 📌 Visão Geral
A aula explora o comportamento do modificador `final` quando aplicado a tipos referência, destacando que:
- A referência torna-se constante (não pode apontar para outro objeto)
- O estado do objeto referenciado PODE ser modificado
- Aplicável a classes, atributos, parâmetros e variáveis locais

## 📋 Exemplos Básicos

### 1. Referência final a objeto mutável
```java
final List<String> lista = new ArrayList<>();
lista.add("Java");  // ✔️ Válido (modificação interna)
// lista = new LinkedList<>();  // ❌ Erro (reatribuição)
```

### 2. Parâmetro final
```java
void processar(final Pessoa pessoa) {
    pessoa.setNome("Novo");  // ✔️ Válido
    // pessoa = new Pessoa();  // ❌ Erro
}
```

## 🏗️ Exemplos Complexos

### 1. Padrão de Classe Imutável
```java
public final class Endereco {
    private final String rua;
    private final int numero;
    
    public Endereco(String rua, int numero) {
        this.rua = rua;
        this.numero = numero;
    }
    
    // Apenas getters
}
```

### 2. Coleção Defensiva
```java
public class Time {
    private final List<Jogador> jogadores;
    
    public Time(List<Jogador> jogadores) {
        this.jogadores = Collections.unmodifiableList(new ArrayList<>(jogadores));
    }
    
    public List<Jogador> getJogadores() {
        return jogadores; // Lista imutável
    }
}
```

## ✅ Melhores Práticas

1. **Para imutabilidade**:
   ```java
   private final List<String> dados = List.of("A", "B"); // Java 9+
   ```

2. **Documentação clara**:
   ```java
   /**
    * @final A referência não pode mudar, mas o objeto pode ser modificado
    */
   private final Configuracao config;
   ```

3. **Cópia defensiva**:
   ```java
   public MinhaClasse(final Map<String, Integer> valores) {
       this.valores = new HashMap<>(valores);
   }
   ```

4. **Classes utilitárias**:
   ```java
   public final class MathUtils {
       private MathUtils() {} // Previne instanciação
   }
   ```

## ❌ Piores Práticas (Evitar)

1. **Expor estado interno**:
   ```java
   public final class Caixa {
       private final List<Item> itens;
       
       public List<Item> getItens() {
           return itens; // ❌ Expõe lista mutável
       }
   }
   ```

2. **Assumir imutabilidade**:
   ```java
   final int[] valores = {1, 2, 3};
   valores[0] = 10; // ❌ Permitido (pode causar bugs)
   ```

3. **Uso redundante**:
   ```java
   public void salvar(final String texto) { // ❌ Desnecessário se não reatribuído
       arquivo.write(texto);
   }
   ```

4. **Vazamento de referência**:
   ```java
   public class Exemplo {
       final int x;
       
       public Exemplo() {
           this.x = 10;
           registrar(this); // ❌ 'this' vaza antes da inicialização completa
       }
   }
   ```

## 🔍 Técnicas Avançadas

1. **Classes seladas (Java 17+)**:
   ```java
   public sealed class Forma permits Circulo, Quadrado {}
   ```

2. **Records (Java 16+)**:
   ```java
   public record Pessoa(String nome, int idade) {} // Campos implicitamente final
   ```

3. **Métodos final**:
   ```java
   public class Pai {
       public final void metodo() {} // Não pode ser sobrescrito
   }
   ```

4. **VarHandle para atomicidade**:
   ```java
   private static final VarHandle CONTADOR;
   static {
       try {
           CONTADOR = MethodHandles.lookup().findVarHandle(...);
       } catch (Exception e) { ... }
   }
   ```

5. **Pattern Matching (Java 17+)**:
   ```java
   if(obj instanceof final String s) {
       System.out.println(s.toLowerCase());
   }
   ```


[Voltar ao Índice](#indice)

---


## <a name="parte82">82 - 079 - Orientação Objetos - Modificador final pt 03 - Classes e métodos</a>

# Resumo: Modificador `final` em Classes e Métodos Java

## 📌 Visão Geral
A aula explora o uso do modificador `final` em classes e métodos, destacando que:
- **Classes final**: Não podem ser estendidas/herdadas
- **Métodos final**: Não podem ser sobrescritos por subclasses
- Objetivos principais: segurança, design intencional e otimização

## 📋 Exemplos Básicos

### 1. Classe Final (Não pode ser herdada)
```java
public final class String { // Classe core do Java
    // implementação...
}

// class MinhaString extends String {} // ❌ Erro de compilação
```

### 2. Método Final (Não pode ser sobrescrito)
```java
class Pagamento {
    public final void processar() { // Bloqueia sobrescrita
        System.out.println("Processamento base");
    }
}

class PagamentoCartao extends Pagamento {
    // @Override public void processar() {} // ❌ Erro
}
```

## 🏗️ Exemplos Complexos

### 1. Padrão Template Method com final
```java
public abstract class TemplateProcessamento {
    // Método final que define o fluxo
    public final void executarFluxo() {
        iniciar();
        processar(); // Método abstrato
        finalizar();
    }
    
    protected abstract void processar(); // Hook method
    
    private void iniciar() { /* implementação */ }
    private void finalizar() { /* implementação */ }
}
```

### 2. Hierarquia de Classes Imutáveis
```java
public final class EnderecoImutavel {
    private final String rua;
    private final int numero;
    
    public EnderecoImutavel(String rua, int numero) {
        this.rua = rua;
        this.numero = numero;
    }
    // Apenas getters
}

// Não pode ser estendida (final)
```

## ✅ Melhores Práticas

1. **Use final para classes utilitárias**:
   ```java
   public final class MathUtils {
       private MathUtils() {} // Construtor privado
       public static double calcular(...) { ... }
   }
   ```

2. **Documente a intenção**:
   ```java
   /**
    * @final Esta classe não deve ser estendida
    * pois implementa algoritmo crítico
    */
   public final class AlgoritmoSeguro { ... }
   ```

3. **Combine com sealed classes (Java 17+)**:
   ```java
   public sealed class Forma permits Circulo, Quadrado { ... }
   ```

4. **Para métodos críticos**:
   ```java
   public class Autenticador {
       public final boolean validarCredenciais(...) { ... }
   }
   ```

5. **Em frameworks**:
   ```java
   public abstract class ServicoBase {
       public final void iniciar() { ... } // Fluxo fixo
   }
   ```

## ❌ Piores Práticas (Evitar)

1. **Usar final sem motivo**:
   ```java
   public final class ClasseQualquer {} // ❌ Sem razão clara
   ```

2. **Impedir extensibilidade útil**:
   ```java
   public final class MinhaLista {} // ❌ Pode limitar reuso
   ```

3. **Métodos final em classes abstratas**:
   ```java
   public abstract class Figura {
       public final void desenhar() { ... } // ❌ Contraditório
   }
   ```

4. **Quebrar LSP (Princípio de Substituição)**:
   ```java
   class Pai {
       public final void metodo() { ... }
   }
   class Filha extends Pai {
       // Não pode sobrescrever método necessário
   }
   ```

5. **Ignorar alternativas modernas**:
   ```java
   // Preferir:
   public sealed class Animal permits Cachorro, Gato {}
   // Em vez de:
   public final class Animal {}
   ```

## 🔍 Técnicas Avançadas

1. **Records (Java 16+)**:
   ```java
   public record Pessoa(String nome, int idade) {} 
   // Implicitamente final
   ```

2. **Enums com métodos final**:
   ```java
   public enum Nivel {
       BASIC {
           @Override final void show() { ... }
       };
       abstract void show();
   }
   ```

3. **Padrão Strategy com final**:
   ```java
   public final class PagamentoCredito implements EstrategiaPagamento {
       @Override public final void pagar() { ... }
   }
   ```

4. **Injeção de Dependência**:
   ```java
   @Service
   public final class ServicoEmail {
       // Garante que ninguém altere o comportamento
       public final void enviar(...) { ... }
   }
   ```

5. **Classes de Utilidade**:
   ```java
   public final class Strings {
       private Strings() {}
       public static boolean isBlank(String s) { ... }
   }
   ```


[Voltar ao Índice](#indice)

---


## <a name="parte83">83 - 080 - Orientação Objetos - Enumeração pt 01 - Introdução</a>

```java
package dominio;

public enum dominio.TipoCliente {
    PESSOA_FISCA, PESSOA_JURIDICA
}

```

```java
import dominio.TipoCliente;

public class Cliente {
    private String nome;
    private TipoCliente tipoCliente;

    public Cliente(String nome, TipoCliente tipoCliente) {
        this.nome = nome;
        this.tipoCliente = tipoCliente;
    }

```

```java
import dominio.TipoCliente;

public class ClienteTeste01 {
    public static void main(String[] args) {
        Cliente cliente1 = new Cliente("Tsubasa", TipoCliente.PESSOA_FISCA);
        Cliente cliente2 = new Cliente("Tsubasa", TipoCliente.PESSOA_JURIDICA);
        Cliente cliente3 = new Cliente("Tsubasa", TipoCliente.PESSOA_FISCA);
        Cliente cliente4 = new Cliente("Tsubasa", TipoCliente.PESSOA_JURIDICA);

```

---

Resumo GEMINI

## Resumo sobre Enumerações (Enums) em Java ☕

Enumerações em Java (declaradas com a palavra-chave `enum`) são um tipo de dado especial usado para definir um conjunto de **constantes nomeadas**. Elas são muito úteis quando você tem um número fixo de valores que uma variável pode assumir, como dias da semana, naipes de um baralho, ou estados de um pedido.

Em essência, um `enum` é uma **classe especial**. Os valores definidos em um `enum` são **instâncias** dessa classe `enum`. Isso significa que `enums` podem ter construtores, campos (variáveis) e métodos, tornando-os muito mais poderosos do que as constantes estáticas (`public static final`) tradicionais.

---

### Exemplos de Código

#### Exemplo Básico: Dias da Semana

```java
public enum DiaSemana {
    DOMINGO,
    SEGUNDA,
    TERCA,
    QUARTA,
    QUINTA,
    SEXTA,
    SABADO
}

public class TesteEnumBasico {
    public static void main(String[] args) {
        DiaSemana hoje = DiaSemana.SEXTA;
        System.out.println("Hoje é: " + hoje); // Saída: Hoje é: SEXTA

        // Iterando sobre os valores do enum
        System.out.println("\nDias da semana:");
        for (DiaSemana dia : DiaSemana.values()) {
            System.out.println(dia);
        }

        // Usando enum em um switch
        switch (hoje) {
            case SEGUNDA:
                System.out.println("\nComeço da semana de trabalho.");
                break;
            case SEXTA:
                System.out.println("\nSextou!");
                break;
            default:
                System.out.println("\nUm dia qualquer.");
        }
    }
}
```

#### Exemplo Complexo: Planetas com Atributos e Métodos

Neste exemplo, cada constante do `enum` `Planeta` terá atributos (massa e raio) e um método para calcular a gravidade superficial.

```java
public enum Planeta {
    MERCURIO (3.303e+23, 2.4397e6),
    VENUS    (4.869e+24, 6.0518e6),
    TERRA    (5.976e+24, 6.37814e6),
    MARTE    (6.421e+23, 3.3972e6),
    JUPITER  (1.9e+27,   7.1492e7),
    SATURNO  (5.688e+26, 6.0268e7),
    URANO    (8.686e+25, 2.5559e7),
    NETUNO   (1.024e+26, 2.4746e7);

    private final double massa;   // em quilogramas
    private final double raio;    // em metros
    public static final double G = 6.67300E-11; // Constante gravitacional

    Planeta(double massa, double raio) {
        this.massa = massa;
        this.raio = raio;
    }

    public double getMassa() {
        return massa;
    }

    public double getRaio() {
        return raio;
    }

    public double gravidadeSuperficial() {
        return G * massa / (raio * raio);
    }

    public double pesoSuperficial(double outraMassa) {
        return outraMassa * gravidadeSuperficial();
    }
}

public class TesteEnumComplexo {
    public static void main(String[] args) {
        double pesoNaTerra = 75.0; // kg

        for (Planeta p : Planeta.values()) {
            System.out.printf("Seu peso em %s é %.2f N%n",
                              p, p.pesoSuperficial(pesoNaTerra));
            System.out.printf("A gravidade superficial de %s é %.2f m/s^2%n%n",
                              p, p.gravidadeSuperficial());
        }

        Planeta meuPlaneta = Planeta.TERRA;
        System.out.println("Meu planeta: " + meuPlaneta);
        System.out.println("Massa do meu planeta: " + meuPlaneta.getMassa() + " kg");
    }
}
```

---

### Melhores Práticas (O que fazer 👍)

1.  **Use `enums` em vez de constantes `int` ou `String`**: `Enums` fornecem segurança de tipo (type safety). Com constantes `int`, você pode acidentalmente passar um valor inválido. `Enums` garantem que apenas os valores definidos sejam usados.
    ```java
    // Ruim: usando constantes int
    public static final int ESTADO_PENDENTE = 0;
    public static final int ESTADO_APROVADO = 1;
    public static final int ESTADO_REJEITADO = 2;
    // void processarPedido(int estado) { ... }

    // Bom: usando enum
    public enum EstadoPedido { PENDENTE, APROVADO, REJEITADO }
    // void processarPedido(EstadoPedido estado) { ... }
    ```
2.  **Nomeie as constantes `enum` em MAIÚSCULAS**: Por convenção, constantes em Java (incluindo valores de `enum`) são nomeadas com todas as letras maiúsculas, com palavras separadas por underscores (`_`).
    ```java
    public enum Cor { VERMELHO, VERDE_ESCURO, AZUL_CELESTE }
    ```
3.  **Use `enums` em instruções `switch`**: `Enums` funcionam muito bem com `switch`, tornando o código mais legível.
    ```java
    Nivel prioridade = Nivel.ALTO;
    switch (prioridade) {
        case BAIXO:
            System.out.println("Prioridade baixa.");
            break;
        case MEDIO:
            System.out.println("Prioridade média.");
            break;
        case ALTO:
            System.out.println("Prioridade alta.");
            break;
    }
    ```
4.  **Adicione campos e métodos aos `enums` quando necessário**: Como mostrado no exemplo `Planeta`, `enums` podem ter construtores, campos e métodos, permitindo que você associe dados e comportamento a cada constante. O construtor de um `enum` deve ser `private` ou package-private (o padrão).
5.  **Use `EnumSet` e `EnumMap` para coleções de `enums`**: Se você precisa de um `Set` ou `Map` cujas chaves são `enums`, `EnumSet` e `EnumMap` são implementações altamente otimizadas.
    ```java
    import java.util.EnumSet;
    import java.util.EnumMap;
    import java.util.Map;

    public enum DiaUtil { SEGUNDA, TERCA, QUARTA, QUINTA, SEXTA }

    // EnumSet
    EnumSet<DiaUtil> diasDeTrabalho = EnumSet.of(DiaUtil.SEGUNDA, DiaUtil.TERCA, DiaUtil.QUARTA);

    // EnumMap
    EnumMap<DiaUtil, String> tarefas = new EnumMap<>(DiaUtil.class);
    tarefas.put(DiaUtil.SEGUNDA, "Reunião de planejamento");
    ```
6.  **Implemente interfaces com `enums`**: `Enums` podem implementar interfaces, permitindo que você trate diferentes `enums` de forma polimórfica.
    ```java
    public interface Mensageiro {
        String getMensagemFormatada();
    }

    public enum TipoNotificacao implements Mensageiro {
        EMAIL {
            @Override
            public String getMensagemFormatada() { return "Email: "; }
        },
        SMS {
            @Override
            public String getMensagemFormatada() { return "SMS: "; }
        };
    }
    ```
7.  **Prefira `==` para comparar `enums`**: Como `enums` são instâncias únicas (singletons), você pode usar o operador `==` para compará-los com segurança e eficiência. `equals()` também funciona e faz a mesma coisa para `enums`.
    ```java
    DiaSemana dia1 = DiaSemana.SEGUNDA;
    DiaSemana dia2 = DiaSemana.SEGUNDA;
    if (dia1 == dia2) { // true
        System.out.println("São o mesmo dia.");
    }
    ```

---

### Piores Práticas (O que evitar 👎)

1.  **Não use `ordinal()` para lógica de negócios**: O método `ordinal()` retorna a posição de uma constante `enum` em sua declaração (começando em 0). Confiar nesse valor é perigoso, pois se a ordem das constantes mudar, seu código quebrará. Se precisar de um valor associado, adicione um campo ao `enum`.
    ```java
    public enum Prioridade {
        BAIXA, // ordinal() == 0
        MEDIA, // ordinal() == 1
        ALTA   // ordinal() == 2
    }

    // Ruim:
    // if (prioridade.ordinal() == 0) { ... }

    // Bom (se precisar de um valor numérico associado):
    public enum PrioridadeComValor {
        BAIXA(1),
        MEDIA(5),
        ALTA(10);

        private final int valor;
        PrioridadeComValor(int valor) { this.valor = valor; }
        public int getValor() { return valor; }
    }
    // if (prioridade.getValor() == 1) { ... }
    ```
2.  **Evite `enums` muito grandes ou com responsabilidades demais**: Se um `enum` começa a ficar muito complexo, com muitos métodos ou lógica que não está diretamente relacionada às suas constantes, pode ser um sinal de que você precisa refatorar para classes separadas.
3.  **Não tente estender um `enum`**: `Enums` implicitamente herdam de `java.lang.Enum` e não podem herdar de outra classe. (Eles podem, no entanto, implementar interfaces).
4.  **Evite expor construtores públicos**: Construtores de `enum` devem ser `private` (ou package-private). O compilador os chama automaticamente para criar as instâncias das constantes definidas. Você não deve instanciar `enums` com `new`.
5.  **Cuidado ao serializar `enums` que mudam frequentemente**: Se você serializa um `enum` e depois adiciona, remove ou reordena constantes, pode ter problemas de desserialização. Usar nomes (`toString()`) para persistência em vez de ordinais pode ser mais robusto, mas ainda requer cuidado. Se os valores associados (como IDs para banco de dados) são importantes, defina-os explicitamente.
6.  **Não use `enums` para substituir qualquer conjunto de constantes**: Se as "constantes" podem mudar dinamicamente ou se há um número ilimitado delas, um `enum` não é a escolha apropriada. `Enums` são para conjuntos *fixos* de valores conhecidos em tempo de compilação.

Lembre-se que o objetivo principal dos `enums` é melhorar a legibilidade e a segurança do tipo do seu código, representando um conjunto fixo de constantes de forma clara e robusta.


[Voltar ao Índice](#indice)

---


## <a name="parte84">84 - 081 - Orientação Objetos - Enumeração pt 02 - Construtores e atributos</a>

```java
package dominio;

public enum TipoCliente {
    PESSOA_FISICA(1, "Pessoa Fisica"),
    PESSOA_JURIDICA(2, "Pessoa Juridica");

    private int valor;
    public String nomeRelatorio;

    TipoCliente(int valor, String nomeRelatorio) {
        this.valor = valor;
        this.nomeRelatorio = nomeRelatorio;
    }

    public int getValor() {
        return valor;
    }

    public String getNomeRelatorio() {
        return nomeRelatorio;
    }
}

```

```java
package dominio;

public class Cliente {

    public enum TipoPagamento {
        DEBITO,
        CREDITO
    }

    private String nome;
    private TipoCliente tipoCliente;
    private TipoPagamento tipoPagamento;

    public Cliente(String nome, TipoCliente tipoCliente, TipoPagamento tipoPagamento) {
        this.nome = nome;
        this.tipoCliente = tipoCliente;
        this.tipoPagamento = tipoPagamento;
    }

    @Override
    public String toString() {
        return "Cliente{" +
                "nome='" + nome + '\'' +
                ", tipoCliente=" + tipoCliente +
                ", tipoClienteValor=" + tipoCliente.getValor() +
                ", tipoClienteNomeRelatorio=" + tipoCliente.getNomeRelatorio() +
                ", tipoPagamento=" + tipoPagamento +
                '}';
    }
}

```

--

### RESUMO DA GEMINI

## Construtores e Atributos em Enumerações Java ☕

Continuando o estudo de `enums` em Java, esta parte foca em como adicionar **construtores e atributos** às suas enumerações, tornando-as ainda mais poderosas e capazes de armazenar dados e comportamentos específicos para cada constante.

Quando você define atributos em um `enum`, cada constante da enumeração pode ter seus próprios valores para esses atributos. Esses valores são tipicamente passados através de um **construtor**, que é chamado automaticamente quando cada constante do `enum` é criada.

---

### Pontos Principais: Construtores e Atributos em Enums

1.  **Atributos (Campos)**:
    * Você pode declarar campos (variáveis de instância) dentro de um `enum`, assim como faria em uma classe normal.
    * Esses campos geralmente são `private` e `final` para garantir que os dados associados a cada constante do `enum` sejam imutáveis após a criação.

2.  **Construtores**:
    * Construtores em `enums` são sempre **`private`** (ou package-private, o padrão, mas `private` é a convenção mais forte). Você não pode declarar um construtor de `enum` como `public` ou `protected`.
    * O construtor é chamado uma vez para cada constante definida no `enum` no momento em que a classe do `enum` é carregada.
    * Você não chama o construtor do `enum` explicitamente com `new`; o compilador faz isso por você quando encontra as declarações das constantes.
    * Se você definir um construtor com parâmetros, deverá fornecer os argumentos para esses parâmetros ao declarar cada constante do `enum`.

3.  **Métodos**:
    * Você pode adicionar métodos ao `enum` para operar sobre os atributos ou fornecer funcionalidades relacionadas às constantes. Por exemplo, métodos `getter` são comuns para acessar os valores dos atributos.

---

### Exemplos de Código

#### Exemplo Básico: Tipo de Cliente com Código

```java
public enum TipoCliente {
    PESSOA_FISICA(1, "Pessoa Física"), // Chama o construtor TipoCliente(1, "Pessoa Física")
    PESSOA_JURIDICA(2, "Pessoa Jurídica"); // Chama o construtor TipoCliente(2, "Pessoa Jurídica")

    private final int codigo;
    private final String descricao;

    // Construtor é implicitamente private
    TipoCliente(int codigo, String descricao) {
        this.codigo = codigo;
        this.descricao = descricao;
    }

    public int getCodigo() {
        return codigo;
    }

    public String getDescricao() {
        return descricao;
    }

    // Opcional: sobrescrever toString para uma representação mais amigável
    @Override
    public String toString() {
        return codigo + " - " + descricao;
    }
}

public class TesteTipoCliente {
    public static void main(String[] args) {
        TipoCliente pf = TipoCliente.PESSOA_FISICA;
        System.out.println("Tipo: " + pf.name()); // Saída: PESSOA_FISICA
        System.out.println("Código: " + pf.getCodigo()); // Saída: 1
        System.out.println("Descrição: " + pf.getDescricao()); // Saída: Pessoa Física
        System.out.println("Representação: " + pf); // Saída: 1 - Pessoa Física (devido ao toString)

        TipoCliente pj = TipoCliente.PESSOA_JURIDICA;
        System.out.println("\nTipo: " + pj.name()); // Saída: PESSOA_JURIDICA
        System.out.println("Código: " + pj.getCodigo()); // Saída: 2
        System.out.println("Descrição: " + pj.getDescricao()); // Saída: Pessoa Jurídica
        System.out.println("Representação: " + pj); // Saída: 2 - Pessoa Jurídica

        // Obtendo um enum pelo nome (útil para deserialização ou input de usuário)
        String tipoInput = "PESSOA_FISICA";
        TipoCliente tipoEncontrado = TipoCliente.valueOf(tipoInput);
        System.out.println("\nEncontrado pelo nome: " + tipoEncontrado.getDescricao());
    }
}
```

#### Exemplo Mais Elaborado: Status de Pagamento com Lógica

```java
public enum StatusPagamento {
    PENDENTE(1, "Aguardando Pagamento") {
        @Override
        public boolean podeCancelar() {
            return true;
        }
        @Override
        public String proximoPassoPossivel() {
            return "Realizar pagamento ou cancelar.";
        }
    },
    PAGO(2, "Pagamento Confirmado") {
        @Override
        public boolean podeCancelar() {
            return false; // Não pode cancelar após pago, talvez estornar
        }
        @Override
        public String proximoPassoPossivel() {
            return "Aguardar envio do produto.";
        }
    },
    CANCELADO(3, "Pagamento Cancelado") {
        @Override
        public boolean podeCancelar() {
            return false;
        }
        @Override
        public String proximoPassoPossivel() {
            return "Nenhuma ação pendente.";
        }
    },
    ESTORNADO(4, "Pagamento Estornado") {
        @Override
        public boolean podeCancelar() {
            return false;
        }
        @Override
        public String proximoPassoPossivel() {
            return "Nenhuma ação pendente.";
        }
    }; // Ponto e vírgula aqui é OBRIGATÓRIO se houver métodos ou campos após as constantes

    private final int id;
    private final String textoDisplay;

    // Construtor (private por padrão)
    StatusPagamento(int id, String textoDisplay) {
        this.id = id;
        this.textoDisplay = textoDisplay;
    }

    public int getId() {
        return id;
    }

    public String getTextoDisplay() {
        return textoDisplay;
    }

    // Métodos abstratos para serem implementados por cada constante (corpo específico da constante)
    public abstract boolean podeCancelar();
    public abstract String proximoPassoPossivel();

    // Método comum a todos
    public void imprimirStatusDetalhado() {
        System.out.println("Status: " + getTextoDisplay() + " (ID: " + getId() + ")");
        System.out.println("  Pode cancelar? " + (podeCancelar() ? "Sim" : "Não"));
        System.out.println("  Próximo passo: " + proximoPassoPossivel());
    }
}

public class TesteStatusPagamento {
    public static void main(String[] args) {
        StatusPagamento status1 = StatusPagamento.PENDENTE;
        status1.imprimirStatusDetalhado();
        /*
        Saída:
        Status: Aguardando Pagamento (ID: 1)
          Pode cancelar? Sim
          Próximo passo: Realizar pagamento ou cancelar.
        */

        System.out.println("---");

        StatusPagamento status2 = StatusPagamento.PAGO;
        status2.imprimirStatusDetalhado();
        /*
        Saída:
        Status: Pagamento Confirmado (ID: 2)
          Pode cancelar? Não
          Próximo passo: Aguardar envio do produto.
        */
    }
}
```
Neste exemplo `StatusPagamento`, cada constante do `enum` não só tem seus próprios valores para `id` e `textoDisplay`, mas também fornece uma implementação específica para os métodos abstratos `podeCancelar()` e `proximoPassoPossivel()`. Isso é chamado de **corpo específico da constante** (constant-specific body).

---

### Melhores Práticas (O que fazer 👍)

1.  **Declare atributos como `private final`**: Isso garante que os dados associados a cada constante sejam imutáveis e encapsulados.
2.  **Forneça `getters` para os atributos**: Se os atributos precisam ser acessados de fora do `enum`, forneça métodos `public getter`. Evite `setters` para manter a imutabilidade.
3.  **Mantenha construtores `private`**: Isso é imposto pelo Java para `enums`, mas é uma boa prática reforçar que `enums` não são instanciados como classes normais.
4.  **Use o ponto e vírgula (`;`) após a lista de constantes se houver membros subsequentes**: Se o seu `enum` tem apenas constantes, o ponto e vírgula é opcional. Mas se você adicionar campos, métodos ou construtores, o ponto e vírgula após a última constante é obrigatório.
    ```java
    public enum Opcao {
        SIM, NAO; // Ponto e vírgula obrigatório aqui se adicionar mais membros

        // Exemplo: um método
        public boolean isAfirmativo() {
            return this == SIM;
        }
    }
    ```
5.  **Sobrescreva `toString()` para representações amigáveis**: Por padrão, `toString()` retorna o nome da constante (ex: "PESSOA_FISICA"). Se uma representação mais legível para o usuário ou para logs for necessária, sobrescreva `toString()`.
6.  **Use corpos específicos de constante (Constant-Specific Bodies) para comportamento variado**: Se diferentes constantes do `enum` precisam se comportar de maneiras ligeiramente diferentes para o mesmo método, você pode declarar o método (possivelmente abstrato) no `enum` e fazer com que cada constante o sobrescreva. Isso é uma forma poderosa de polimorfismo dentro de um `enum`.

---

### Piores Práticas (O que evitar 👎)

1.  **Atributos mutáveis**: Evite atributos que não sejam `final`, pois isso quebra a ideia de que as constantes do `enum` são, de fato, constantes e imutáveis.
    ```java
    // Ruim: atributo mutável
    public enum Nivel {
        BAIXO(1), MEDIO(2), ALTO(3);
        public int valor; // Não final, e público!
        Nivel(int v) { this.valor = v; }
    }
    ```
2.  **Construtores `public` ou `protected`**: O compilador não permite isso, mas a tentativa indica um mal-entendido de como `enums` são instanciados.
3.  **Confiar em `ordinal()` quando atributos podem fazer o trabalho**: Se você precisa de um valor numérico ou outro dado associado a uma constante, defina um atributo para isso em vez de depender da ordem de declaração (`ordinal()`).
4.  **Sobrecarga de responsabilidades**: Não transforme um `enum` em uma classe massiva com inúmeros atributos e métodos complexos que poderiam ser melhor gerenciados por classes dedicadas. `Enums` são para representar um conjunto fixo de constantes relacionadas, com dados e comportamentos associados a *essas constantes*.
5.  **Esquecer o ponto e vírgula (`;`)** quando necessário: Se o `enum` contém qualquer coisa além das próprias constantes (campos, métodos, construtores), você deve terminar a lista de constantes com um ponto e vírgula. A falta dele causará um erro de compilação.

Ao usar construtores e atributos, os `enums` em Java se tornam uma ferramenta muito expressiva para modelar tipos de dados que representam um conjunto fixo de valores, cada um com suas próprias características e comportamentos.

[Voltar ao Índice](#indice)

---


## <a name="parte85">85 - 082 - Orientação Objetos - Enumeração pt 03 - Sobrescrita de métodos</a>

```java
package dominio;

public enum TipoPagamento {
    DEBITO{
        @Override
        public double calculaDesconto(double valor) {
            return valor * 0.1;

        }
    },
    CREDITO{
        @Override
        public double calculaDesconto(double valor) {
            return valor * 0.5;
        }
    };
    public abstract double calculaDesconto(double valor) ;
}
```

```java
        System.out.println(TipoPagamento.DEBITO.calculaDesconto(100));
        System.out.println(TipoPagamento.CREDITO.calculaDesconto(100));
```

---

### RESUMO GEMINI

## Sobrescrita de Métodos em Enumerações Java ☕

A capacidade de **sobrescrever métodos** em `enums` em Java adiciona uma camada significativa de flexibilidade e poder, permitindo que cada constante da enumeração tenha comportamentos específicos. Isso é particularmente útil quando diferentes constantes precisam reagir de maneiras distintas a uma mesma chamada de método.

Existem duas formas principais de sobrescrita de métodos em `enums`:

1.  **Sobrescrever métodos da classe `java.lang.Enum` (ou `Object`)**: O mais comum é sobrescrever o método `toString()` para fornecer uma representação textual mais amigável da constante do `enum`.
2.  **Corpos de Método Específicos da Constante (Constant-Specific Method Bodies)**: Você pode declarar um método (concreto ou abstrato) no `enum` e, em seguida, fornecer uma implementação diferente para esse método dentro de cada constante específica. Isso permite um comportamento polimórfico dentro do próprio `enum`.

---

### Pontos Principais: Sobrescrita de Métodos em Enums

* **Sobrescrevendo `toString()`**: Por padrão, `toString()` retorna o nome da constante como declarado (ex: `SEGUNDA_FEIRA`). Você pode sobrescrevê-lo para retornar algo mais descritivo ou formatado.
* **Métodos Abstratos no Enum**: Você pode declarar métodos abstratos dentro do seu `enum`. Se fizer isso, cada constante do `enum` **deve** fornecer uma implementação para esses métodos abstratos. Isso força cada constante a definir seu próprio comportamento.
* **Métodos Concretos com Implementação Específica da Constante**: Você pode ter um método concreto no `enum` com uma implementação padrão e, opcionalmente, sobrescrevê-lo para constantes específicas que necessitem de um comportamento diferente.
* **Sintaxe**: Para fornecer uma implementação específica da constante, você abre chaves `{}` após a declaração da constante e implementa o método ali. É necessário um ponto e vírgula (`;`) após a última constante se o `enum` contiver campos, métodos ou construtores adicionais.

---

### Exemplos de Código

#### Exemplo Básico: Sobrescrevendo `toString()`

```java
public enum DiaDaSemana {
    DOMINGO("Domingo"),
    SEGUNDA("Segunda-feira"),
    TERCA("Terça-feira"),
    QUARTA("Quarta-feira"),
    QUINTA("Quinta-feira"),
    SEXTA("Sexta-feira"),
    SABADO("Sábado");

    private final String nomeFormatado;

    DiaDaSemana(String nomeFormatado) {
        this.nomeFormatado = nomeFormatado;
    }

    // Getter para o nome formatado (opcional, dependendo da necessidade)
    public String getNomeFormatado() {
        return nomeFormatado;
    }

    // Sobrescrevendo toString() para retornar o nomeFormatado
    @Override
    public String toString() {
        return nomeFormatado;
    }
}

public class TesteToStringEnum {
    public static void main(String[] args) {
        DiaDaSemana hoje = DiaDaSemana.SEXTA;
        System.out.println("Hoje é: " + hoje); // Saída: Hoje é: Sexta-feira
        System.out.println("Nome original da constante: " + hoje.name()); // Saída: Nome original da constante: SEXTA
        System.out.println("Nome formatado (via getter): " + hoje.getNomeFormatado()); // Saída: Nome formatado (via getter): Sexta-feira
    }
}
```

#### Exemplo Complexo: Operações Matemáticas com Implementações Específicas da Constante

Neste exemplo, cada constante do `enum` `Operacao` representa uma operação matemática e implementa um método abstrato `executar`.

```java
public enum Operacao {
    SOMA {
        @Override
        public double executar(double x, double y) {
            return x + y;
        }
        @Override
        public String getSimbolo() {
            return "+";
        }
    },
    SUBTRACAO {
        @Override
        public double executar(double x, double y) {
            return x - y;
        }
        @Override
        public String getSimbolo() {
            return "-";
        }
    },
    MULTIPLICACAO {
        @Override
        public double executar(double x, double y) {
            return x * y;
        }
        @Override
        public String getSimbolo() {
            return "*";
        }
    },
    DIVISAO {
        @Override
        public double executar(double x, double y) {
            if (y == 0) {
                throw new ArithmeticException("Divisão por zero!");
            }
            return x / y;
        }
        @Override
        public String getSimbolo() {
            return "/";
        }
    }; // Ponto e vírgula obrigatório aqui

    // Método abstrato que cada constante deve implementar
    public abstract double executar(double x, double y);
    public abstract String getSimbolo(); // Outro método abstrato para o símbolo da operação

    // Método concreto que pode usar os métodos específicos da constante
    public void exibirCalculo(double x, double y) {
        try {
            System.out.printf("%.2f %s %.2f = %.2f%n", x, getSimbolo(), y, executar(x, y));
        } catch (ArithmeticException e) {
            System.err.println("Erro ao calcular " + x + " " + getSimbolo() + " " + y + ": " + e.getMessage());
        }
    }
}

public class TesteOperacaoEnum {
    public static void main(String[] args) {
        double x = 10.0;
        double y = 5.0;

        Operacao.SOMA.exibirCalculo(x, y);         // Saída: 10.00 + 5.00 = 15.00
        Operacao.SUBTRACAO.exibirCalculo(x, y);    // Saída: 10.00 - 5.00 = 5.00
        Operacao.MULTIPLICACAO.exibirCalculo(x, y); // Saída: 10.00 * 5.00 = 50.00
        Operacao.DIVISAO.exibirCalculo(x, y);      // Saída: 10.00 / 5.00 = 2.00
        Operacao.DIVISAO.exibirCalculo(x, 0);      // Saída: Erro ao calcular 10.0 / 0.0: Divisão por zero!

        System.out.println("\nIterando e executando:");
        for (Operacao op : Operacao.values()) {
            System.out.printf("Resultado de 8 %s 2: %.2f%n", op.getSimbolo(), op.executar(8, 2));
        }
    }
}
```

---

### Melhores Práticas (O que fazer 👍)

1.  **Sobrescreva `toString()` para clareza**: Se a representação padrão do nome da constante não for ideal para logs ou interface do usuário, forneça uma sobrescrita de `toString()`.
2.  **Use métodos abstratos para forçar implementações específicas**: Se cada constante *deve* ter um comportamento único para um determinado método, declare o método como `abstract` no `enum`. Isso garante que todas as constantes forneçam sua própria lógica.
3.  **Utilize corpos específicos da constante para variar comportamento**: Esta é uma maneira elegante de implementar o padrão Strategy ou State dentro de um `enum`. Cada constante se torna uma "estratégia" ou "estado" com seu próprio comportamento.
4.  **Mantenha a lógica coesa**: A lógica dentro dos métodos específicos da constante deve estar relacionada à responsabilidade daquela constante. Se ficar muito complexa, pode ser um sinal de que o `enum` está fazendo demais.
5.  **Ponto e vírgula obrigatório**: Lembre-se do ponto e vírgula (`;`) após a última declaração de constante se o `enum` contiver quaisquer membros (campos, métodos, construtores, ou corpos específicos da constante).
6.  **Combine com atributos**: Atributos podem ser usados em conjunto com métodos sobrescritos para fornecer dados que influenciam o comportamento específico da constante.

---

### Piores Práticas (O que evitar 👎)

1.  **Sobrescrita excessiva e desnecessária**: Não sobrescreva métodos apenas por sobrescrever. Se o comportamento padrão (herdado de `Enum` ou `Object`) é suficiente, ou se um método concreto no `enum` atende a todas as constantes, não há necessidade de implementações específicas.
2.  **Lógica muito complexa dentro de corpos específicos de constante**: Se a implementação de um método para uma constante se torna muito longa ou envolve muitas dependências, pode ser um indicativo de que essa lógica deveria estar em uma classe separada, e o `enum` poderia delegar a ela. O objetivo é manter o `enum` coeso.
3.  **Ignorar a necessidade de métodos abstratos**: Se você se encontrar verificando qual é a constante atual com `if/else` ou `switch` dentro de um método do `enum` para então executar lógicas diferentes, provavelmente você deveria estar usando um método abstrato (ou um método concreto com sobrescritas específicas da constante).
    ```java
    // Ruim: Usar switch dentro de um método do enum
    public enum TipoArquivo {
        TEXTO, BINARIO, IMAGEM;

        public String getDescricao() {
            switch (this) { // Evite isso dentro do enum!
                case TEXTO: return "Arquivo de texto simples";
                case BINARIO: return "Arquivo de dados binários";
                case IMAGEM: return "Arquivo de imagem";
                default: throw new AssertionError();
            }
        }
    }

    // Bom: Usar método abstrato ou sobrescrita
    public enum TipoArquivoMelhorado {
        TEXTO {
            @Override
            public String getDescricao() { return "Arquivo de texto simples"; }
        },
        BINARIO {
            @Override
            public String getDescricao() { return "Arquivo de dados binários"; }
        },
        IMAGEM {
            @Override
            public String getDescricao() { return "Arquivo de imagem"; }
        };
        public abstract String getDescricao();
    }
    ```
4.  **Esquecer o ponto e vírgula (`;`)**: Um erro comum que leva a erros de compilação quando se adiciona qualquer membro após as constantes do `enum`.
5.  **Tentar sobrescrever métodos `final` da classe `Enum`**: Métodos como `ordinal()`, `name()`, `compareTo()`, `equals()`, `hashCode()`, e `getDeclaringClass()` são `final` em `java.lang.Enum` e não podem ser sobrescritos (exceto `toString()`, que é de `Object`).

A sobrescrita de métodos, especialmente com corpos específicos da constante, transforma `enums` de simples listas de nomes em tipos de dados altamente especializados e comportamentais, promovendo um código mais limpo e orientado a objetos.

[Voltar ao Índice](#indice)

---


## <a name="parte86">86 - 083 - Orientação Objetos - Enumeração pt 04 - Busca por atributos</a>

```java
package dominio;

public enum TipoCliente {
    PESSOA_FISICA(1, "Pessoa Fisica"),
    PESSOA_JURIDICA(2, "Pessoa Juridica");

    private int valor;
    public String nomeRelatorio;

    TipoCliente(int valor, String nomeRelatorio) {
        this.valor = valor;
        this.nomeRelatorio = nomeRelatorio;
    }

    public static TipoCliente tipoClientePorNomeRelatorio(String nomeRelatorio) {
        for (TipoCliente tipoCliente : values()) {
            if (tipoCliente.getNomeRelatorio().equals(nomeRelatorio)) {
                return tipoCliente;
            }
        }
        return null;
```

```java
        TipoCliente tipoCliente1 = TipoCliente.valueOf("PESSOA_FISICA");
        System.out.println(tipoCliente1);

        TipoCliente tipoCliente2 = TipoCliente.tipoClientePorNomeRelatorio("PESSOA_FISICA");
        System.out.println(tipoCliente2);

```


--- 

### Resumo GEMINI

Entendido! O tema agora é "Busca por atributos" em `enums` Java. Isso é super útil quando você tem um `enum` com atributos e precisa encontrar uma constante específica baseada no valor de um desses atributos (por exemplo, obter um `StatusPedido` a partir de um código numérico que veio de um banco de dados ou de uma API).

A ideia principal é criar um método estático dentro do seu `enum` que permita essa busca.

---
## Busca por Atributos em Enumerações Java 🔎

Quando suas enumerações Java possuem atributos, frequentemente surge a necessidade de obter uma constante específica do `enum` com base no valor de um desses atributos. Por exemplo, você pode ter um `enum` `StatusPedido` com um atributo `codigo`, e precisar encontrar o `StatusPedido` que corresponde a um `codigo` recebido de uma fonte externa.

A abordagem mais comum e recomendada é implementar um **método estático** dentro do próprio `enum` que itere sobre as constantes (usando o método `values()`) e compare o atributo desejado. Para otimizar buscas em `enums` com muitas constantes, pode-se usar um `Map` estático para um lookup mais rápido.

---

### Pontos Principais: Busca por Atributos

1.  **Necessidade**: Surge quando você tem um valor (ex: um ID, um código, uma string descritiva) e precisa encontrar a constante do `enum` que possui esse valor em um de seus atributos.
2.  **Método `values()`**: O método `values()`, implicitamente disponível em todos os `enums`, retorna um array contendo todas as constantes do `enum` na ordem em que foram declaradas. Este array pode ser iterado para realizar a busca.
3.  **Método Estático de Busca**: É uma convenção criar um método `public static` (por exemplo, `getByCodigo(int codigo)`, `fromString(String texto)`, etc.) dentro do `enum` para encapsular a lógica de busca.
4.  **Tratamento de Não Encontrado**: O método de busca deve definir como lidar com casos onde nenhuma constante corresponde ao valor fornecido (retornar `null`, lançar uma exceção como `IllegalArgumentException`, ou retornar um valor padrão).
5.  **Otimização com `Map` (para `enums` grandes)**: Se o `enum` tiver muitas constantes e a performance da busca for crítica, pode-se inicializar um `Map` estático no `enum` que mapeia o valor do atributo para a constante. Isso oferece uma busca O(1).

---

### Exemplos de Código

#### Exemplo Básico: Buscando Tipo de Pagamento por Código

```java
public enum TipoPagamento {
    BOLETO(1, "Boleto Bancário"),
    CARTAO_CREDITO(2, "Cartão de Crédito"),
    PIX(3, "Pagamento Instantâneo (PIX)"),
    TRANSFERENCIA(4, "Transferência Bancária");

    private final int codigo;
    private final String descricao;

    TipoPagamento(int codigo, String descricao) {
        this.codigo = codigo;
        this.descricao = descricao;
    }

    public int getCodigo() {
        return codigo;
    }

    public String getDescricao() {
        return descricao;
    }

    // Método estático para buscar por código
    public static TipoPagamento getByCodigo(int codigo) {
        for (TipoPagamento tipo : values()) { // Itera sobre todas as constantes
            if (tipo.getCodigo() == codigo) {
                return tipo; // Retorna a constante encontrada
            }
        }
        // Lança uma exceção se o código não for encontrado
        throw new IllegalArgumentException("Código de tipo de pagamento inválido: " + codigo);
        // Alternativamente, poderia retornar null:
        // return null;
    }

    @Override
    public String toString() {
        return descricao;
    }
}

public class TesteBuscaEnum {
    public static void main(String[] args) {
        int codigoRecebido = 3; // Exemplo de código vindo de uma API, banco, etc.

        try {
            TipoPagamento tipo = TipoPagamento.getByCodigo(codigoRecebido);
            System.out.println("Código " + codigoRecebido + " corresponde a: " + tipo);
            // Saída: Código 3 corresponde a: Pagamento Instantâneo (PIX)

            TipoPagamento tipoInexistente = TipoPagamento.getByCodigo(99); // Código inválido
            System.out.println(tipoInexistente);

        } catch (IllegalArgumentException e) {
            System.err.println(e.getMessage());
            // Saída: Código de tipo de pagamento inválido: 99
        }

        // Exemplo retornando null (se o método getByCodigo fosse alterado)
        // TipoPagamento tipo2 = TipoPagamento.getByCodigo(99);
        // if (tipo2 == null) {
        //     System.out.println("Tipo de pagamento com código 99 não encontrado.");
        // }
    }
}
```

#### Exemplo Otimizado com `Map` Estático: Código de Moeda

Para `enums` com um número maior de constantes, ou quando a performance da busca é crítica.

```java
import java.util.Map;
import java.util.HashMap;
import java.util.Optional; // Para um retorno mais elegante de valor opcional

public enum Moeda {
    BRL("BRL", "Real Brasileiro", "R$"),
    USD("USD", "Dólar Americano", "$"),
    EUR("EUR", "Euro", "€"),
    GBP("GBP", "Libra Esterlina", "£"),
    JPY("JPY", "Iene Japonês", "¥");
    // ... imagine muitas outras moedas

    private final String codigoISO;
    private final String nome;
    private final String simbolo;

    // Mapa estático para lookup rápido pelo códigoISO
    private static final Map<String, Moeda> lookupPorCodigoISO = new HashMap<>();

    // Bloco estático para popular o mapa quando o enum é carregado
    static {
        for (Moeda m : values()) {
            lookupPorCodigoISO.put(m.getCodigoISO(), m);
        }
    }

    Moeda(String codigoISO, String nome, String simbolo) {
        this.codigoISO = codigoISO;
        this.nome = nome;
        this.simbolo = simbolo;
    }

    public String getCodigoISO() {
        return codigoISO;
    }

    public String getNome() {
        return nome;
    }

    public String getSimbolo() {
        return simbolo;
    }

    // Método de busca usando o Map (O(1) em média)
    public static Moeda getByCodigoISO(String codigoISO) {
        Moeda moeda = lookupPorCodigoISO.get(codigoISO.toUpperCase());
        if (moeda == null) {
            throw new IllegalArgumentException("Código ISO de moeda inválido: " + codigoISO);
        }
        return moeda;
    }

    // Alternativa usando Optional para evitar exceções ou null
    public static Optional<Moeda> findByCodigoISO(String codigoISO) {
        return Optional.ofNullable(lookupPorCodigoISO.get(codigoISO.toUpperCase()));
    }

    @Override
    public String toString() {
        return nome + " (" + simbolo + ")";
    }
}

public class TesteBuscaMoeda {
    public static void main(String[] args) {
        String codigo = "EUR";
        Moeda euro = Moeda.getByCodigoISO(codigo);
        System.out.println("Moeda encontrada: " + euro + ", Símbolo: " + euro.getSimbolo());
        // Saída: Moeda encontrada: Euro (€), Símbolo: €

        Optional<Moeda> ieneOpt = Moeda.findByCodigoISO("JPY");
        ieneOpt.ifPresent(moeda -> System.out.println("Moeda (Optional): " + moeda.getNome()));
        // Saída: Moeda (Optional): Iene Japonês

        Optional<Moeda> inexistenteOpt = Moeda.findByCodigoISO("XYZ");
        if (inexistenteOpt.isEmpty()) {
            System.out.println("Moeda XYZ não encontrada via Optional.");
            // Saída: Moeda XYZ não encontrada via Optional.
        }

        try {
            Moeda.getByCodigoISO("ABC");
        } catch (IllegalArgumentException e) {
            System.err.println(e.getMessage());
            // Saída: Código ISO de moeda inválido: ABC
        }
    }
}
```

---

### Melhores Práticas (O que fazer 👍)

1.  **Crie métodos estáticos de busca nomeados claramente**: Nomes como `getByCodigo()`, `fromValor()`, `valueOfLabel()` são mais descritivos do que um `valueOf()` sobrecarregado (que já existe para buscar pelo nome da constante).
2.  **Seja consistente no tratamento de não encontrados**: Escolha uma estratégia (lançar exceção, retornar `null`, ou retornar `Optional`) e aplique-a consistentemente. Lançar `IllegalArgumentException` é comum se o valor de entrada *deveria* corresponder a uma constante. Retornar `Optional<MeuEnum>` (Java 8+) é uma forma moderna e segura de lidar com valores que podem não existir.
3.  **Use um `Map` estático para `enums` grandes ou buscas frequentes**: Para melhorar a performance, pré-calcule um `Map` que mapeia o atributo de busca para a constante do `enum`. Isso é feito em um bloco de inicialização estático.
4.  **Torne os atributos do `enum` `final`**: Isso garante que os valores pelos quais você está buscando não mudem, mantendo a consistência do `Map` de lookup, se usado.
5.  **Considere a sensibilidade a maiúsculas/minúsculas (case sensitivity)**: Se estiver buscando por um atributo `String` (como um código ou descrição), decida se a busca deve ser case-sensitive ou não, e normalize a entrada e/ou os valores armazenados no `Map` (ex: usando `toUpperCase()` ou `toLowerCase()`).

---

### Piores Práticas (O que evitar 👎)

1.  **Expor a lógica de iteração fora do `enum`**: Clientes do `enum` não deveriam ter que escrever o loop `for (MeuEnum e : MeuEnum.values())` repetidamente. Encapsule essa lógica dentro de um método estático no próprio `enum`.
2.  **Depender de `ordinal()` para busca**: O `ordinal()` representa a posição de declaração e é frágil. Se a ordem mudar, a busca baseada em `ordinal()` quebrará. Sempre use um atributo explícito para a busca.
3.  **Modificar o `Map` de lookup após a inicialização**: Se você usar um `Map` estático para lookup, ele deve ser populado uma vez no bloco estático e depois tratado como imutável.
4.  **Não tratar o caso de valor não encontrado**: Se o método de busca simplesmente retornar `null` sem uma documentação clara ou se o código cliente não verificar o `null`, isso pode levar a `NullPointerExceptions`.
5.  **Performance ruim com `enums` muito grandes e buscas lineares frequentes**: Se um `enum` tem centenas de constantes e você está buscando por atributo em um loop `for` muitas vezes em uma seção crítica de performance, a inicialização de um `Map` estático é uma otimização importante a ser considerada.
6.  **Nomes de método de busca genéricos ou confusos**: Um método chamado `get(Object value)` pode ser ambíguo se o `enum` tiver múltiplos atributos pelos quais se poderia buscar.

Ao implementar métodos de busca por atributos, seus `enums` se tornam mais fáceis de usar e integrar com outras partes do sistema que podem não conhecer as constantes do `enum` diretamente, mas sim seus valores de atributo.

---

**Sim, para os cenários que os exemplos dados ilustram, usar `enum` da maneira como foi mostrado é geralmente considerado uma ótima prática em Java e, em muitos casos, a melhor maneira de tratar esses dados.**

Vamos recapitular o porquê e depois discutir quando alternativas podem ser mais adequadas:

### Por que `enum` é bom para esses casos?

1.  **Segurança de Tipo (Type Safety)**: `Enum` garante que você só pode usar os valores definidos. Você não pode acidentalmente passar um inteiro ou string inválido, como aconteceria com constantes `public static final int` ou `String`. Isso elimina uma classe inteira de bugs em tempo de compilação.
2.  **Conjunto Fixo e Conhecido**: `Enums` são ideais quando você tem um número limitado e bem definido de constantes que são conhecidas em tempo de compilação (ex: dias da semana, status de um pedido, tipos de pagamento, operações matemáticas fixas).
3.  **Legibilidade e Manutenibilidade**: O código fica mais claro e fácil de entender. `StatusPedido.APROVADO` é muito mais expressivo do que `pedido.setStatus(1)`.
4.  **Capacidade de Adicionar Atributos e Comportamento**:
    * **Atributos**: Permitem que cada constante do `enum` carregue dados específicos (ex: `TipoPagamento.BOLETO` com `codigo = 1` e `descricao = "Boleto Bancário"`).
    * **Construtores**: Gerenciam a inicialização desses atributos.
    * **Métodos**: Permitem que cada constante tenha seu próprio comportamento ou que o `enum` como um todo forneça funcionalidades úteis (ex: `Operacao.SOMA.executar(a, b)` ou `TipoPagamento.getByCodigo(int codigo)`). A sobrescrita de métodos para comportamento específico da constante é um recurso poderoso.
5.  **Integração com a Linguagem**:
    * Funcionam bem em instruções `switch`.
    * `EnumSet` e `EnumMap` são coleções altamente otimizadas para `enums`.
    * São naturalmente serializáveis (com ressalvas se a estrutura do `enum` mudar).

### Quando `enum` é a melhor escolha (como nos exemplos)?

* **Representar estados finitos**: Status de um pedido, níveis de prioridade, modos de operação.
* **Representar um conjunto fixo de opções**: Tipos de documento, categorias de produtos (se forem fixas), dias da semana, naipes de baralho.
* **Implementar o padrão Strategy de forma simples**: Como no exemplo de `Operacao`, onde cada constante implementava um método `executar` de forma diferente.
* **Substituir "magic numbers" ou constantes de string**: Para códigos de erro, tipos de mensagem, etc., onde cada valor tem um significado específico.
* **Facilitar buscas seguras**: O método `getByAtributo()` que discutimos é um exemplo de como `enums` podem fornecer uma maneira robusta e segura de converter dados externos (como um ID de banco de dados) para um tipo seguro em Java.

### Quando considerar alternativas ou abordagens diferentes?

Apesar de todas as vantagens, existem cenários onde `enums` podem não ser a melhor solução, ou onde seu uso excessivo pode complicar as coisas:

1.  **Dados Dinâmicos ou Carregados do Banco de Dados**:
    * Se o conjunto de "constantes" não é fixo e precisa ser carregado de um banco de dados, arquivo de configuração, ou pode ser alterado pelo usuário em tempo de execução, `enums` não são adequados porque são definidos em tempo de compilação.
    * **Alternativa**: Use classes normais (POJOs) e carregue instâncias a partir do banco (ex: uma tabela de "Tipos de Cliente" que pode ser editada). Um padrão Factory ou um Service Layer podem ser usados para buscar esses objetos.

2.  **Número Muito Grande de "Constantes"**:
    * Se você tem milhares de "constantes" potenciais, um `enum` pode se tornar pesado, pois todas as instâncias são carregadas na memória quando a classe do `enum` é inicializada.
    * **Alternativa**: Novamente, uma tabela de banco de dados com busca sob demanda pode ser mais eficiente.

3.  **Necessidade de Herança Complexa**:
    * `Enums` implicitamente herdam de `java.lang.Enum` e não podem herdar de outra classe. Eles podem implementar interfaces, o que é muito útil, mas se você precisa de uma hierarquia de classes com estado e comportamento herdados de uma superclasse que não seja `Enum`, então classes regulares são o caminho.

4.  **Lógica Excessivamente Complexa nos Enums**:
    * Se os métodos dentro do seu `enum` (especialmente os específicos de cada constante) começam a ficar muito grandes e complexos, manipulando muitas dependências ou lógica de negócios extensa, pode ser um sinal de que o `enum` está assumindo responsabilidades demais.
    * **Alternativa**: O `enum` ainda pode ser usado para representar os diferentes tipos ou estratégias, mas a lógica complexa pode ser delegada para classes separadas (padrão Strategy mais explícito, onde o `enum` apenas aponta para a instância da estratégia correta).

5.  **"Constantes" que são mais Entidades do Domínio**:
    * Se os itens que você está tentando modelar têm um ciclo de vida próprio, relacionamentos complexos com outras entidades, ou precisam ser gerenciados por um ORM de forma mais completa, eles provavelmente são mais "entidades" do que "constantes" e devem ser modelados como classes Java normais.

### Conclusão

**Para os exemplos que vimos (como `TipoPagamento`, `Operacao`, `StatusPedido`, `DiaDaSemana` com atributos e métodos de busca/comportamento), `enums` são, sim, uma abordagem excelente e recomendada em Java.** Eles oferecem uma combinação poderosa de segurança de tipo, clareza e capacidade de encapsular dados e comportamento.

A chave é reconhecer a natureza dos dados que você está modelando:

* **É um conjunto pequeno, finito e fixo de valores conceituais?** `Enum` é provavelmente o ideal.
* **Os valores podem mudar, são muitos, vêm de uma fonte externa dinâmica, ou precisam de uma estrutura de herança complexa?** Classes regulares, possivelmente com dados de um banco, são uma escolha melhor.

É ótimo que você esteja fazendo essa pergunta, pois entender as nuances e os limites de cada ferramenta é fundamental para se tornar um bom desenvolvedor! Os `enums` em Java são muito mais poderosos do que em algumas outras linguagens onde são apenas apelidos para inteiros; em Java, eles são verdadeiras classes.

[Voltar ao Índice](#indice)

---


## <a name="parte87">87 - 084 - Orientação Objetos - Classes abstratas pt 01</a>

- https://www.youtube.com/watch?v=ws1NVBGeegs&list=PL62G310vn6nFIsOCC0H-C2infYgwm8SWW&index=86


[Voltar ao Índice](#indice)

---


## <a name="parte88">88 - 085 - Orientação Objetos - Classes abstratas pt 02 - Métodos abstratos</a>

- https://www.youtube.com/watch?v=j97OEyzBcKI




[Voltar ao Índice](#indice)

---


## <a name="parte89">89 - 086 - Orientação Objetos - Classes abstratas pt 03 - Métodos abstratos regras</a>



[Voltar ao Índice](#indice)

---


## <a name="parte90">90 - 087 - Orientação Objetos - Interfaces pt 01 - Introdução</a>



[Voltar ao Índice](#indice)

---


## <a name="parte91">91 - 088 - Orientação Objetos - Interfaces pt 02 - Implementando múltiplas interfaces</a>



[Voltar ao Índice](#indice)

---


## <a name="parte92">92 - 089 - Orientação Objetos - Interfaces pt 03 - Atributos e métodos estáticos</a>



[Voltar ao Índice](#indice)

---


## <a name="parte93">93 - 090 - Orientação Objetos - Polimorfismo pt 01 - Introdução</a>



[Voltar ao Índice](#indice)

---


## <a name="parte94">94 - 091 - Orientação Objetos - Polimorfismo pt 02 - Funcionamento</a>



[Voltar ao Índice](#indice)

---


## <a name="parte95">95 - 092 - Orientação Objetos - Polimorfismo pt 03 - Parâmetros polimórficos</a>



[Voltar ao Índice](#indice)

---


## <a name="parte96">96 - 093 - Orientação Objetos - Polimorfismo pt 04 - Cast e instanceof</a>



[Voltar ao Índice](#indice)

---


## <a name="parte97">97 - 094 - Orientação Objetos - Polimorfismo pt 05 - Programação orientada a interface</a>



[Voltar ao Índice](#indice)

---


## <a name="parte98">98 - 095 - Exceções pt 01 - Errors</a>



[Voltar ao Índice](#indice)

---


## <a name="parte99">99 - 096 - Exceções pt 02 - RuntimeException</a>



[Voltar ao Índice](#indice)

---


## <a name="parte100">100 - 097 - Exceções pt 03 - Exception</a>



[Voltar ao Índice](#indice)

---


## <a name="parte101">101 - 098 - Exceções pt 04 - Lançando exceção unchecked</a>



[Voltar ao Índice](#indice)

---


## <a name="parte102">102 - 099 - Exceções pt 05 - Lançando exceção checked</a>



[Voltar ao Índice](#indice)

---


## <a name="parte103">103 - 100 - Exceções pt 06 - Bloco Finally</a>



[Voltar ao Índice](#indice)

---


## <a name="parte104">104 - 101 - Exceções pt 07 - Capturando múltiplas exceções</a>



[Voltar ao Índice](#indice)

---


## <a name="parte105">105 - 102 - Exceções pt 08 - Multi catch em linha</a>



[Voltar ao Índice](#indice)

---


## <a name="parte106">106 - 103 - Exceções pt 09 - Try with resources</a>



[Voltar ao Índice](#indice)

---


## <a name="parte107">107 - 104 - Exceções pt 10 - Exceção customizada</a>



[Voltar ao Índice](#indice)

---


## <a name="parte108">108 - 105 - Exceções pt 11 - Exceção e regras de sobrescrita</a>



[Voltar ao Índice](#indice)

---


## <a name="parte109">109 - 106 - Classes Utilitárias - Wrappers pt 01</a>



[Voltar ao Índice](#indice)

---


## <a name="parte110">110 - 107 - Classes Utilitárias - Wrappers pt 02</a>



[Voltar ao Índice](#indice)

---


## <a name="parte111">111 - 108 - Classes Utilitárias - Strings pt 01</a>



[Voltar ao Índice](#indice)

---


## <a name="parte112">112 - 109 - Classes Utilitárias - Strings pt 02</a>



[Voltar ao Índice](#indice)

---


## <a name="parte113">113 - 110 - Classes Utilitárias - Strings pt 03 - Desempenho</a>



[Voltar ao Índice](#indice)

---


## <a name="parte114">114 - 111 - Classes Utilitárias - Strings pt 04 - StringBuilder</a>



[Voltar ao Índice](#indice)

---


## <a name="parte115">115 - 112 - Classes Utilitárias - Date</a>



[Voltar ao Índice](#indice)

---


## <a name="parte116">116 - 113 - Classes Utilitárias - Calendar</a>



[Voltar ao Índice](#indice)

---


## <a name="parte117">117 - 114 - Classes Utilitárias - DateFormat</a>



[Voltar ao Índice](#indice)

---


## <a name="parte118">118 - 115 - Classes Utilitárias - Internacionalização Datas com Locale</a>



[Voltar ao Índice](#indice)

---


## <a name="parte119">119 - 116 - Classes Utilitárias - Internacionalização Números com Locale</a>



[Voltar ao Índice](#indice)

---


## <a name="parte120">120 - 117 - Classes Utilitárias - Internacionalização de moeda com Locale</a>



[Voltar ao Índice](#indice)

---


## <a name="parte121">121 - 118 - Classes Utilitárias - SimpleDateFormat</a>



[Voltar ao Índice](#indice)

---


## <a name="parte122">122 - 119 - Classes Utilitárias - LocalDate</a>



[Voltar ao Índice](#indice)

---


## <a name="parte123">123 - 120 - Classes Utilitárias - LocalTime</a>



[Voltar ao Índice](#indice)

---


## <a name="parte124">124 - 121 - Classes Utilitárias - LocalDateTime</a>



[Voltar ao Índice](#indice)

---


## <a name="parte125">125 - 122 - Classes Utilitárias - Instant</a>



[Voltar ao Índice](#indice)

---


## <a name="parte126">126 - 123 - Classes Utilitárias - Duration</a>



[Voltar ao Índice](#indice)

---


## <a name="parte127">127 - 124 - Classes Utilitárias - Period</a>



[Voltar ao Índice](#indice)

---


## <a name="parte128">128 - 125 - Classes Utilitárias - ChronoUnit</a>



[Voltar ao Índice](#indice)

---


## <a name="parte129">129 - 126 - Classes Utilitárias - TemporalAdjusters</a>



[Voltar ao Índice](#indice)

---


## <a name="parte130">130 - 127 - Classes Utilitárias - TemporalAdjuster</a>



[Voltar ao Índice](#indice)

---


## <a name="parte131">131 - 128 - Classes Utilitárias - ZonedDateTime, ZoneId, OffsetDateTime</a>



[Voltar ao Índice](#indice)

---


## <a name="parte132">132 - 129 - Classes Utilitárias - DateTimeFormatter</a>



[Voltar ao Índice](#indice)

---


## <a name="parte133">133 - 130 - Classes Utilitárias - ResourceBundle</a>



[Voltar ao Índice](#indice)

---


## <a name="parte134">134 - 131 - Classes Utilitárias - Regex pt 01 - Pattern e Matcher</a>



[Voltar ao Índice](#indice)

---


## <a name="parte135">135 - 132 - Classes Utilitárias - Regex pt 02 - Pattern e Matcher - Meta caracteres</a>



[Voltar ao Índice](#indice)

---


## <a name="parte136">136 - 133 - Classes Utilitárias - Regex pt 03 - Pattern e Matcher - Range</a>



[Voltar ao Índice](#indice)

---


## <a name="parte137">137 - 134 - Classes Utilitárias - Regex pt 04 - Pattern e Matcher - Quantificadores pt 01</a>



[Voltar ao Índice](#indice)

---


## <a name="parte138">138 - 135 - Classes Utilitárias - Regex pt 05 - Pattern e Matcher - Quantificadores pt 02</a>



[Voltar ao Índice](#indice)

---


## <a name="parte139">139 - 136 - Classes Utilitárias - Regex pt 06 - Pattern e Matcher - Anchor</a>



[Voltar ao Índice](#indice)

---


## <a name="parte140">140 - 137 - Classes Utilitárias - Scanner - Tokens e Delimitadores</a>



[Voltar ao Índice](#indice)

---


## <a name="parte141">141 - 138 - Classes Utilitárias - IO pt 01 - File</a>



[Voltar ao Índice](#indice)

---


## <a name="parte142">142 - 139 - Classes Utilitárias - IO pt 02 - FileWriter</a>



[Voltar ao Índice](#indice)

---


## <a name="parte143">143 - 140 - Classes Utilitárias - IO pt 03 - FileReader</a>



[Voltar ao Índice](#indice)

---


## <a name="parte144">144 - 141 - Classes Utilitárias - IO pt 04 - BufferedWriter</a>



[Voltar ao Índice](#indice)

---


## <a name="parte145">145 - 142 - Classes Utilitárias - IO pt 05 - BufferedReader</a>



[Voltar ao Índice](#indice)

---


## <a name="parte146">146 - 143 - Classes Utilitárias - IO pt 06 - File para diretórios</a>



[Voltar ao Índice](#indice)

---


## <a name="parte147">147 - 144 - Classes Utilitárias - NIO pt 01 - Path, Paths, Files pt 01</a>



[Voltar ao Índice](#indice)

---


## <a name="parte148">148 - 145 - Classes Utilitárias - NIO pt 02 - Path, Paths, Files pt 02</a>



[Voltar ao Índice](#indice)

---


## <a name="parte149">149 - 146 - Classes Utilitárias - NIO pt 03 - Normalização</a>



[Voltar ao Índice](#indice)

---


## <a name="parte150">150 - 147 - Classes Utilitárias - NIO pt 04 - Resolvendo Paths</a>



[Voltar ao Índice](#indice)

---


## <a name="parte151">151 - 148 - Classes Utilitárias - NIO pt 05 - Relativize</a>



[Voltar ao Índice](#indice)

---


## <a name="parte152">152 - 149 - Classes Utilitárias - NIO pt 06 - BasicFileAttributes pt 01</a>



[Voltar ao Índice](#indice)

---


## <a name="parte153">153 - 150 - Classes Utilitárias - NIO pt 07 - BasicFileAttributes pt 02</a>



[Voltar ao Índice](#indice)

---


## <a name="parte154">154 - 151 - Classes Utilitárias - NIO pt 08 - DosFileAttribute</a>



[Voltar ao Índice](#indice)

---


## <a name="parte155">155 - 152 - Classes Utilitárias - NIO pt 09 - PosixFileAttributes</a>



[Voltar ao Índice](#indice)

---


## <a name="parte156">156 - 153 - Classes Utilitárias - NIO pt 10 - DirectoryStream</a>



[Voltar ao Índice](#indice)

---


## <a name="parte157">157 - 154 - Classes Utilitárias - NIO pt 11 - SimpleFileVisitor pt 01</a>



[Voltar ao Índice](#indice)

---


## <a name="parte158">158 - 155 - Classes Utilitárias - NIO pt 12 - SimpleFileVisitor pt 02</a>



[Voltar ao Índice](#indice)

---


## <a name="parte159">159 - 156 - Classes Utilitárias - NIO pt 13 - PathMatcher pt 01</a>



[Voltar ao Índice](#indice)

---


## <a name="parte160">160 - 157 - Classes Utilitárias - NIO pt 14 - PathMatcher pt 02</a>



[Voltar ao Índice](#indice)

---


## <a name="parte161">161 - 158 - Classes Utilitárias - NIO pt 15 - ZipOutputStream</a>



[Voltar ao Índice](#indice)

---


## <a name="parte162">162 - 159 - Classes Utilitárias - Serialization pt 01</a>



[Voltar ao Índice](#indice)

---


## <a name="parte163">163 - 160 - Classes Utilitárias - Serialization pt 02</a>



[Voltar ao Índice](#indice)

---


## <a name="parte164">164 - 161 - Coleções pt 01 - equals pt 01</a>



[Voltar ao Índice](#indice)

---


## <a name="parte165">165 - 162 - Coleções pt 02 - equals pt 02</a>



[Voltar ao Índice](#indice)

---


## <a name="parte166">166 - 163 - Coleções pt 03 - hashCode pt 01</a>



[Voltar ao Índice](#indice)

---


## <a name="parte167">167 - 164 - Coleções pt 04 - hashCode pt 02</a>



[Voltar ao Índice](#indice)

---


## <a name="parte168">168 - 165 - Coleções pt 05 - Complexidade Big-O</a>



[Voltar ao Índice](#indice)

---


## <a name="parte169">169 - 166 - Coleções pt 06 - List pt 01</a>



[Voltar ao Índice](#indice)

---


## <a name="parte170">170 - 167 - Coleções pt 07 - List pt 02</a>



[Voltar ao Índice](#indice)

---


## <a name="parte171">171 - 168 - Coleções pt 08 - List pt 03</a>



[Voltar ao Índice](#indice)

---


## <a name="parte172">172 - 169 - Coleções pt 09 - Sorting lists pt 01</a>



[Voltar ao Índice](#indice)

---


## <a name="parte173">173 - 170 - Coleções pt 10 - Sorting lists pt 02 - Comparable</a>



[Voltar ao Índice](#indice)

---


## <a name="parte174">174 - 171 - Coleções pt 11 - Sorting lists pt 03 - Comparator</a>



[Voltar ao Índice](#indice)

---


## <a name="parte175">175 - 172 - Coleções pt 12 - Binary Search</a>



[Voltar ao Índice](#indice)

---


## <a name="parte176">176 - 173 - Coleções pt 13 - Conversão de Lista para Arrays e vice versa</a>



[Voltar ao Índice](#indice)

---


## <a name="parte177">177 - 174 - Coleções pt 14 - Iterator</a>



[Voltar ao Índice](#indice)

---


## <a name="parte178">178 - 175 - Coleções pt 15 - Set, HashSet</a>



[Voltar ao Índice](#indice)

---


## <a name="parte179">179 - 176 - Coleções pt 16 - NavigableSet, TreeSet pt 01</a>



[Voltar ao Índice](#indice)

---


## <a name="parte180">180 - 177 - Coleções pt 17 - NavigableSet, TreeSet pt 02</a>



[Voltar ao Índice](#indice)

---


## <a name="parte181">181 - 178 - Coleções pt 18 - Map, HashMap, LinkedHashMap pt 01</a>



[Voltar ao Índice](#indice)

---


## <a name="parte182">182 - 179 - Coleções pt 19 - Map, HashMap, LinkedHashMap pt 02</a>



[Voltar ao Índice](#indice)

---


## <a name="parte183">183 - 180 - Coleções pt 20 - Map, HashMap, LinkedHashMap pt 03</a>



[Voltar ao Índice](#indice)

---


## <a name="parte184">184 - 181 - Coleções pt 21 - NavigableMap, TreeMap</a>



[Voltar ao Índice](#indice)

---


## <a name="parte185">185 - 182 - Coleções pt 22 - Queue, PriorityQueue</a>



[Voltar ao Índice](#indice)

---


## <a name="parte186">186 - 183 - Generics pt 01 - Introdução</a>



[Voltar ao Índice](#indice)

---


## <a name="parte187">187 - 184 - Generics pt 02 - Wildcard pt 01</a>



[Voltar ao Índice](#indice)

---


## <a name="parte188">188 - 185 - Generics pt 03 - Wildcard pt 02</a>



[Voltar ao Índice](#indice)

---


## <a name="parte189">189 - 186 - Generics pt 04 - Classes Genéricas pt 01</a>



[Voltar ao Índice](#indice)

---


## <a name="parte190">190 - 187 - Generics pt 05 - Classes Genéricas pt 02</a>



[Voltar ao Índice](#indice)

---


## <a name="parte191">191 - 188 - Generics pt 06 - Métodos Genéricos</a>



[Voltar ao Índice](#indice)

---


## <a name="parte192">192 - 189 - Classes Internas pt 01 - Classes aninhadas</a>



[Voltar ao Índice](#indice)

---


## <a name="parte193">193 - 190 - Classes Internas pt 02 - Classes Locais</a>



[Voltar ao Índice](#indice)

---


## <a name="parte194">194 - 191 - Classes Internas pt 03 - Classes Anônimas</a>



[Voltar ao Índice](#indice)

---


## <a name="parte195">195 - 192 - Classes Internas pt 04 - Classes aninhadas estáticas</a>



[Voltar ao Índice](#indice)

---


## <a name="parte196">196 - 193 - Parametrizando comportamentos pt 01</a>



[Voltar ao Índice](#indice)

---


## <a name="parte197">197 - 194 - Parametrizando comportamentos pt 02</a>



[Voltar ao Índice](#indice)

---


## <a name="parte198">198 - 195 - Lambdas pt 01 - Predicate</a>



[Voltar ao Índice](#indice)

---


## <a name="parte199">199 - 196 - Lambdas pt 02 - Consumer</a>



[Voltar ao Índice](#indice)

---


## <a name="parte200">200 - 197 - Lambdas pt 03 - Function</a>



[Voltar ao Índice](#indice)

---


## <a name="parte201">201 - 198 - Method Reference pt 01 - Referência a métodos estáticos</a>



[Voltar ao Índice](#indice)

---


## <a name="parte202">202 - 199 - Method Reference pt 02 - Referência a métodos não estáticos</a>



[Voltar ao Índice](#indice)

---


## <a name="parte203">203 - 200 - Method Reference pt 03 - Referência a construtor</a>



[Voltar ao Índice](#indice)

---


## <a name="parte204">204 - 201 - Optional pt 01</a>



[Voltar ao Índice](#indice)

---


## <a name="parte205">205 - 202 - Optional pt 02</a>



[Voltar ao Índice](#indice)

---


## <a name="parte206">206 - 203 - Streams pt 01 - Introduction pt 01</a>



[Voltar ao Índice](#indice)

---


## <a name="parte207">207 - 204 - Streams pt 02 - Introduction pt 02</a>



[Voltar ao Índice](#indice)

---


## <a name="parte208">208 - 205 - Streams pt 03 - Introduction pt 03</a>



[Voltar ao Índice](#indice)

---


## <a name="parte209">209 - 206 - Streams pt 04 - FlatMap pt 01</a>



[Voltar ao Índice](#indice)

---


## <a name="parte210">210 - 207 - Streams pt 05 - FlatMap pt 02</a>



[Voltar ao Índice](#indice)

---


## <a name="parte211">211 - 208 - Streams pt 06 - Finding and Matching</a>



[Voltar ao Índice](#indice)

---


## <a name="parte212">212 - 209 - Streams pt 07 - Reduce pt 01</a>



[Voltar ao Índice](#indice)

---


## <a name="parte213">213 - 210 - Streams pt 08 - Reduce pt 02</a>



[Voltar ao Índice](#indice)

---


## <a name="parte214">214 - 211 - Streams pt 09 - Gerando streams pt 01</a>



[Voltar ao Índice](#indice)

---


## <a name="parte215">215 - 212 - Streams pt 10 - Gerando streams pt 02</a>



[Voltar ao Índice](#indice)

---


## <a name="parte216">216 - 213 - Streams pt 11 - Collectors pt 01 - Summarizing</a>



[Voltar ao Índice](#indice)

---


## <a name="parte217">217 - 214 - Streams pt 12 - Collectors pt 02 - Grouping by pt 01</a>



[Voltar ao Índice](#indice)

---


## <a name="parte218">218 - 215 - Streams pt 13 - Collectors pt 03 - Grouping by pt 02</a>



[Voltar ao Índice](#indice)

---


## <a name="parte219">219 - 216 - Streams pt 14 - Collectors pt 04 - Grouping by pt 03</a>



[Voltar ao Índice](#indice)

---


## <a name="parte220">220 - 217 - Streams pt 15 - Collectors pt 05 - Grouping by pt 04</a>



[Voltar ao Índice](#indice)

---


## <a name="parte221">221 - 218 - Streams pt 16 - Parallel Streams pt 01</a>



[Voltar ao Índice](#indice)

---


## <a name="parte222">222 - 219 - Streams pt 17 - Parallel Streams pt 02</a>



[Voltar ao Índice](#indice)

---


## <a name="parte223">223 - 220 - Threads pt 01 - Introduction</a>



[Voltar ao Índice](#indice)

---


## <a name="parte224">224 - 221 - Threads pt 02 - Estados das threads</a>



[Voltar ao Índice](#indice)

---


## <a name="parte225">225 - 222 - Threads pt 03 - Prioridade e Sleep</a>



[Voltar ao Índice](#indice)

---


## <a name="parte226">226 - 223 - Threads pt 04 - Yield e Join</a>



[Voltar ao Índice](#indice)

---


## <a name="parte227">227 - 224 - Threads pt 05 - Sincronismo de thread pt 01</a>



[Voltar ao Índice](#indice)

---


## <a name="parte228">228 - 225 - Threads pt 06 - Sincronismo de thread pt 02</a>



[Voltar ao Índice](#indice)

---


## <a name="parte229">229 - 226 - Threads pt 07 - Sincronismo de thread pt 03 - Classes thread safe</a>



[Voltar ao Índice](#indice)

---


## <a name="parte230">230 - 227 - Threads pt 08 - Sincronismo de thread pt 04 - Deadlock</a>



[Voltar ao Índice](#indice)

---


## <a name="parte231">231 - 228 - Threads pt 09 - Sincronismo de thread pt 05 - Wait, notify e notifyAll</a>



[Voltar ao Índice](#indice)

---


## <a name="parte232">232 - 229 - Concorrência pt 01 - AtomicInteger</a>



[Voltar ao Índice](#indice)

---


## <a name="parte233">233 - 230 - Concorrência pt 02 - Lock and ReentrantLock</a>



[Voltar ao Índice](#indice)

---


## <a name="parte234">234 - 231 - Concorrência pt 03 - Conditions</a>



[Voltar ao Índice](#indice)

---


## <a name="parte235">235 - 232 - Concorrência pt 04 - ReentrantReadWriteLock</a>



[Voltar ao Índice](#indice)

---


## <a name="parte236">236 - 233 - Concorrência pt 05 - CopyOnWriteArrayList</a>



[Voltar ao Índice](#indice)

---


## <a name="parte237">237 - 234 - Concorrência pt 06 - ArrayBlockingQueue</a>



[Voltar ao Índice](#indice)

---


## <a name="parte238">238 - 235 - Concorrência pt 07 - LinkedTransferQueue</a>



[Voltar ao Índice](#indice)

---


## <a name="parte239">239 - 236 - Concorrência pt 08 - Executors pt 01 - Thread Pools</a>



[Voltar ao Índice](#indice)

---


## <a name="parte240">240 - 237 - Concorrência pt 09 - Executors pt 02 - ScheduledExecutorService</a>



[Voltar ao Índice](#indice)

---


## <a name="parte241">241 - 238 - Concorrência pt 10 - Executors pt 03 - Interface Callable</a>



[Voltar ao Índice](#indice)

---


## <a name="parte242">242 - 239 - Concorrência pt 11 - Executors pt 04 - Future</a>



[Voltar ao Índice](#indice)

---


## <a name="parte243">243 - 240 - Concorrência pt 12 - CompletableFuture pt 01 - get and join</a>



[Voltar ao Índice](#indice)

---


## <a name="parte244">244 - 241 - Concorrência pt 13 - CompletableFuture pt 02 - streams</a>



[Voltar ao Índice](#indice)

---


## <a name="parte245">245 - 242 - Concorrência pt 14 - CompletableFuture pt 03 - ThreadFactory</a>



[Voltar ao Índice](#indice)

---


## <a name="parte246">246 - 243 - Concorrência pt 15 - CompletableFuture pt 04 - Encadeando chamadas pt 01</a>



[Voltar ao Índice](#indice)

---


## <a name="parte247">247 - 244 - Concorrência pt 16 - CompletableFuture pt 05 - Encadeando chamadas pt 02</a>



[Voltar ao Índice](#indice)

---


## <a name="parte248">248 - 245 - Concorrência pt 17 - CompletableFuture pt 06 - allOf, anyOf</a>



[Voltar ao Índice](#indice)

---


## <a name="parte249">249 - 246 - Padrões de Projeto pt 01 - Builder</a>



[Voltar ao Índice](#indice)

---


## <a name="parte250">250 - 247 - Padrões de Projeto pt 02 - Factory</a>



[Voltar ao Índice](#indice)

---


## <a name="parte251">251 - 248 - Padrões de Projeto pt 03 - Singleton pt 01 - Eager Initialization</a>



[Voltar ao Índice](#indice)

---


## <a name="parte252">252 - 249 - Padrões de Projeto pt 04 - Singleton pt 02 - Lazy Initialization</a>



[Voltar ao Índice](#indice)

---


## <a name="parte253">253 - 250 - Padrões de Projeto pt 05 - Singleton pt 03 - Singleton with enumeration</a>



[Voltar ao Índice](#indice)

---


## <a name="parte254">254 - 251 - Padrões de Projeto pt 06 - Data Transfer Object</a>



[Voltar ao Índice](#indice)

---


## <a name="parte255">255 - 252 - JDBC pt 01 - Instalando Docker</a>



[Voltar ao Índice](#indice)

---


## <a name="parte256">256 - 253 - JDBC pt 02 - Criando container MySQL</a>



[Voltar ao Índice](#indice)

---


## <a name="parte257">257 - 254 - JDBC pt 03 - Instalando Workbench, criando schema e tabelas</a>



[Voltar ao Índice](#indice)

---


## <a name="parte258">258 - 255 - JDBC pt 04 - Instalando e adicionando maven ao projeto</a>



[Voltar ao Índice](#indice)

---


## <a name="parte259">259 - 256 - JDBC pt 05 - Adicionando dependência e conectando com banco</a>



[Voltar ao Índice](#indice)

---


## <a name="parte260">260 - 257 - JDBC pt 06 - Inserindo dados com Statement</a>



[Voltar ao Índice](#indice)

---


## <a name="parte261">261 - 258 - JDBC pt 07 - Lombok e Log4J2</a>



[Voltar ao Índice](#indice)

---


## <a name="parte262">262 - 259 - JDBC pt 08 - Deletando dados com Statement</a>



[Voltar ao Índice](#indice)

---


## <a name="parte263">263 - 260 - JDBC pt 09 - Atualizando dados com Statement</a>



[Voltar ao Índice](#indice)

---


## <a name="parte264">264 - 261 - JDBC pt 10 - Buscando dados com ResultSet pt 01 - findAll</a>



[Voltar ao Índice](#indice)

---


## <a name="parte265">265 - 262 - JDBC pt 11 - Buscando dados com ResultSet pt 02 - findByName</a>



[Voltar ao Índice](#indice)

---


## <a name="parte266">266 - 263 - JDBC pt 12 - ResultSetMetaData</a>



[Voltar ao Índice](#indice)

---


## <a name="parte267">267 - 264 - JDBC pt 13 - DatabaseMetaData</a>



[Voltar ao Índice](#indice)

---


## <a name="parte268">268 - 265 - JDBC pt 14 - ResultSet.TYPE_SCROLL_INSENSITIVE</a>



[Voltar ao Índice](#indice)

---


## <a name="parte269">269 - 266 - JDBC pt 15 - Atualizando registros com ResultSet</a>



[Voltar ao Índice](#indice)

---


## <a name="parte270">270 - 267 - JDBC pt 16 - Inserindo e deletando registros com ResultSet</a>



[Voltar ao Índice](#indice)

---


## <a name="parte271">271 - 268 - JDBC pt 17 - PreparedStatement pt 01</a>



[Voltar ao Índice](#indice)

---


## <a name="parte272">272 - 269 - JDBC pt 18 - PreparedStatement pt 02</a>



[Voltar ao Índice](#indice)

---


## <a name="parte273">273 - 270 - JDBC pt 19 - CallableStatement</a>



[Voltar ao Índice](#indice)

---


## <a name="parte274">274 - 271 - JDBC pt 20 - Connected RowSet - JdbcRowSet pt 01</a>



[Voltar ao Índice](#indice)

---


## <a name="parte275">275 - 272 - JDBC pt 21 - Connected RowSet - JdbcRowSet pt 02</a>



[Voltar ao Índice](#indice)

---


## <a name="parte276">276 - 273 - JDBC pt 22 - Disconnected RowSet - CachedRowSet</a>



[Voltar ao Índice](#indice)

---


## <a name="parte277">277 - 274 - JDBC pt 23 - Transação</a>



[Voltar ao Índice](#indice)

---


## <a name="parte278">278 - 275 - JDBC pt 24 - CRUD pt 01 - findByName and findAll</a>



[Voltar ao Índice](#indice)

---


## <a name="parte279">279 - 276 - JDBC pt 25 - CRUD pt 02 - delete</a>



[Voltar ao Índice](#indice)

---


## <a name="parte280">280 - 277 - JDBC pt 26 - CRUD pt 03 - save</a>



[Voltar ao Índice](#indice)

---


## <a name="parte281">281 - 278 - JDBC pt 27 - CRUD pt 04 - update</a>



[Voltar ao Índice](#indice)

---


## <a name="parte282">282 - 279 - JDBC pt 28 - CRUD pt 05 - Anime Crud</a>



[Voltar ao Índice](#indice)

---


## <a name="parte283">283 - 280 - Testes unitários com jUnit pt 01</a>



[Voltar ao Índice](#indice)

---


## <a name="parte284">284 - 281 - Testes unitários com jUnit pt 02</a>



[Voltar ao Índice](#indice)

---


## <a name="parte285">285 - 282 - Atualizando JDK</a>



[Voltar ao Índice](#indice)

---


## <a name="parte286">286 - 283 - Record Class</a>



[Voltar ao Índice](#indice)

---


## <a name="parte287">287 - 284 - Pattern Matching for instanceof</a>



[Voltar ao Índice](#indice)

---


## <a name="parte288">288 - 285 - É só correr pro abraço</a>



[Voltar ao Índice](#indice)

---