
# Maratona Java Virado No Jiraya - DevDojo Academy

https://www.youtube.com/playlist?list=PL62G310vn6nFIsOCC0H-C2infYgwm8SWW

Cr√©ditos: Melhor, maior, e o mais completo curso de Java em portugu√™s gr√°tis de toda Internet est√° de volta. Maratona Java Virado No Jiraya. Regravado desde a aula 0, com extrema qualidade, utilizando a √∫ltima vers√£o do Java, com fonte 22 e fundo branco celestial. FAQ Q. Quem criou? A. O cara com um parafuso a menos que colocou um curso desses gratuito foi esse aqui: https://www.linkedin.com/in/williamsuane/ Q. Quem editou os v√≠deos? A. O irm√£o do cara com um parafuso a menos, que tamb√©m tem um parafuso a menos, j√° que editou de gra√ßa: https://www.linkedin.com/in/wildneisuane/

FONTE RESUMO: Deepseek/CHATGPT/COPILOT

## <a name="indice">√çndice</a>

001. [000 - Maratona Java Virado No Jiraya - Bem-vindo](#parte1)
002. [001 - O que esperar do curso](#parte2)
003. [002 - Como Java Funciona](#parte3)
004. [003 - Fazendo o download da JDK 15](#parte4)
005. [004 - Configurando variaveis de ambiente](#parte5)
006. [005 - Executando compila√ß√£o manualmente](#parte6)
007. [006 - Download da IDE IntelliJ Community](#parte7)
008. [007 - Conhecendo a IDE IntelliJ Community](#parte8)
009. [008 - Organizando o c√≥digo em pacotes](#parte9)
010. [009 - Coment√°rios](#parte10)
011. [010 - Tipos primitivos pt 01 - conven√ß√µes de vari√°veis](#parte11)
012. [011 - Tipos primitivos pt 02 - declara√ß√£o e tamanho em mem√≥ria](#parte12)
013. [012 - Tipos primitivos pt 03 - casting](#parte13)
014. [013 - Tipos primitivos pt 04 - Strings](#parte14)
015. [014 - Tipos primitivos pt 05 - Exerc√≠cio](#parte15)
016. [015 - Operadores pt 01 - Aritim√©ticos](#parte16)
017. [016 - Operadores pt 02 - Relacionais](#parte17)
018. [017 - Operadores pt 03 - L√≥gicos AND](#parte18)
019. [018 - Operadores pt 04 - L√≥gicos OR](#parte19)
020. [019 - Operadores pt 05 - Atribui√ß√£o](#parte20)
021. [020 - Estruturas Condicionais pt 01 - IF](#parte21)
022. [021 - Estruturas Condicionais pt 02 - ELSE IF](#parte22)
023. [022 - Estruturas Condicionais pt 03 - Operador tern√°rio](#parte23)
024. [023 - Estruturas Condicionais pt 04 - Tabela Verdade e exerc√≠cio](#parte24)
025. [024 - Estruturas Condicionais pt 05 - Resolu√ß√£o do exerc√≠cios](#parte25)
026. [025 - Estruturas Condicionais pt 06 - Switch](#parte26)
027. [026 - Estruturas Condicionais pt 07 - Switch exerc√≠cio](#parte27)
028. [027 - Estruturas de Repeti√ß√£o pt 01 - La√ßos de repeti√ß√£o while, do while, for](#parte28)
029. [028 - Estruturas de Repeti√ß√£o pt 02 - Exerc√≠cio for](#parte29)
030. [029 - Estruturas de Repeti√ß√£o pt 03 - Break](#parte30)
031. [030 - Estruturas de Repeti√ß√£o pt 04 - Exerc√≠cio Break](#parte31)
032. [031 - Estruturas de Repeti√ß√£o pt 05 - Continue](#parte32)
033. [032 - Arrays pt 01](#parte33)
034. [033 - Arrays pt 02](#parte34)
035. [034 - Arrays pt 03](#parte35)
036. [035 - Arrays pt 04 - Foreach](#parte36)
037. [036 - Arrays Multidimensionais pt 01](#parte37)
038. [037 - Arrays Multidimensionais pt 02 - Foreach](#parte38)
039. [038 - Arrays Multidimensionais pt 03 - Inicializa√ß√£o](#parte39)
040. [039 - Orienta√ß√£o Objetos pt 01 - Introdu√ß√£o classes pt 01](#parte40)
041. [040 - Orienta√ß√£o Objetos - Introdu√ß√£o classes pt 02](#parte41)
042. [041 - Orienta√ß√£o Objetos - Coes√£o](#parte42)
043. [042 - Orienta√ß√£o Objetos - Exerc√≠cio Classes](#parte43)
044. [043 - Orienta√ß√£o Objetos - Refer√™ncia de objetos](#parte44)
045. [044 - Orienta√ß√£o Objetos - M√©todos pt 01](#parte45)
046. [045 - Orienta√ß√£o Objetos - M√©todos pt 02 - Par√¢metros](#parte46)
047. [046 - Orienta√ß√£o Objetos - M√©todos pt 03 - Retorno pt 01](#parte47)
048. [047 - Orienta√ß√£o Objetos - M√©todos pt 04 - Retorno pt 02](#parte48)
049. [048 - Orienta√ß√£o Objetos - M√©todos pt 05 - Par√¢metros tipo primitivo](#parte49)
050. [049 - Orienta√ß√£o Objetos - M√©todos pt 06 - Par√¢metros tipo refer√™ncia](#parte50)
051. [050 - Orienta√ß√£o Objetos - M√©todos pt 07 - Par√¢metros tipo refer√™ncia pt 02](#parte51)
052. [051 - Orienta√ß√£o Objetos - M√©todos pt 08 - Refer√™ncia this](#parte52)
053. [052 - Orienta√ß√£o Objetos - M√©todos pt 09 - Varargs](#parte53)
054. [053 - Orienta√ß√£o Objetos - M√©todos pt 10 - Exercise](#parte54)
055. [054 - Orienta√ß√£o Objetos - Modificador de acesso private, get e set pt 01](#parte55)
056. [055 - Orienta√ß√£o Objetos - Modificador de acesso private, get e set pt 02](#parte56)
057. [056 - Orienta√ß√£o Objetos - Modificador de acesso private, get e set pt 03](#parte57)
058. [057 - Orienta√ß√£o Objetos - Sobrecarga de m√©todos](#parte58)
059. [058 - Orienta√ß√£o Objetos - Construtores pt 01](#parte59)
060. [059 - Orienta√ß√£o Objetos - Construtores pt 02 - Sobrecarga](#parte60)
061. [060 - Orienta√ß√£o Objetos - Blocos de inicializa√ß√£o](#parte61)
062. [061 - Orienta√ß√£o Objetos - Modificador static](#parte62)
063. [062 - Orienta√ß√£o Objetos - M√©todos est√°ticos](#parte63)
064. [063 - Orienta√ß√£o Objetos - Bloco de inicializa√ß√£o est√°tico](#parte64)
065. [064 - Orienta√ß√£o Objetos - Associa√ß√£o pt 01 - Arrays com Objetos](#parte65)
066. [065 - Orienta√ß√£o Objetos - Associa√ß√£o pt 02 - Associa√ß√£o unidirecional um para muitos](#parte66)
067. [066 - Orienta√ß√£o Objetos - Associa√ß√£o pt 03 - Associa√ß√£o unidirecional muitos para um](#parte67)
068. [067 - Orienta√ß√£o Objetos - Associa√ß√£o pt 04 - Associa√ß√£o bidirecional](#parte68)
069. [068 - Orienta√ß√£o Objetos - Leitura de dados pelo console](#parte69)
070. [069 - Orienta√ß√£o Objetos - Exerc√≠cio leitura de dados do teclado](#parte70)
071. [068 - Orienta√ß√£o Objetos - Leitura de dados pelo console](#parte71)
072. [069 - Orienta√ß√£o Objetos - Exerc√≠cio leitura de dados do teclado](#parte72)
073. [070 - Orienta√ß√£o Objetos - Associa√ß√£o pt 05 - Exerc√≠cio Associa√ß√£o](#parte73)
074. [071 - Orienta√ß√£o Objetos - Heran√ßa pt 01](#parte74)
075. [072 - Orienta√ß√£o Objetos - Heran√ßa pt 02 - Super](#parte75)
076. [073 - Orienta√ß√£o Objetos - Heran√ßa pt 03 - protected](#parte76)
077. [074 - Orienta√ß√£o Objetos - Heran√ßa pt 04 - Construtores](#parte77)
078. [075 - Orienta√ß√£o Objetos - Heran√ßa pt 05 - Sequ√™ncia de inicializa√ß√£o](#parte78)
079. [076 - Orienta√ß√£o Objetos - Sobrescrita do m√©todo toString](#parte79)
080. [077 - Orienta√ß√£o Objetos - Modificador final pt 01 - Tipo primitivo](#parte80)
081. [078 - Orienta√ß√£o Objetos - Modificador final pt 02 - Tipo refer√™ncia](#parte81)
082. [079 - Orienta√ß√£o Objetos - Modificador final pt 03 - Classes e m√©todos](#parte82)
083. [080 - Orienta√ß√£o Objetos - Enumera√ß√£o pt 01 - Introdu√ß√£o](#parte83)
084. [081 - Orienta√ß√£o Objetos - Enumera√ß√£o pt 02 - Construtores e atributos](#parte84)
085. [082 - Orienta√ß√£o Objetos - Enumera√ß√£o pt 03 - Sobrescrita de m√©todos](#parte85)
086. [083 - Orienta√ß√£o Objetos - Enumera√ß√£o pt 04 - Busca por atributos](#parte86)
087. [084 - Orienta√ß√£o Objetos - Classes abstratas pt 01](#parte87)
088. [085 - Orienta√ß√£o Objetos - Classes abstratas pt 02 - M√©todos abstratos](#parte88)
089. [086 - Orienta√ß√£o Objetos - Classes abstratas pt 03 - M√©todos abstratos regras](#parte89)
090. [087 - Orienta√ß√£o Objetos - Interfaces pt 01 - Introdu√ß√£o](#parte90)
091. [088 - Orienta√ß√£o Objetos - Interfaces pt 02 - Implementando m√∫ltiplas interfaces](#parte91)
092. [089 - Orienta√ß√£o Objetos - Interfaces pt 03 - Atributos e m√©todos est√°ticos](#parte92)
093. [090 - Orienta√ß√£o Objetos - Polimorfismo pt 01 - Introdu√ß√£o](#parte93)
094. [091 - Orienta√ß√£o Objetos - Polimorfismo pt 02 - Funcionamento](#parte94)
095. [092 - Orienta√ß√£o Objetos - Polimorfismo pt 03 - Par√¢metros polim√≥rficos](#parte95)
096. [093 - Orienta√ß√£o Objetos - Polimorfismo pt 04 - Cast e instanceof](#parte96)
097. [094 - Orienta√ß√£o Objetos - Polimorfismo pt 05 - Programa√ß√£o orientada a interface](#parte97)
098. [095 - Exce√ß√µes pt 01 - Errors](#parte98)
099. [096 - Exce√ß√µes pt 02 - RuntimeException](#parte99)
100. [097 - Exce√ß√µes pt 03 - Exception](#parte100)
101. [098 - Exce√ß√µes pt 04 - Lan√ßando exce√ß√£o unchecked](#parte101)
102. [099 - Exce√ß√µes pt 05 - Lan√ßando exce√ß√£o checked](#parte102)
103. [100 - Exce√ß√µes pt 06 - Bloco Finally](#parte103)
104. [101 - Exce√ß√µes pt 07 - Capturando m√∫ltiplas exce√ß√µes](#parte104)
105. [102 - Exce√ß√µes pt 08 - Multi catch em linha](#parte105)
106. [103 - Exce√ß√µes pt 09 - Try with resources](#parte106)
107. [104 - Exce√ß√µes pt 10 - Exce√ß√£o customizada](#parte107)
108. [105 - Exce√ß√µes pt 11 - Exce√ß√£o e regras de sobrescrita](#parte108)
109. [106 - Classes Utilit√°rias - Wrappers pt 01](#parte109)
110. [107 - Classes Utilit√°rias - Wrappers pt 02](#parte110)
111. [108 - Classes Utilit√°rias - Strings pt 01](#parte111)
112. [109 - Classes Utilit√°rias - Strings pt 02](#parte112)
113. [110 - Classes Utilit√°rias - Strings pt 03 - Desempenho](#parte113)
114. [111 - Classes Utilit√°rias - Strings pt 04 - StringBuilder](#parte114)
115. [112 - Classes Utilit√°rias - Date](#parte115)
116. [113 - Classes Utilit√°rias - Calendar](#parte116)
117. [114 - Classes Utilit√°rias - DateFormat](#parte117)
118. [115 - Classes Utilit√°rias - Internacionaliza√ß√£o Datas com Locale](#parte118)
119. [116 - Classes Utilit√°rias - Internacionaliza√ß√£o N√∫meros com Locale](#parte119)
120. [117 - Classes Utilit√°rias - Internacionaliza√ß√£o de moeda com Locale](#parte120)
121. [118 - Classes Utilit√°rias - SimpleDateFormat](#parte121)
122. [119 - Classes Utilit√°rias - LocalDate](#parte122)
123. [120 - Classes Utilit√°rias - LocalTime](#parte123)
124. [121 - Classes Utilit√°rias - LocalDateTime](#parte124)
125. [122 - Classes Utilit√°rias - Instant](#parte125)
126. [123 - Classes Utilit√°rias - Duration](#parte126)
127. [124 - Classes Utilit√°rias - Period](#parte127)
128. [125 - Classes Utilit√°rias - ChronoUnit](#parte128)
129. [126 - Classes Utilit√°rias - TemporalAdjusters](#parte129)
130. [127 - Classes Utilit√°rias - TemporalAdjuster](#parte130)
131. [128 - Classes Utilit√°rias - ZonedDateTime, ZoneId, OffsetDateTime](#parte131)
132. [129 - Classes Utilit√°rias - DateTimeFormatter](#parte132)
133. [130 - Classes Utilit√°rias - ResourceBundle](#parte133)
134. [131 - Classes Utilit√°rias - Regex pt 01 - Pattern e Matcher](#parte134)
135. [132 - Classes Utilit√°rias - Regex pt 02 - Pattern e Matcher - Meta caracteres](#parte135)
136. [133 - Classes Utilit√°rias - Regex pt 03 - Pattern e Matcher - Range](#parte136)
137. [134 - Classes Utilit√°rias - Regex pt 04 - Pattern e Matcher - Quantificadores pt 01](#parte137)
138. [135 - Classes Utilit√°rias - Regex pt 05 - Pattern e Matcher - Quantificadores pt 02](#parte138)
139. [136 - Classes Utilit√°rias - Regex pt 06 - Pattern e Matcher - Anchor](#parte139)
140. [137 - Classes Utilit√°rias - Scanner - Tokens e Delimitadores](#parte140)
141. [138 - Classes Utilit√°rias - IO pt 01 - File](#parte141)
142. [139 - Classes Utilit√°rias - IO pt 02 - FileWriter](#parte142)
143. [140 - Classes Utilit√°rias - IO pt 03 - FileReader](#parte143)
144. [141 - Classes Utilit√°rias - IO pt 04 - BufferedWriter](#parte144)
145. [142 - Classes Utilit√°rias - IO pt 05 - BufferedReader](#parte145)
146. [143 - Classes Utilit√°rias - IO pt 06 - File para diret√≥rios](#parte146)
147. [144 - Classes Utilit√°rias - NIO pt 01 - Path, Paths, Files pt 01](#parte147)
148. [145 - Classes Utilit√°rias - NIO pt 02 - Path, Paths, Files pt 02](#parte148)
149. [146 - Classes Utilit√°rias - NIO pt 03 - Normaliza√ß√£o](#parte149)
150. [147 - Classes Utilit√°rias - NIO pt 04 - Resolvendo Paths](#parte150)
151. [148 - Classes Utilit√°rias - NIO pt 05 - Relativize](#parte151)
152. [149 - Classes Utilit√°rias - NIO pt 06 - BasicFileAttributes pt 01](#parte152)
153. [150 - Classes Utilit√°rias - NIO pt 07 - BasicFileAttributes pt 02](#parte153)
154. [151 - Classes Utilit√°rias - NIO pt 08 - DosFileAttribute](#parte154)
155. [152 - Classes Utilit√°rias - NIO pt 09 - PosixFileAttributes](#parte155)
156. [153 - Classes Utilit√°rias - NIO pt 10 - DirectoryStream](#parte156)
157. [154 - Classes Utilit√°rias - NIO pt 11 - SimpleFileVisitor pt 01](#parte157)
158. [155 - Classes Utilit√°rias - NIO pt 12 - SimpleFileVisitor pt 02](#parte158)
159. [156 - Classes Utilit√°rias - NIO pt 13 - PathMatcher pt 01](#parte159)
160. [157 - Classes Utilit√°rias - NIO pt 14 - PathMatcher pt 02](#parte160)
161. [158 - Classes Utilit√°rias - NIO pt 15 - ZipOutputStream](#parte161)
162. [159 - Classes Utilit√°rias - Serialization pt 01](#parte162)
163. [160 - Classes Utilit√°rias - Serialization pt 02](#parte163)
164. [161 - Cole√ß√µes pt 01 - equals pt 01](#parte164)
165. [162 - Cole√ß√µes pt 02 - equals pt 02](#parte165)
166. [163 - Cole√ß√µes pt 03 - hashCode pt 01](#parte166)
167. [164 - Cole√ß√µes pt 04 - hashCode pt 02](#parte167)
168. [165 - Cole√ß√µes pt 05 - Complexidade Big-O](#parte168)
169. [166 - Cole√ß√µes pt 06 - List pt 01](#parte169)
170. [167 - Cole√ß√µes pt 07 - List pt 02](#parte170)
171. [168 - Cole√ß√µes pt 08 - List pt 03](#parte171)
172. [169 - Cole√ß√µes pt 09 - Sorting lists pt 01](#parte172)
173. [170 - Cole√ß√µes pt 10 - Sorting lists pt 02 - Comparable](#parte173)
174. [171 - Cole√ß√µes pt 11 - Sorting lists pt 03 - Comparator](#parte174)
175. [172 - Cole√ß√µes pt 12 - Binary Search](#parte175)
176. [173 - Cole√ß√µes pt 13 - Convers√£o de Lista para Arrays e vice versa](#parte176)
177. [174 - Cole√ß√µes pt 14 - Iterator](#parte177)
178. [175 - Cole√ß√µes pt 15 - Set, HashSet](#parte178)
179. [176 - Cole√ß√µes pt 16 - NavigableSet, TreeSet pt 01](#parte179)
180. [177 - Cole√ß√µes pt 17 - NavigableSet, TreeSet pt 02](#parte180)
181. [178 - Cole√ß√µes pt 18 - Map, HashMap, LinkedHashMap pt 01](#parte181)
182. [179 - Cole√ß√µes pt 19 - Map, HashMap, LinkedHashMap pt 02](#parte182)
183. [180 - Cole√ß√µes pt 20 - Map, HashMap, LinkedHashMap pt 03](#parte183)
184. [181 - Cole√ß√µes pt 21 - NavigableMap, TreeMap](#parte184)
185. [182 - Cole√ß√µes pt 22 - Queue, PriorityQueue](#parte185)
186. [183 - Generics pt 01 - Introdu√ß√£o](#parte186)
187. [184 - Generics pt 02 - Wildcard pt 01](#parte187)
188. [185 - Generics pt 03 - Wildcard pt 02](#parte188)
189. [186 - Generics pt 04 - Classes Gen√©ricas pt 01](#parte189)
190. [187 - Generics pt 05 - Classes Gen√©ricas pt 02](#parte190)
191. [188 - Generics pt 06 - M√©todos Gen√©ricos](#parte191)
192. [189 - Classes Internas pt 01 - Classes aninhadas](#parte192)
193. [190 - Classes Internas pt 02 - Classes Locais](#parte193)
194. [191 - Classes Internas pt 03 - Classes An√¥nimas](#parte194)
195. [192 - Classes Internas pt 04 - Classes aninhadas est√°ticas](#parte195)
196. [193 - Parametrizando comportamentos pt 01](#parte196)
197. [194 - Parametrizando comportamentos pt 02](#parte197)
198. [195 - Lambdas pt 01 - Predicate](#parte198)
199. [196 - Lambdas pt 02 - Consumer](#parte199)
200. [197 - Lambdas pt 03 - Function](#parte200)
201. [198 - Method Reference pt 01 - Refer√™ncia a m√©todos est√°ticos](#parte201)
202. [199 - Method Reference pt 02 - Refer√™ncia a m√©todos n√£o est√°ticos](#parte202)
203. [200 - Method Reference pt 03 - Refer√™ncia a construtor](#parte203)
204. [201 - Optional pt 01](#parte204)
205. [202 - Optional pt 02](#parte205)
206. [203 - Streams pt 01 - Introduction pt 01](#parte206)
207. [204 - Streams pt 02 - Introduction pt 02](#parte207)
208. [205 - Streams pt 03 - Introduction pt 03](#parte208)
209. [206 - Streams pt 04 - FlatMap pt 01](#parte209)
210. [207 - Streams pt 05 - FlatMap pt 02](#parte210)
211. [208 - Streams pt 06 - Finding and Matching](#parte211)
212. [209 - Streams pt 07 - Reduce pt 01](#parte212)
213. [210 - Streams pt 08 - Reduce pt 02](#parte213)
214. [211 - Streams pt 09 - Gerando streams pt 01](#parte214)
215. [212 - Streams pt 10 - Gerando streams pt 02](#parte215)
216. [213 - Streams pt 11 - Collectors pt 01 - Summarizing](#parte216)
217. [214 - Streams pt 12 - Collectors pt 02 - Grouping by pt 01](#parte217)
218. [215 - Streams pt 13 - Collectors pt 03 - Grouping by pt 02](#parte218)
219. [216 - Streams pt 14 - Collectors pt 04 - Grouping by pt 03](#parte219)
220. [217 - Streams pt 15 - Collectors pt 05 - Grouping by pt 04](#parte220)
221. [218 - Streams pt 16 - Parallel Streams pt 01](#parte221)
222. [219 - Streams pt 17 - Parallel Streams pt 02](#parte222)
223. [220 - Threads pt 01 - Introduction](#parte223)
224. [221 - Threads pt 02 - Estados das threads](#parte224)
225. [222 - Threads pt 03 - Prioridade e Sleep](#parte225)
226. [223 - Threads pt 04 - Yield e Join](#parte226)
227. [224 - Threads pt 05 - Sincronismo de thread pt 01](#parte227)
228. [225 - Threads pt 06 - Sincronismo de thread pt 02](#parte228)
229. [226 - Threads pt 07 - Sincronismo de thread pt 03 - Classes thread safe](#parte229)
230. [227 - Threads pt 08 - Sincronismo de thread pt 04 - Deadlock](#parte230)
231. [228 - Threads pt 09 - Sincronismo de thread pt 05 - Wait, notify e notifyAll](#parte231)
232. [229 - Concorr√™ncia pt 01 - AtomicInteger](#parte232)
233. [230 - Concorr√™ncia pt 02 - Lock and ReentrantLock](#parte233)
234. [231 - Concorr√™ncia pt 03 - Conditions](#parte234)
235. [232 - Concorr√™ncia pt 04 - ReentrantReadWriteLock](#parte235)
236. [233 - Concorr√™ncia pt 05 - CopyOnWriteArrayList](#parte236)
237. [234 - Concorr√™ncia pt 06 - ArrayBlockingQueue](#parte237)
238. [235 - Concorr√™ncia pt 07 - LinkedTransferQueue](#parte238)
239. [236 - Concorr√™ncia pt 08 - Executors pt 01 - Thread Pools](#parte239)
240. [237 - Concorr√™ncia pt 09 - Executors pt 02 - ScheduledExecutorService](#parte240)
241. [238 - Concorr√™ncia pt 10 - Executors pt 03 - Interface Callable](#parte241)
242. [239 - Concorr√™ncia pt 11 - Executors pt 04 - Future](#parte242)
243. [240 - Concorr√™ncia pt 12 - CompletableFuture pt 01 - get and join](#parte243)
244. [241 - Concorr√™ncia pt 13 - CompletableFuture pt 02 - streams](#parte244)
245. [242 - Concorr√™ncia pt 14 - CompletableFuture pt 03 - ThreadFactory](#parte245)
246. [243 - Concorr√™ncia pt 15 - CompletableFuture pt 04 - Encadeando chamadas pt 01](#parte246)
247. [244 - Concorr√™ncia pt 16 - CompletableFuture pt 05 - Encadeando chamadas pt 02](#parte247)
248. [245 - Concorr√™ncia pt 17 - CompletableFuture pt 06 - allOf, anyOf](#parte248)
249. [246 - Padr√µes de Projeto pt 01 - Builder](#parte249)
250. [247 - Padr√µes de Projeto pt 02 - Factory](#parte250)
251. [248 - Padr√µes de Projeto pt 03 - Singleton pt 01 - Eager Initialization](#parte251)
252. [249 - Padr√µes de Projeto pt 04 - Singleton pt 02 - Lazy Initialization](#parte252)
253. [250 - Padr√µes de Projeto pt 05 - Singleton pt 03 - Singleton with enumeration](#parte253)
254. [251 - Padr√µes de Projeto pt 06 - Data Transfer Object](#parte254)
255. [252 - JDBC pt 01 - Instalando Docker](#parte255)
256. [253 - JDBC pt 02 - Criando container MySQL](#parte256)
257. [254 - JDBC pt 03 - Instalando Workbench, criando schema e tabelas](#parte257)
258. [255 - JDBC pt 04 - Instalando e adicionando maven ao projeto](#parte258)
259. [256 - JDBC pt 05 - Adicionando depend√™ncia e conectando com banco](#parte259)
260. [257 - JDBC pt 06 - Inserindo dados com Statement](#parte260)
261. [258 - JDBC pt 07 - Lombok e Log4J2](#parte261)
262. [259 - JDBC pt 08 - Deletando dados com Statement](#parte262)
263. [260 - JDBC pt 09 - Atualizando dados com Statement](#parte263)
264. [261 - JDBC pt 10 - Buscando dados com ResultSet pt 01 - findAll](#parte264)
265. [262 - JDBC pt 11 - Buscando dados com ResultSet pt 02 - findByName](#parte265)
266. [263 - JDBC pt 12 - ResultSetMetaData](#parte266)
267. [264 - JDBC pt 13 - DatabaseMetaData](#parte267)
268. [265 - JDBC pt 14 - ResultSet.TYPE_SCROLL_INSENSITIVE](#parte268)
269. [266 - JDBC pt 15 - Atualizando registros com ResultSet](#parte269)
270. [267 - JDBC pt 16 - Inserindo e deletando registros com ResultSet](#parte270)
271. [268 - JDBC pt 17 - PreparedStatement pt 01](#parte271)
272. [269 - JDBC pt 18 - PreparedStatement pt 02](#parte272)
273. [270 - JDBC pt 19 - CallableStatement](#parte273)
274. [271 - JDBC pt 20 - Connected RowSet - JdbcRowSet pt 01](#parte274)
275. [272 - JDBC pt 21 - Connected RowSet - JdbcRowSet pt 02](#parte275)
276. [273 - JDBC pt 22 - Disconnected RowSet - CachedRowSet](#parte276)
277. [274 - JDBC pt 23 - Transa√ß√£o](#parte277)
278. [275 - JDBC pt 24 - CRUD pt 01 - findByName and findAll](#parte278)
279. [276 - JDBC pt 25 - CRUD pt 02 - delete](#parte279)
280. [277 - JDBC pt 26 - CRUD pt 03 - save](#parte280)
281. [278 - JDBC pt 27 - CRUD pt 04 - update](#parte281)
282. [279 - JDBC pt 28 - CRUD pt 05 - Anime Crud](#parte282)
283. [280 - Testes unit√°rios com jUnit pt 01](#parte283)
284. [281 - Testes unit√°rios com jUnit pt 02](#parte284)
285. [282 - Atualizando JDK](#parte285)
286. [283 - Record Class](#parte286)
287. [284 - Pattern Matching for instanceof](#parte287)
288. [285 - √â s√≥ correr pro abra√ßo](#parte288)
---


## <a name="parte1">1 - 000 - Maratona Java Virado No Jiraya - Bem-vindo</a>

https://www.youtube.com/watch?v=VKjFuX91G5Q



[Voltar ao √çndice](#indice)

---


## <a name="parte2">2 - 001 - O que esperar do curso</a>

https://www.youtube.com/watch?v=ooCqalwSpuE&list=PL62G310vn6nFIsOCC0H-C2infYgwm8SWW&index=2

[Voltar ao √çndice](#indice)

---


## <a name="parte3">3 - 002 - Como Java Funciona</a>

https://www.youtube.com/watch?v=ooCqalwSpuE&list=PL62G310vn6nFIsOCC0H-C2infYgwm8SWW&index=2

[Voltar ao √çndice](#indice)

---


## <a name="parte4">4 - 003 - Fazendo o download da JDK 15</a>

https://www.youtube.com/watch?v=Tsyeybeh968&list=PL62G310vn6nFIsOCC0H-C2infYgwm8SWW&index=4

https://www.codejava.net/java-se/java-se-versions-history



[Voltar ao √çndice](#indice)

---


## <a name="parte5">5 - 004 - Configurando variaveis de ambiente</a>

https://www.youtube.com/watch?v=xzAESAp_soQ&list=PL62G310vn6nFIsOCC0H-C2infYgwm8SWW&index=5

[Voltar ao √çndice](#indice)

---


## <a name="parte6">6 - 005 - Executando compila√ß√£o manualmente</a>

https://www.youtube.com/watch?v=E64JTsEyXCM&list=PL62G310vn6nFIsOCC0H-C2infYgwm8SWW&index=6

[Voltar ao √çndice](#indice)

---


## <a name="parte7">7 - 006 - Download da IDE IntelliJ Community</a>

https://www.youtube.com/watch?v=uB5Qbm-RMyU&list=PL62G310vn6nFIsOCC0H-C2infYgwm8SWW&index=7

[Voltar ao √çndice](#indice)

---


## <a name="parte8">8 - 007 - Conhecendo a IDE IntelliJ Community</a>

https://www.youtube.com/watch?v=ds3t9C2A50U&list=PL62G310vn6nFIsOCC0H-C2infYgwm8SWW&index=8

[Voltar ao √çndice](#indice)

---


## <a name="parte9">9 - 008 - Organizando o c√≥digo em pacotes</a>

https://www.youtube.com/watch?v=TnnS-R--WKc&list=PL62G310vn6nFIsOCC0H-C2infYgwm8SWW&index=9

```java
package net.josemalcher;

public class OlaDevDojo {
    public static void main(String[] args) {
        System.out.println("Ol√° mundo!!");
    }
}

```

[Voltar ao √çndice](#indice)

---


## <a name="parte10">10 - 009 - Coment√°rios</a>

https://www.youtube.com/watch?v=2rMT0qRyiYs&list=PL62G310vn6nFIsOCC0H-C2infYgwm8SWW&index=10

[Voltar ao √çndice](#indice)

---


## <a name="parte11">11 - 010 - Tipos primitivos pt 01 - conven√ß√µes de vari√°veis</a>

https://www.youtube.com/watch?v=RRHGYyJTTpQ&list=PL62G310vn6nFIsOCC0H-C2infYgwm8SWW&index=11


Todos os valores, na verdade, s√£o formados por bits e eles ficam na nossa mem√≥ria RAM. 
> Um pente de mem√≥ria RAM de 8gb (64,000,000,000bits).

Cada tipo primitivo utiliza uma quantidade fixa de bits para representar um valor na RAM. 
O tipo 'int' usa 4 bytes para representar n√∫meros. Isto √©, para representar n√∫meros, o 'int' utiliza 32 d√≠gitos bin√°rios (uns e zeros): 00000000000000000000000000000000

Com 32 bits, podemos representar um total de 4 bilh√µes e alguns milh√µes (2^32).
Por√©m, para acomodar tanto n√∫meros NEGATIVOS quanto POSITIVOS, esse valor √© "partido ao meio".
Consequentemente, uma vari√°vel do tipo 'int' pode armazenar, aproximadamente, cerca de 2 bilh√µes e 100 milh√µes:
int num = 2100000000;
// ou
int num = -2100000000;

Se a gente ultrapassar muito esse valor, teremos erro:
int num = 2800000000; // error

->> Esse erro ocorre porque o valor '2800000000' exige mais bits para ser representado.
E para resolver essa quest√£o, temos o tipo 'long'. O 'long' utiliza 8 bytes (64 bits) para armazenar valores, ent√£o, se precisarmos armazenar o n√∫mero '2800000000', usaremos o tipo 'long' e n√£o o 'int'

Al√©m disso, temos o 'byte' e o 'short'. N√£o vou me prolongar muito na explica√ß√£o, ent√£o vou abordar apenas o tipo 'byte'.
O 'byte' utiliza apenas 1 byte (8 bits - 00000000) para representar um valor. Portanto, vari√°veis do tipo 'byte' s√£o usadas para armazenar valores muito pequenos, por exemplo:
byte numzinho = 100 

Se tentarmos armazenar o valor de 200 numa vari√°vel do tipo 'byte', teremos um erro, j√° que o 200 requer mais bits para ser representado

FONTE: Coment√°rio do v√≠deo

Resumo

#### ‚úÖ Tipos Primitivos em Java

Java possui **8 tipos primitivos**, que s√£o a base para representar dados simples:

```
| Tipo      | Tamanho      | Exemplo de uso                          |
|-----------|--------------|-----------------------------------------|
| `byte`    | 8 bits       | Armazena n√∫meros pequenos (-128 a 127)  |
| `short`   | 16 bits      | N√∫meros inteiros maiores que `byte`     |
| `int`     | 32 bits      | Mais usado para n√∫meros inteiros        |
| `long`    | 64 bits      | N√∫meros inteiros muito grandes          |
| `float`   | 32 bits      | N√∫meros decimais com menos precis√£o     |
| `double`  | 64 bits      | N√∫meros decimais com mais precis√£o      |
| `char`    | 16 bits      | Um √∫nico caractere (ex: 'A', '9')       |
| `boolean` | 1 bit (l√≥gico) | Verdadeiro ou falso (`true` ou `false`) |
```
---

## üìù Conven√ß√µes de Vari√°veis em Java

Java √© **case-sensitive** e segue algumas conven√ß√µes de nomea√ß√£o (n√£o obrigat√≥rias, mas boas pr√°ticas):

- **camelCase** para nomes de vari√°veis e m√©todos:
  ```java
  int idadeDoUsuario;
  boolean isAtivo;
  ```

- **UPPER_CASE** para constantes:
  ```java
  final int MAX_TENTATIVAS = 3;
  ```

- **Nomes claros e significativos** (evitar `x`, `y`, `z`, a n√£o ser em exemplos matem√°ticos):
  ```java
  double salarioMensal;
  ```

- **N√£o usar palavras reservadas** como nome de vari√°vel (`int`, `class`, `public`, etc).


FONTE: CHATGPT


[Voltar ao √çndice](#indice)

---


## <a name="parte12">12 - 011 - Tipos primitivos pt 02 - declara√ß√£o e tamanho em mem√≥ria</a>

https://www.youtube.com/watch?v=veDgI_zZ7uk&list=PL62G310vn6nFIsOCC0H-C2infYgwm8SWW&index=12

Declara√ß√£o de vari√°veis primitivas: Como declarar e inicializar vari√°veis dos tipos byte, short, int, long, float, double, char e boolean.‚Äã
Universidade Java

Tamanho em mem√≥ria: Discuss√£o sobre o espa√ßo que cada tipo primitivo ocupa na mem√≥ria, por exemplo:

byte: 1 byte (8 bits)

short: 2 bytes (16 bits)

int: 4 bytes (32 bits)

long: 8 bytes (64 bits)

float: 4 bytes (32 bits)

double: 8 bytes (64 bits)

char: 2 bytes (16 bits)

boolean: 1 bit (valor l√≥gico true ou false)‚Äã

Import√¢ncia da escolha do tipo adequado: Explica√ß√£o sobre como a escolha correta do tipo primitivo pode impactar na performance e no uso eficiente da mem√≥ria.‚Äã

üìå Observa√ß√µes
A aula enfatiza a import√¢ncia de entender os tipos primitivos para uma programa√ß√£o eficiente e eficaz em Java.‚Äã

FONTE: CHATGPT

https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html

[Voltar ao √çndice](#indice)

---


## <a name="parte13">13 - 012 - Tipos primitivos pt 03 - casting</a>

https://www.youtube.com/watch?v=74hd4o7V328&list=PL62G310vn6nFIsOCC0H-C2infYgwm8SWW&index=13

## üß† CAST de Tipos Primitivos em Java

### ‚úÖ O que √© *Cast*?

O **casting** (ou convers√£o de tipos) √© o processo de **converter um valor de um tipo primitivo para outro**. Existem dois tipos de cast em Java:

- **Casting impl√≠cito (widening cast):** Quando convertendo de um tipo menor para um tipo maior.
- **Casting expl√≠cito (narrowing cast):** Quando convertendo de um tipo maior para um tipo menor. Nesse caso, voc√™ precisa informar a convers√£o de forma expl√≠cita.

---

### üìà Casting Impl√≠cito (Widening)

N√£o precisa de c√≥digo adicional. Acontece quando n√£o h√° risco de perda de dados.

```java
int num = 10;
long numeroMaior = num; // int -> long (OK)
double numeroDecimal = numeroMaior; // long -> double (OK)

System.out.println(numeroDecimal); // Sa√≠da: 10.0
```

#### ‚úÖ Por que funciona?
O tipo `long` pode armazenar todos os valores poss√≠veis de um `int`, e o `double` pode armazenar todos os valores poss√≠veis de um `long`.

---

### üìâ Casting Expl√≠cito (Narrowing)

Precisa de convers√£o manual porque h√° risco de perda de dados.

```java
double valorDecimal = 10.99;
int valorInteiro = (int) valorDecimal; // double -> int

System.out.println(valorInteiro); // Sa√≠da: 10
```

#### ‚ö†Ô∏è Cuidado!
Nesse exemplo, **o valor ap√≥s o ponto √© perdido**.

---

### üéØ Exemplo com perda de dados

```java
int valorGrande = 130;
byte valorPequeno = (byte) valorGrande; // int -> byte

System.out.println(valorPequeno); // Sa√≠da: -126
```

> `byte` vai de -128 a 127. Como `130` est√° fora desse intervalo, o valor √© "reciclado" e vira -126.

---

### üß™ Compara√ß√£o entre tipos e convers√£o

| De         | Para       | Precisa de Cast? | Risco de perda? |
|------------|------------|------------------|-----------------|
| byte       | short      | N√£o              | N√£o             |
| int        | long       | N√£o              | N√£o             |
| long       | int        | Sim              | Sim             |
| double     | float      | Sim              | Sim             |
| float      | double     | N√£o              | N√£o             |
| char       | int        | N√£o              | N√£o             |
| int        | char       | Sim              | Sim             |

---

### üí° Dica de ouro

Sempre que voc√™ estiver **reduzindo o tamanho do tipo**, pense:  
> ‚ÄúEstou avisando ao Java que **eu assumo o risco de perda de dados**‚Äù.

---

FONTE: CHATGPT

[Voltar ao √çndice](#indice)

---


## <a name="parte14">14 - 013 - Tipos primitivos pt 04 - Strings</a>

https://www.youtube.com/watch?v=13VfcFXwsjw&list=PL62G310vn6nFIsOCC0H-C2infYgwm8SWW&index=14

ÓàÄiÓàÇturn0image0ÓàÇturn0image1ÓàÇturn0image3ÓàÇturn0image5ÓàÅClaro! Aqui est√° um resumo em formato Markdown da aula **"13 - Tipos Primitivos pt 04 - Strings"** do curso Maratona Java do DevDojo, complementado com explica√ß√µes e exemplos pr√°ticos:

---

# Aula 13 ‚Äì Tipos Primitivos pt 04: Strings

üì∫ **Link do v√≠deo:** [Assista no YouTube](https://www.youtube.com/watch?v=13VfcFXwsjw)

### üß† Conte√∫do Abordado

Nesta aula, o instrutor William Suane introduz o tipo `String` em Java, destacando que, embora n√£o seja um tipo primitivo, √© amplamente utilizado e possui caracter√≠sticas especiais. Os principais pontos abordados incluem:

- **Declara√ß√£o e inicializa√ß√£o de Strings:**
  ```java
  String nome = "DevDojo";
  ```
 
Aqui, a vari√°vel `nome` √© uma refer√™ncia a um objeto do tipo `String` contendo o valor `"DevDojo".

- **Imutabilidade das Strings:**
 Em Java, as Strings s√£o objetos imut√°veis. Isso significa que, uma vez criada, uma `String` n√£o pode ser alterada. Qualquer opera√ß√£o que pare√ßa modificar uma `String` na verdade cria uma nova inst√¢nci.

- **Concatena√ß√£o de Strings:**
 A aula demonstra como concatenar Strings utilizando o operador `+:
  ```java
  String saudacao = "Ol√°, ";
  String nome = "Mundo!";
  String mensagem = saudacao + nome;
  System.out.println(mensagem); // Sa√≠da: Ol√°, Mundo!
  ```


- **Uso de caracteres especiais:**
 Para incluir caracteres especiais em Strings, utiliza-se a barra invertida (`\`) como caractere de escap:
  ```java
  String texto = "Ele disse: \"Java √© incr√≠vel!\"";
  System.out.println(texto); // Sa√≠da: Ele disse: "Java √© incr√≠vel!"
  ```


---

### üìö Complemento: M√©todos Comuns da Classe String

Al√©m dos conceitos abordados na aula, √© importante conhecer alguns m√©todos √∫teis da classe `String`:

- **`length()`**: Retorna o comprimento da Strig.
  ```java
  String texto = "Java";
  int tamanho = texto.length(); // tamanho = 4
  ```


- **`toUpperCase()` e `toLowerCase()`**: Convertem a String para letras mai√∫sculas ou min√∫sculas, respectivamene.
  ```java
  String original = "DevDojo";
  String maiuscula = original.toUpperCase(); // "DEVDOJO"
  String minuscula = original.toLowerCase(); // "devdojo"
  ```


- **`substring(int beginIndex, int endIndex)`**: Retorna uma nova String que √© uma subsequ√™ncia da originl.
  ```java
  String texto = "Maratona Java";
  String parte = texto.substring(9, 13); // "Java"
  ```


- **`equals(String anotherString)`**: Compara o conte√∫do de duas Strins.
  ```java
  String a = "Java";
  String b = "java";
  boolean iguais = a.equals(b); // false
  ```


- **`equalsIgnoreCase(String anotherString)`**: Compara o conte√∫do de duas Strings, ignorando diferen√ßas entre mai√∫sculas e min√∫sculs.
  ```java
  boolean iguaisIgnorandoCase = a.equalsIgnoreCase(b); // true
  ```


- **`trim()`**: Remove espa√ßos em branco do in√≠cio e do fim da Strig.
  ```java
  String texto = "  DevDojo  ";
  String ajustado = texto.trim(); // "DevDojo"
  ```


---

## üîç Observa√ß√µes Importantes
- Embora `String` n√£o seja um tipo primitivo, √© tratado de forma especial em Java devido √† sua ampla utiliza√£o.
- A imutabilidade das Strings √© uma caracter√≠stica que oferece seguran√ßa e facilita o uso em ambientes concorrentes, mas pode impactar a performance em opera√ß√µes intensivas de concatena√ß√£o. Nesses casos, √© recomend√°vel utilizar classes como `StringBuilder` ou `StringBuffr`.

---


[Voltar ao √çndice](#indice)

---


## <a name="parte15">15 - 014 - Tipos primitivos pt 05 - Exerc√≠cio</a>

https://www.youtube.com/watch?v=Q0REhCVBvAg&list=PL62G310vn6nFIsOCC0H-C2infYgwm8SWW&index=15



[Voltar ao √çndice](#indice)

---


## <a name="parte16">16 - 015 - Operadores pt 01 - Aritim√©ticos</a>

https://www.youtube.com/watch?v=1Fsvlted69g&list=PL62G310vn6nFIsOCC0H-C2infYgwm8SWW&index=16

# Aula 15 ‚Äì Operadores pt 01: Aritm√©ticos

## üß† Conte√∫do Abordado

Nesta aula, o instrutor William Suane introduz os operadores aritm√©ticos em Java, que s√£o utilizados para realizar opera√ß√µes matem√°ticas b√°sicas. Os principais operadores abordados incluem:

- **Adi√ß√£o (`+`)**: Soma dois valores.
- **Subtra√ß√£o (`-`)**: Subtrai o segundo valor do primeiro.
- **Multiplica√ß√£o (`*`)**: Multiplica dois valores.
- **Divis√£o (`/`)**: Divide o primeiro valor pelo segundo.
- **M√≥dulo (`%`)**: Retorna o resto da divis√£o do primeiro valor pelo segundo.

## üìù Exemplos Pr√°ticos

```java
int a = 10;
int b = 3;

int soma = a + b;          // 13
int subtracao = a - b;     // 7
int multiplicacao = a * b; // 30
int divisao = a / b;       // 3
int modulo = a % b;        // 1

System.out.println("Soma: " + soma);
System.out.println("Subtra√ß√£o: " + subtracao);
System.out.println("Multiplica√ß√£o: " + multiplicacao);
System.out.println("Divis√£o: " + divisao);
System.out.println("M√≥dulo: " + modulo);
```

## ‚ö†Ô∏è Observa√ß√µes Importantes

- **Divis√£o entre inteiros**: Ao dividir dois n√∫meros inteiros, o resultado tamb√©m ser√° um n√∫mero inteiro, descartando qualquer parte decimal.
- **Divis√£o por zero**: Tentar dividir um n√∫mero inteiro por zero resultar√° em uma exce√ß√£o (`ArithmeticException`).
- **Uso do m√≥dulo**: O operador `%` √© √∫til para determinar se um n√∫mero √© par ou √≠mpar, entre outras aplica√ß√µes.

---

## üìö Complemento: Preced√™ncia de Operadores

Em express√µes com m√∫ltiplos operadores, a ordem de execu√ß√£o segue a preced√™ncia dos operadores:

1. Multiplica√ß√£o (`*`), Divis√£o (`/`) e M√≥dulo (`%`)
2. Adi√ß√£o (`+`) e Subtra√ß√£o (`-`)

Operadores com a mesma preced√™ncia s√£o avaliados da esquerda para a direita.

### üß™ Exemplo de Preced√™ncia

```java
int resultado = 10 + 5 * 2; // Resultado: 20
```

Neste exemplo, a multiplica√ß√£o √© realizada antes da adi√ß√£o.

Para alterar a ordem de execu√ß√£o, utilize par√™nteses:

```java
int resultado = (10 + 5) * 2; // Resultado: 30
```


[Voltar ao √çndice](#indice)

---


## <a name="parte17">17 - 016 - Operadores pt 02 - Relacionais</a>

# Aula 16 ‚Äì Operadores pt 02: Relacionais

üì∫ **Link do v√≠deo:** [Assista no YouTube](https://www.youtube.com/watch?v=U390IaCtOUk)

## üß† Conte√∫do Abordado

Nesta aula, o instrutor William Suane apresenta os **operadores relacionais** em Java, que s√£o utilizados para comparar dois valores e retornam um resultado booleano (`true` ou `false`).

### üîé Operadores Relacionais em Java

| Operador | Descri√ß√£o         | Exemplo (`a = 10`, `b = 20`) |
|----------|-------------------|------------------------------|
| `==`     | Igual a           | `a == b` ‚Üí `false`           |
| `!=`     | Diferente de      | `a != b` ‚Üí `true`            |
| `>`      | Maior que         | `a > b` ‚Üí `false`            |
| `<`      | Menor que         | `a < b` ‚Üí `true`             |
| `>=`     | Maior ou igual a  | `a >= b` ‚Üí `false`           |
| `<=`     | Menor ou igual a  | `a <= b` ‚Üí `true`            |

Esses operadores s√£o frequentemente utilizados em estruturas de controle, como `if`, `else if`, `while` e `for`, para tomar decis√µes baseadas em compara√ß√µes.

### üìù Exemplos Pr√°ticos

```java
int idade = 18;

if (idade >= 18) {
    System.out.println("Voc√™ √© maior de idade.");
} else {
    System.out.println("Voc√™ √© menor de idade.");
}
```

```java
int numero1 = 10;
int numero2 = 20;

System.out.println(numero1 == numero2); // false
System.out.println(numero1 != numero2); // true
System.out.println(numero1 > numero2);  // false
System.out.println(numero1 < numero2);  // true
```

---

## üìö Complemento: Compara√ß√£o de Strings

Em Java, para comparar o conte√∫do de duas strings, deve-se utilizar o m√©todo `.equals()`, pois o operador `==` verifica se as refer√™ncias apontam para o mesmo objeto na mem√≥ria.

```java
String nome1 = "Java";
String nome2 = "Java";

System.out.println(nome1 == nome2);       // true (pode ser true devido ao pool de strings)
System.out.println(nome1.equals(nome2));  // true

String nome3 = new String("Java");
System.out.println(nome1 == nome3);       // false
System.out.println(nome1.equals(nome3));  // true
```

---

## ‚ö†Ô∏è Observa√ß√µes Importantes

- **Resultado Booleano:** Todos os operadores relacionais retornam um valor do tipo `boolean`.

- **Compara√ß√£o de Tipos Diferentes:** Ao comparar tipos diferentes, o Java realiza a promo√ß√£o de tipos para fazer a compara√ß√£o.

- **Uso em Estruturas de Controle:** S√£o amplamente utilizados em estruturas como `if`, `while`, `for`, entre outras, para controlar o fluxo do programa com base em condi√ß√µes.


[Voltar ao √çndice](#indice)

---


## <a name="parte18">18 - 017 - Operadores pt 03 - L√≥gicos AND</a>


# Aula 17 ‚Äì Operadores pt 03: L√≥gicos AND (`&&`)

üì∫ **Link do v√≠deo:** [Assista no YouTube](https://www.youtube.com/watch?v=cT6sw-Pw4l0)

## üß† Conte√∫do Abordado

Nesta aula, o instrutor William Suane apresenta o operador l√≥gico **AND (`&&`)** em Java, que √© utilizado para combinar duas express√µes booleanas. O resultado ser√° `true` apenas se **ambas** as express√µes forem verdadeiras.

### üîé Operador L√≥gico AND (`&&`)

- **Defini√ß√£o:** O operador `&&` retorna `true` se **ambas** as express√µes forem verdadeiras; caso contr√°rio, retorna `false`.

- **Curto-circuito:** O operador `&&` √© conhecido por seu comportamento de curto-circuito. Isso significa que, se a primeira express√£o for `false`, a segunda express√£o **n√£o ser√° avaliada**, pois o resultado final j√° ser√° `false`.

## üìù Exemplos Pr√°ticos

```java
int idade = 25;
float salario = 3500.0f;

boolean isAprovado = idade >= 18 && salario >= 3000;
System.out.println("Aprovado? " + isAprovado); // true
```

```java
int idade = 16;
float salario = 4000.0f;

boolean isAprovado = idade >= 18 && salario >= 3000;
System.out.println("Aprovado? " + isAprovado); // false
```

## ‚ö†Ô∏è Observa√ß√µes Importantes

- **Avalia√ß√£o Condicional:** Devido ao comportamento de curto-circuito, √© poss√≠vel evitar erros em certas situa√ß√µes. Por exemplo:

```java
int x = 0;
if (x != 0 && (10 / x) > 1) {
    System.out.println("Condi√ß√£o verdadeira");
}
```

Neste exemplo, a segunda condi√ß√£o `(10 / x) > 1` **n√£o ser√° avaliada** se `x != 0` for `false`, evitando assim uma divis√£o por zero.

## üìö Complemento: Operadores L√≥gicos em Java

Al√©m do operador `&&`, Java possui outros operadores l√≥gicos:

- `||` (OR l√≥gico): Retorna `true` se **pelo menos uma** das express√µes for verdadeira.
- `!` (NOT l√≥gico): Inverte o valor l√≥gico da express√£o.
- `^` (XOR l√≥gico): Retorna `true` se **apenas uma** das express√µes for verdadeira.

### üß™ Exemplo com `||`:

```java
boolean temCarteira = true;
boolean temIdade = false;

if (temCarteira || temIdade) {
    System.out.println("Pode dirigir");
} else {
    System.out.println("N√£o pode dirigir");
}
```

[Voltar ao √çndice](#indice)

---


## <a name="parte19">19 - 018 - Operadores pt 04 - L√≥gicos OR</a>


# Aula 18 ‚Äì Operadores pt 04: L√≥gicos OR (`||`)

üì∫ **Link do v√≠deo:** [Assista no YouTube](https://www.youtube.com/watch?v=ELcO4DN7lxw)

## üß† Conte√∫do Abordado

Nesta aula, o instrutor William Suane apresenta o operador l√≥gico **OR (`||`)** em Java, que √© utilizado para combinar duas express√µes booleanas. O resultado ser√° `true` se **pelo menos uma** das express√µes for verdadeira.

### üîé Operador L√≥gico OR (`||`)

- **Defini√ß√£o:** O operador `||` retorna `true` se **pelo menos uma** das express√µes for verdadeira; retorna `false` somente se **ambas** forem falsas.

- **Curto-circuito:** O operador `||` possui comportamento de curto-circuito. Isso significa que, se a primeira express√£o for `true`, a segunda express√£o **n√£o ser√° avaliada**, pois o resultado final j√° ser√° `true`.

## üìù Exemplos Pr√°ticos

```java
int idade = 16;
float salario = 4000.0f;

boolean isAprovado = idade >= 18 || salario >= 3000;
System.out.println("Aprovado? " + isAprovado); // true
```

```java
int idade = 16;
float salario = 2500.0f;

boolean isAprovado = idade >= 18 || salario >= 3000;
System.out.println("Aprovado? " + isAprovado); // false
```

## ‚ö†Ô∏è Observa√ß√µes Importantes

- **Avalia√ß√£o Condicional:** Devido ao comportamento de curto-circuito, √© poss√≠vel evitar erros em certas situa√ß√µes. Por exemplo:

```java
String texto = null;
if (texto != null || texto.length() > 0) {
    System.out.println("Texto v√°lido");
}
```

Neste exemplo, a segunda condi√ß√£o `texto.length() > 0` **n√£o ser√° avaliada** se `texto != null` for `true`, evitando assim um `NullPointerException`.

## üìö Complemento: Operadores L√≥gicos em Java

Al√©m do operador `||`, Java possui outros operadores l√≥gicos:

- `&&` (AND l√≥gico): Retorna `true` se **ambas** as express√µes forem verdadeiras.
- `!` (NOT l√≥gico): Inverte o valor l√≥gico da express√£o.
- `^` (XOR l√≥gico): Retorna `true` se **apenas uma** das express√µes for verdadeira.

### üß™ Exemplo com `&&`:

```java
boolean temCarteira = true;
boolean temIdade = false;

if (temCarteira && temIdade) {
    System.out.println("Pode dirigir");
} else {
    System.out.println("N√£o pode dirigir");
}
```


[Voltar ao √çndice](#indice)

---


## <a name="parte20">20 - 019 - Operadores pt 05 - Atribui√ß√£o</a>

# Aula 19 ‚Äì Operadores pt 05: Atribui√ß√£o

üì∫ **Link do v√≠deo:** [Assista no YouTube](https://www.youtube.com/watch?v=EFrq1WxsL1k)

## üß† Conte√∫do Abordado

Nesta aula, o instrutor William Suane apresenta os **operadores de atribui√ß√£o** em Java, que s√£o utilizados para atribuir valores a vari√°veis. Existem dois tipos principais:

### üîπ Atribui√ß√£o Simples (`=`)

- **Defini√ß√£o:** Atribui o valor da express√£o √† direita para a vari√°vel √† esquerda.
- **Exemplo:**

  ```java
  int idade = 25;
  String nome = "Jo√£o";
  double salario = 3500.50;
  ```

### üîπ Atribui√ß√£o Composta

- **Defini√ß√£o:** Combina um operador aritm√©tico com a atribui√ß√£o, simplificando express√µes.
- **Operadores Comuns:**

  | Operador | Equivalente a     | Exemplo             |
  |----------|-------------------|---------------------|
  | `+=`     | `x = x + y`       | `x += y;`           |
  | `-=`     | `x = x - y`       | `x -= y;`           |
  | `*=`     | `x = x * y`       | `x *= y;`           |
  | `/=`     | `x = x / y`       | `x /= y;`           |
  | `%=`     | `x = x % y`       | `x %= y;`           |

- **Exemplo:**

  ```java
  int x = 10;
  x += 5; // x agora √© 15
  x *= 2; // x agora √© 30
  ```

## ‚ö†Ô∏è Observa√ß√µes Importantes

- **Tipo de Dados:** O tipo da express√£o √† direita deve ser compat√≠vel com o tipo da vari√°vel √† esquerda.
- **Atribui√ß√£o M√∫ltipla:** √â poss√≠vel realizar atribui√ß√µes encadeadas:

  ```java
  int a, b, c;
  a = b = c = 100;
  ```

  Neste exemplo, todas as vari√°veis `a`, `b` e `c` receber√£o o valor `100`.

## üìö Complemento: Operadores de Atribui√ß√£o Bit a Bit

Al√©m dos operadores mencionados, Java possui operadores de atribui√ß√£o bit a bit:

| Operador | Descri√ß√£o                 | Exemplo             |
|----------|---------------------------|---------------------|
| `&=`     | AND bit a bit e atribui   | `x &= y;`           |
| `|=`     | OR bit a bit e atribui    | `x |= y;`           |
| `^=`     | XOR bit a bit e atribui   | `x ^= y;`           |
| `<<=`    | Desloca bits √† esquerda   | `x <<= 2;`          |
| `>>=`    | Desloca bits √† direita    | `x >>= 2;`          |
| `>>>=`   | Desloca bits √† direita sem sinal | `x >>>= 2;`    |

Esses operadores s√£o √∫teis em opera√ß√µes de baixo n√≠vel, como manipula√ß√£o de bits e desenvolvimento de sistemas embarcados.


[Voltar ao √çndice](#indice)

---


## <a name="parte21">21 - 020 - Estruturas Condicionais pt 01 - IF</a>

# Aula 20 ‚Äì Estruturas Condicionais pt 01: IF

üì∫ **Link do v√≠deo:** [Assista no YouTube](https://www.youtube.com/watch?v=gk1_Pn8GZA4)

## üß† Conte√∫do Abordado

Nesta aula, o instrutor William Suane apresenta a estrutura condicional **`if`** em Java, que permite executar blocos de c√≥digo com base em condi√ß√µes booleanas.

### üîπ Estrutura do `if`

- **Defini√ß√£o:** O `if` √© utilizado para verificar se uma condi√ß√£o √© verdadeira. Se for, o bloco de c√≥digo dentro do `if` √© executado.

- **Sintaxe:**

  ```java
  if (condi√ß√£o) {
      // bloco de c√≥digo a ser executado se a condi√ß√£o for verdadeira
  }
  ```

### üîπ Exemplo Pr√°tico

```java
int idade = 18;

if (idade >= 18) {
    System.out.println("Voc√™ √© maior de idade.");
}
```

Neste exemplo, a mensagem ser√° exibida apenas se a vari√°vel `idade` for maior ou igual a 18.

## ‚ö†Ô∏è Observa√ß√µes Importantes

- **Avalia√ß√£o de Condi√ß√µes:** A condi√ß√£o dentro do `if` deve resultar em um valor booleano (`true` ou `false`).

- **Uso de Chaves `{}`:** Embora n√£o seja obrigat√≥rio usar chaves `{}` quando h√° apenas uma instru√ß√£o dentro do `if`, √© uma boa pr√°tica utiliz√°-las para melhorar a legibilidade e evitar erros.

  ```java
  // Sem chaves - v√°lido, mas n√£o recomendado
  if (idade >= 18)
      System.out.println("Maior de idade.");

  // Com chaves - recomendado
  if (idade >= 18) {
      System.out.println("Maior de idade.");
  }
  ```

## üìö Complemento: Estruturas Condicionais em Java

Al√©m do `if`, Java oferece outras estruturas condicionais:

- **`if-else`:** Executa um bloco de c√≥digo se a condi√ß√£o for verdadeira e outro bloco se for falsa.

  ```java
  if (condi√ß√£o) {
      // bloco se condi√ß√£o for verdadeira
  } else {
      // bloco se condi√ß√£o for falsa
  }
  ```

- **`if-else if-else`:** Permite verificar m√∫ltiplas condi√ß√µes em sequ√™ncia.

  ```java
  if (condi√ß√£o1) {
      // bloco se condi√ß√£o1 for verdadeira
  } else if (condi√ß√£o2) {
      // bloco se condi√ß√£o2 for verdadeira
  } else {
      // bloco se nenhuma condi√ß√£o anterior for verdadeira
  }
  ```

- **`switch`:** Ideal para verificar a igualdade de uma vari√°vel contra m√∫ltiplos valores.

  ```java
  switch (vari√°vel) {
      case valor1:
          // bloco para valor1
          break;
      case valor2:
          // bloco para valor2
          break;
      default:
          // bloco se nenhum caso anterior for correspondente
  }
  ```


[Voltar ao √çndice](#indice)

---


## <a name="parte22">22 - 021 - Estruturas Condicionais pt 02 - ELSE IF</a>

# Aula 21 ‚Äì Estruturas Condicionais pt 02: ELSE IF

üì∫ **Link do v√≠deo:** [Assista no YouTube](https://www.youtube.com/watch?v=exxeNsgcg3c)

## üß† Conte√∫do Abordado

Nesta aula, o instrutor William Suane apresenta a estrutura condicional **`else if`** em Java, que permite verificar m√∫ltiplas condi√ß√µes em sequ√™ncia. Essa estrutura √© √∫til quando h√° mais de duas possibilidades a serem avaliadas.

### üîπ Estrutura do `if-else if-else`

- **Defini√ß√£o:** Permite testar v√°rias condi√ß√µes em sequ√™ncia. A primeira condi√ß√£o verdadeira ter√° seu bloco de c√≥digo executado, e as demais ser√£o ignoradas.

- **Sintaxe:**

  ```java
  if (condi√ß√£o1) {
      // bloco de c√≥digo se condi√ß√£o1 for verdadeira
  } else if (condi√ß√£o2) {
      // bloco de c√≥digo se condi√ß√£o2 for verdadeira
  } else {
      // bloco de c√≥digo se nenhuma das condi√ß√µes anteriores for verdadeira
  }
  ```

### üîπ Exemplo Pr√°tico

```java
int nota = 85;

if (nota >= 90) {
    System.out.println("Excelente");
} else if (nota >= 75) {
    System.out.println("Bom");
} else if (nota >= 60) {
    System.out.println("Regular");
} else {
    System.out.println("Reprovado");
}
```

Neste exemplo, a vari√°vel `nota` √© avaliada em diferentes faixas, e a mensagem correspondente √© exibida com base na condi√ß√£o satisfeita.

## ‚ö†Ô∏è Observa√ß√µes Importantes

- **Ordem das Condi√ß√µes:** As condi√ß√µes devem ser organizadas da mais restritiva para a mais abrangente para evitar que condi√ß√µes mais gerais sejam avaliadas antes das espec√≠ficas.

- **Avalia√ß√£o Sequencial:** Assim que uma condi√ß√£o √© satisfeita, as demais n√£o s√£o avaliadas. Portanto, a ordem das condi√ß√µes √© crucial.

## üìö Complemento: Estrutura `if-else if` em Java

- A estrutura `if-else if` √© conhecida como "if-else-if ladder" em Java. Ela permite que o programa escolha entre v√°rias alternativas com base em diferentes condi√ß√µes.

- √â uma alternativa ao uso de m√∫ltiplas estruturas `if-else` aninhadas, proporcionando um c√≥digo mais limpo e leg√≠vel.


[Voltar ao √çndice](#indice)

---


## <a name="parte23">23 - 022 - Estruturas Condicionais pt 03 - Operador tern√°rio</a>


# Aula 22 ‚Äì Estruturas Condicionais pt 03: Operador Tern√°rio

üì∫ **Link do v√≠deo:** [Assista no YouTube](https://www.youtube.com/watch?v=gU-qCpBC5jk)

## üß† Conte√∫do Abordado

Nesta aula, o instrutor William Suane apresenta o **operador tern√°rio** em Java, uma forma concisa de escrever express√µes condicionais simples, substituindo estruturas `if-else` em uma √∫nica linha.

### üîπ Sintaxe do Operador Tern√°rio

```java
condi√ß√£o ? express√£o_se_verdadeiro : express√£o_se_falso;
```

- **condi√ß√£o**: Uma express√£o que retorna `true` ou `false`.
- **express√£o_se_verdadeiro**: Executada se a condi√ß√£o for verdadeira.
- **express√£o_se_falso**: Executada se a condi√ß√£o for falsa.

### üîπ Exemplo Pr√°tico

```java
int idade = 18;
String mensagem = (idade >= 18) ? "Voc√™ √© maior de idade." : "Voc√™ √© menor de idade.";
System.out.println(mensagem);
```

Neste exemplo, a vari√°vel `mensagem` recebe um valor com base na condi√ß√£o `idade >= 18`.

### üîπ Compara√ß√£o com `if-else`

```java
// Usando if-else
if (idade >= 18) {
    mensagem = "Voc√™ √© maior de idade.";
} else {
    mensagem = "Voc√™ √© menor de idade.";
}

// Usando operador tern√°rio
mensagem = (idade >= 18) ? "Voc√™ √© maior de idade." : "Voc√™ √© menor de idade.";
```

Ambas as abordagens produzem o mesmo resultado, mas o operador tern√°rio oferece uma sintaxe mais enxuta.

## ‚ö†Ô∏è Observa√ß√µes Importantes

- **Legibilidade**: O operador tern√°rio √© ideal para condi√ß√µes simples. Para l√≥gica mais complexa, o uso de `if-else` √© recomendado para manter a clareza do c√≥digo.
- **Tipo de Retorno**: As express√µes `express√£o_se_verdadeiro` e `express√£o_se_falso` devem retornar valores compat√≠veis com o tipo da vari√°vel que receber√° o resultado.
- **Aninhamento**: √â poss√≠vel aninhar operadores tern√°rios, mas isso pode comprometer a legibilidade do c√≥digo.

### üîπ Exemplo de Aninhamento

```java
int nota = 85;
String resultado = (nota >= 90) ? "Excelente" :
                   (nota >= 75) ? "Bom" :
                   (nota >= 60) ? "Regular" : "Reprovado";
System.out.println("Desempenho: " + resultado);
```

Neste exemplo, m√∫ltiplas condi√ß√µes s√£o avaliadas em sequ√™ncia para determinar o desempenho com base na nota.

## üìö Complemento: Quando Usar o Operador Tern√°rio

- **Atribui√ß√µes Simples**: Ideal para atribuir valores a vari√°veis com base em uma condi√ß√£o.

  ```java
  int numero = 10;
  String paridade = (numero % 2 == 0) ? "Par" : "√çmpar";
  ```

- **Retorno de M√©todos**: Pode ser utilizado para retornar valores diretamente de m√©todos.

  ```java
  public String verificarIdade(int idade) {
      return (idade >= 18) ? "Maior de idade" : "Menor de idade";
  }
  ```

- **Evitar Uso Excessivo**: Para condi√ß√µes complexas ou m√∫ltiplas, prefira estruturas `if-else` para manter a legibilidade.


[Voltar ao √çndice](#indice)

---


## <a name="parte24">24 - 023 - Estruturas Condicionais pt 04 - Tabela Verdade e exerc√≠cio</a>

# Aula 23 ‚Äì Estruturas Condicionais pt 04: Tabela Verdade e Exerc√≠cio

üì∫ **Link do v√≠deo:** [Assista no YouTube](https://www.youtube.com/watch?v=Y3ODYE3npgo)

## üß† Conte√∫do Abordado

Nesta aula, o instrutor William Suane apresenta a **tabela verdade** dos operadores l√≥gicos `&&` (E l√≥gico) e `||` (OU l√≥gico) em Java, al√©m de propor um exerc√≠cio pr√°tico para fixar o conhecimento.

### üîπ Tabela Verdade dos Operadores L√≥gicos

#### Operador `&&` (E l√≥gico)

| Condi√ß√£o 1 | Condi√ß√£o 2 | Resultado |
|------------|------------|-----------|
| false      | false      | false     |
| false      | true       | false     |
| true       | false      | false     |
| true       | true       | true      |

- **Comportamento:** O resultado √© `true` apenas se **ambas** as condi√ß√µes forem verdadeiras.

#### Operador `||` (OU l√≥gico)

| Condi√ß√£o 1 | Condi√ß√£o 2 | Resultado |
|------------|------------|-----------|
| false      | false      | false     |
| false      | true       | true      |
| true       | false      | true      |
| true       | true       | true      |

- **Comportamento:** O resultado √© `true` se **pelo menos uma** das condi√ß√µes for verdadeira.

### üîπ Exerc√≠cio Proposto

**Objetivo:** Determinar se um funcion√°rio pode receber aux√≠lio com base em seu sal√°rio e dependentes.

**Crit√©rios:**

- **Sal√°rio Baixo:** Sal√°rio menor que R$ 2000.00
- **Muitos Dependentes:** Mais de 2 dependentes

**Implementa√ß√£o:**

```java
public class Auxilio {
    public static void main(String[] args) {
        double salario = 1900.0;
        int dependentes = 3;

        boolean salarioBaixo = salario < 2000.0;
        boolean muitosDependentes = dependentes > 2;

        if (salarioBaixo && muitosDependentes) {
            System.out.println("Funcion√°rio deve receber aux√≠lio.");
        } else {
            System.out.println("Funcion√°rio n√£o se enquadra para o aux√≠lio.");
        }
    }
}
```

**Explica√ß√£o:**

- As vari√°veis `salarioBaixo` e `muitosDependentes` armazenam os resultados das condi√ß√µes.
- O `if` verifica se **ambas** as condi√ß√µes s√£o verdadeiras usando o operador `&&`.
- Se ambas forem verdadeiras, o funcion√°rio tem direito ao aux√≠lio.

## ‚ö†Ô∏è Observa√ß√µes Importantes

- **Avalia√ß√£o Curta-Circuito:**
  - No operador `&&`, se a primeira condi√ß√£o for `false`, a segunda **n√£o √© avaliada**, pois o resultado j√° ser√° `false`.
  - No operador `||`, se a primeira condi√ß√£o for `true`, a segunda **n√£o √© avaliada**, pois o resultado j√° ser√° `true`.

- **Boa Pr√°tica:**
  - Utilizar vari√°veis booleanas intermedi√°rias (`salarioBaixo`, `muitosDependentes`) melhora a legibilidade e facilita a manuten√ß√£o do c√≥digo.



[Voltar ao √çndice](#indice)

---


## <a name="parte25">25 - 024 - Estruturas Condicionais pt 05 - Resolu√ß√£o do exerc√≠cios</a>

# Aula 24 ‚Äì Estruturas Condicionais pt 05: Resolu√ß√£o do Exerc√≠cio

üì∫ **Link do v√≠deo:** [Assista no YouTube](https://www.youtube.com/watch?v=W-ng6Dqa-E4)

## üß† Conte√∫do Abordado

Nesta aula, o instrutor William Suane apresenta a resolu√ß√£o do exerc√≠cio proposto na aula anterior, utilizando estruturas condicionais em Java para determinar se um funcion√°rio deve receber aux√≠lio com base em seu sal√°rio e n√∫mero de dependentes.

### üîπ Relembrando o Exerc√≠cio

**Objetivo:** Determinar se um funcion√°rio deve receber aux√≠lio.

**Crit√©rios:**

- **Sal√°rio Baixo:** Sal√°rio menor que R$ 2000.00
- **Muitos Dependentes:** Mais de 2 dependentes

### üîπ Implementa√ß√£o em Java

```java
public class Auxilio {
    public static void main(String[] args) {
        double salario = 1900.0;
        int dependentes = 3;

        boolean salarioBaixo = salario < 2000.0;
        boolean muitosDependentes = dependentes > 2;

        if (salarioBaixo && muitosDependentes) {
            System.out.println("Funcion√°rio deve receber aux√≠lio.");
        } else {
            System.out.println("Funcion√°rio n√£o se enquadra para o aux√≠lio.");
        }
    }
}
```

**Explica√ß√£o:**

- As vari√°veis `salarioBaixo` e `muitosDependentes` armazenam os resultados das condi√ß√µes.
- O `if` verifica se **ambas** as condi√ß√µes s√£o verdadeiras usando o operador `&&`.
- Se ambas forem verdadeiras, o funcion√°rio tem direito ao aux√≠lio.

### üîπ Utilizando o Operador Tern√°rio

Para tornar o c√≥digo mais conciso, √© poss√≠vel utilizar o operador tern√°rio:

```java
public class Auxilio {
    public static void main(String[] args) {
        double salario = 1900.0;
        int dependentes = 3;

        String resultado = (salario < 2000.0 && dependentes > 2) 
            ? "Funcion√°rio deve receber aux√≠lio." 
            : "Funcion√°rio n√£o se enquadra para o aux√≠lio.";

        System.out.println(resultado);
    }
}
```

**Explica√ß√£o:**

- O operador tern√°rio avalia a condi√ß√£o `(salario < 2000.0 && dependentes > 2)`.
- Se verdadeira, retorna "Funcion√°rio deve receber aux√≠lio."
- Caso contr√°rio, retorna "Funcion√°rio n√£o se enquadra para o aux√≠lio."

## ‚ö†Ô∏è Observa√ß√µes Importantes

- **Avalia√ß√£o Curta-Circuito:**
  - No operador `&&`, se a primeira condi√ß√£o for `false`, a segunda **n√£o √© avaliada**, pois o resultado j√° ser√° `false`.
  - No operador `||`, se a primeira condi√ß√£o for `true`, a segunda **n√£o √© avaliada**, pois o resultado j√° ser√° `true`.

- **Boas Pr√°ticas:**
  - Utilizar vari√°veis booleanas intermedi√°rias (`salarioBaixo`, `muitosDependentes`) melhora a legibilidade e facilita a manuten√ß√£o do c√≥digo.
  - O operador tern√°rio √© ideal para condi√ß√µes simples. Para l√≥gica mais complexa, prefira estruturas `if-else` para manter a clareza do c√≥digo.



[Voltar ao √çndice](#indice)

---


## <a name="parte26">26 - 025 - Estruturas Condicionais pt 06 - Switch</a>

# Aula 25 ‚Äì Estruturas Condicionais pt 06: Switch

üì∫ **Link do v√≠deo:** [Assista no YouTube](https://www.youtube.com/watch?v=AYMtqJSrQTU)

## üß† Conte√∫do Abordado

Nesta aula, o instrutor William Suane apresenta a estrutura condicional `switch` em Java, que permite executar diferentes blocos de c√≥digo com base no valor de uma vari√°vel, oferecendo uma alternativa mais organizada ao uso de m√∫ltiplos `if-else`.

### üîπ Sintaxe do `switch`

```java
switch (express√£o) {
    case valor1:
        // c√≥digo a ser executado
        break;
    case valor2:
        // c√≥digo a ser executado
        break;
    // outros casos
    default:
        // c√≥digo a ser executado se nenhum caso for satisfeito
}
```

- **express√£o**: Pode ser do tipo `byte`, `short`, `char`, `int`, `String` ou `enum`.
- **case**: Cada `case` compara o valor da express√£o com um valor constante.
- **break**: Impede o *fall-through*, ou seja, evita que a execu√ß√£o continue nos pr√≥ximos casos.
- **default**: Executado quando nenhum `case` corresponde ao valor da express√£o.

### üîπ Exemplo Pr√°tico

```java
public class DiaDaSemana {
    public static void main(String[] args) {
        int dia = 3;
        switch (dia) {
            case 1:
                System.out.println("Domingo");
                break;
            case 2:
                System.out.println("Segunda-feira");
                break;
            case 3:
                System.out.println("Ter√ßa-feira");
                break;
            case 4:
                System.out.println("Quarta-feira");
                break;
            case 5:
                System.out.println("Quinta-feira");
                break;
            case 6:
                System.out.println("Sexta-feira");
                break;
            case 7:
                System.out.println("S√°bado");
                break;
            default:
                System.out.println("Dia inv√°lido");
        }
    }
}
```

**Sa√≠da:**

```
Ter√ßa-feira
```

### üîπ Uso com `String` (a partir do Java 7)

```java
public class DiaDaSemanaString {
    public static void main(String[] args) {
        String dia = "ter√ßa";
        switch (dia.toLowerCase()) {
            case "segunda":
                System.out.println("Dia 2");
                break;
            case "ter√ßa":
                System.out.println("Dia 3");
                break;
            case "quarta":
                System.out.println("Dia 4");
                break;
            case "quinta":
                System.out.println("Dia 5");
                break;
            case "sexta":
                System.out.println("Dia 6");
                break;
            case "s√°bado":
                System.out.println("Dia 7");
                break;
            case "domingo":
                System.out.println("Dia 1");
                break;
            default:
                System.out.println("Dia inv√°lido");
        }
    }
}
```

**Sa√≠da:**

```
Dia 3
```

## ‚ö†Ô∏è Observa√ß√µes Importantes

- **Fall-through**: Se o `break` for omitido, a execu√ß√£o continuar√° nos pr√≥ximos casos at√© encontrar um `break` ou o final do `switch`.
  
  ```java
  int numero = 2;
  switch (numero) {
      case 1:
          System.out.println("Um");
      case 2:
          System.out.println("Dois");
      case 3:
          System.out.println("Tr√™s");
      default:
          System.out.println("N√∫mero n√£o identificado");
  }
  ```

  **Sa√≠da:**

  ```
  Dois
  Tr√™s
  N√∫mero n√£o identificado
  ```

- **`default` opcional**: O bloco `default` √© opcional, mas recomendado para tratar valores inesperados.
- **Valores √∫nicos**: Cada `case` deve ter um valor constante e √∫nico.



[Voltar ao √çndice](#indice)

---


## <a name="parte27">27 - 026 - Estruturas Condicionais pt 07 - Switch exerc√≠cio</a>

# Aula 26 ‚Äì Estruturas Condicionais pt 07: Switch Exerc√≠cio

üì∫ **Link do v√≠deo:** [Assista no YouTube](https://www.youtube.com/watch?v=GDAgMb9amow)

## üß† Conte√∫do Abordado

Nesta aula, o instrutor William Suane prop√µe um exerc√≠cio pr√°tico para refor√ßar o entendimento da estrutura condicional `switch` em Java. O objetivo √© aplicar o conhecimento adquirido na aula anterior, utilizando o `switch` para resolver problemas reais.

### üîπ Descri√ß√£o do Exerc√≠cio

**Objetivo:** Criar um programa que, com base em um n√∫mero de 1 a 7, exiba o dia da semana correspondente.

**Requisitos:**

- Utilizar a estrutura `switch`.
- Tratar casos onde o n√∫mero n√£o corresponde a um dia da semana v√°lido.

### üîπ Implementa√ß√£o em Java

```java
public class DiaDaSemana {
    public static void main(String[] args) {
        int dia = 3; // Voc√™ pode alterar este valor para testar outros casos

        switch (dia) {
            case 1:
                System.out.println("Domingo");
                break;
            case 2:
                System.out.println("Segunda-feira");
                break;
            case 3:
                System.out.println("Ter√ßa-feira");
                break;
            case 4:
                System.out.println("Quarta-feira");
                break;
            case 5:
                System.out.println("Quinta-feira");
                break;
            case 6:
                System.out.println("Sexta-feira");
                break;
            case 7:
                System.out.println("S√°bado");
                break;
            default:
                System.out.println("Dia inv√°lido");
        }
    }
}
```

**Explica√ß√£o:**

- A vari√°vel `dia` representa o n√∫mero do dia da semana.
- O `switch` avalia o valor de `dia` e executa o bloco correspondente.
- O `default` trata casos onde o valor de `dia` n√£o est√° entre 1 e 7.

### üîπ Testando o Programa

Altere o valor da vari√°vel `dia` para testar diferentes cen√°rios:

- `dia = 1` ‚Üí Sa√≠da: `Domingo`
- `dia = 5` ‚Üí Sa√≠da: `Quinta-feira`
- `dia = 8` ‚Üí Sa√≠da: `Dia inv√°lido`

## ‚ö†Ô∏è Observa√ß√µes Importantes

- **Uso do `break`:** Cada `case` termina com um `break` para evitar o *fall-through*, onde m√∫ltiplos blocos seriam executados.
- **`default` opcional:** Embora opcional, √© uma boa pr√°tica incluir o `default` para tratar valores inesperados.
- **Tipos compat√≠veis:** A express√£o no `switch` pode ser dos tipos `byte`, `short`, `int`, `char`, `String` (a partir do Java 7) ou `enum`.


[Voltar ao √çndice](#indice)

---


## <a name="parte28">28 - 027 - Estruturas de Repeti√ß√£o pt 01 - La√ßos de repeti√ß√£o while, do while, for</a>

# Aula 27 ‚Äì Estruturas de Repeti√ß√£o pt 01: La√ßos de repeti√ß√£o while, do while, for

üì∫ **Link do v√≠deo:** [Assista no YouTube](https://www.youtube.com/watch?v=hEl67ZAU_Hg)

## üß† Conte√∫do Abordado

Nesta aula, o instrutor William Suane apresenta as estruturas de repeti√ß√£o em Java: `while`, `do-while` e `for`. Essas estruturas permitem executar um bloco de c√≥digo repetidamente, com base em uma condi√ß√£o.

### üîπ Estrutura `while`

A estrutura `while` executa um bloco de c√≥digo enquanto uma condi√ß√£o for verdadeira. A condi√ß√£o √© verificada antes da execu√ß√£o do bloco.

**Sintaxe:**

```java
while (condi√ß√£o) {
    // c√≥digo a ser executado
}
```

**Exemplo:**

```java
int i = 1;
while (i <= 5) {
    System.out.println("Valor de i: " + i);
    i++;
}
```

**Sa√≠da:**

```
Valor de i: 1
Valor de i: 2
Valor de i: 3
Valor de i: 4
Valor de i: 5
```

### üîπ Estrutura `do-while`

A estrutura `do-while` √© semelhante ao `while`, mas a condi√ß√£o √© verificada ap√≥s a execu√ß√£o do bloco. Isso garante que o bloco seja executado pelo menos uma vez.

**Sintaxe:**

```java
do {
    // c√≥digo a ser executado
} while (condi√ß√£o);
```

**Exemplo:**

```java
int i = 1;
do {
    System.out.println("Valor de i: " + i);
    i++;
} while (i <= 5);
```

**Sa√≠da:**

```
Valor de i: 1
Valor de i: 2
Valor de i: 3
Valor de i: 4
Valor de i: 5
```

### üîπ Estrutura `for`

A estrutura `for` √© utilizada quando se sabe previamente o n√∫mero de vezes que o bloco de c√≥digo deve ser executado. Ela combina inicializa√ß√£o, condi√ß√£o e incremento em uma √∫nica linha.

**Sintaxe:**

```java
for (inicializa√ß√£o; condi√ß√£o; incremento) {
    // c√≥digo a ser executado
}
```

**Exemplo:**

```java
for (int i = 1; i <= 5; i++) {
    System.out.println("Valor de i: " + i);
}
```

**Sa√≠da:**

```
Valor de i: 1
Valor de i: 2
Valor de i: 3
Valor de i: 4
Valor de i: 5
```

## ‚ö†Ô∏è Observa√ß√µes Importantes

- **`while`**: Verifica a condi√ß√£o antes de executar o bloco. Se a condi√ß√£o for falsa na primeira verifica√ß√£o, o bloco pode n√£o ser executado nenhuma vez.
- **`do-while`**: Executa o bloco pelo menos uma vez, pois a condi√ß√£o √© verificada ap√≥s a execu√ß√£o.
- **`for`**: Ideal quando se sabe exatamente quantas vezes o loop deve ser executado.



[Voltar ao √çndice](#indice)

---


## <a name="parte29">29 - 028 - Estruturas de Repeti√ß√£o pt 02 - Exerc√≠cio for</a>

# Aula 28 ‚Äì Estruturas de Repeti√ß√£o pt 02: Exerc√≠cio com `for`

üì∫ **Link do v√≠deo:** [Assista no YouTube](https://www.youtube.com/watch?v=nvFAe05Ok3g)

## üß† Conte√∫do Abordado

Nesta aula, o instrutor William Suane prop√µe um exerc√≠cio pr√°tico para refor√ßar o entendimento da estrutura de repeti√ß√£o `for` em Java. O objetivo √© aplicar o conhecimento adquirido na aula anterior, utilizando o `for` para resolver problemas reais.

### üîπ Descri√ß√£o do Exerc√≠cio

**Objetivo:** Criar um programa que exiba todos os n√∫meros pares de 0 a 100.

**Requisitos:**

- Utilizar a estrutura `for`.
- Exibir apenas n√∫meros pares no intervalo de 0 a 100.

### üîπ Implementa√ß√£o em Java

```java
public class NumerosPares {
    public static void main(String[] args) {
        for (int i = 0; i <= 100; i++) {
            if (i % 2 == 0) {
                System.out.println("N√∫mero par: " + i);
            }
        }
    }
}
```

**Explica√ß√£o:**

- A vari√°vel `i` √© inicializada com 0 e incrementada at√© 100.
- A condi√ß√£o `i % 2 == 0` verifica se o n√∫mero √© par.
- Se a condi√ß√£o for verdadeira, o n√∫mero √© exibido no console.

### üîπ Alternativa com Incremento de 2

Uma forma mais eficiente de exibir apenas os n√∫meros pares √© incrementar a vari√°vel `i` de 2 em 2:

```java
public class NumerosPares {
    public static void main(String[] args) {
        for (int i = 0; i <= 100; i += 2) {
            System.out.println("N√∫mero par: " + i);
        }
    }
}
```

**Vantagens:**

- Elimina a necessidade de verificar se o n√∫mero √© par.
- Reduz o n√∫mero de itera√ß√µes, tornando o programa mais eficiente.

## ‚ö†Ô∏è Observa√ß√µes Importantes

- **Uso do `for`:** Ideal quando se sabe exatamente quantas vezes o loop deve ser executado.
- **Efici√™ncia:** Incrementar de 2 em 2 √© mais eficiente do que verificar se o n√∫mero √© par a cada itera√ß√£o.
- **Legibilidade:** Escolher a abordagem que torna o c√≥digo mais leg√≠vel e f√°cil de entender.


[Voltar ao √çndice](#indice)

---


## <a name="parte30">30 - 029 - Estruturas de Repeti√ß√£o pt 03 - Break</a>

# Aula 29 ‚Äì Estruturas de Repeti√ß√£o pt 03: Break

üì∫ **Link do v√≠deo:** [Assista no YouTube](https://www.youtube.com/watch?v=bcv-cgpw7Ak)

## üß† Conte√∫do Abordado

Nesta aula, o instrutor William Suane apresenta o uso da instru√ß√£o `break` em Java, que √© utilizada para interromper a execu√ß√£o de estruturas de repeti√ß√£o (`for`, `while`, `do-while`) ou de um bloco `switch`.

### üîπ O que √© o `break`?

O `break` √© uma instru√ß√£o de controle de fluxo que, quando executada, termina imediatamente a estrutura de controle mais pr√≥xima (`for`, `while`, `do-while` ou `switch`) e transfere o controle para a pr√≥xima instru√ß√£o ap√≥s essa estrutura.

### üîπ Uso do `break` em loops

**Exemplo com `for`:**

```java
for (int i = 0; i < 10; i++) {
    if (i == 5) {
        break;
    }
    System.out.println("i: " + i);
}
```

**Sa√≠da:**

```
i: 0
i: 1
i: 2
i: 3
i: 4
```

**Exemplo com `while`:**

```java
int i = 0;
while (i < 10) {
    if (i == 5) {
        break;
    }
    System.out.println("i: " + i);
    i++;
}
```

**Sa√≠da:**

```
i: 0
i: 1
i: 2
i: 3
i: 4
```

**Exemplo com `do-while`:**

```java
int i = 0;
do {
    if (i == 5) {
        break;
    }
    System.out.println("i: " + i);
    i++;
} while (i < 10);
```

**Sa√≠da:**

```
i: 0
i: 1
i: 2
i: 3
i: 4
```

### üîπ Uso do `break` em `switch`

```java
int dia = 3;
switch (dia) {
    case 1:
        System.out.println("Domingo");
        break;
    case 2:
        System.out.println("Segunda-feira");
        break;
    case 3:
        System.out.println("Ter√ßa-feira");
        break;
    default:
        System.out.println("Dia inv√°lido");
}
```

**Sa√≠da:**

```
Ter√ßa-feira
```

### üîπ Uso de `break` com r√≥tulos (labeled break)

Em loops aninhados, o `break` afeta apenas o loop mais interno. Para sair de loops externos, utiliza-se r√≥tulos:

```java
externo:
for (int i = 0; i < 3; i++) {
    for (int j = 0; j < 3; j++) {
        if (i == 1 && j == 1) {
            break externo;
        }
        System.out.println("i: " + i + ", j: " + j);
    }
}
```

**Sa√≠da:**

```
i: 0, j: 0
i: 0, j: 1
i: 0, j: 2
i: 1, j: 0
```

## ‚ö†Ô∏è Observa√ß√µes Importantes

- **Uso adequado:** Utilize o `break` para sair de loops ou `switch` quando uma condi√ß√£o espec√≠fica for atendida.
- **Legibilidade:** Evite o uso excessivo de `break`, pois pode dificultar a leitura e manuten√ß√£o do c√≥digo.
- **Loops infinitos:** Em loops sem condi√ß√£o de t√©rmino expl√≠cita, o `break` pode ser utilizado para definir uma condi√ß√£o de sa√≠da.


[Voltar ao √çndice](#indice)

---


## <a name="parte31">31 - 030 - Estruturas de Repeti√ß√£o pt 04 - Exerc√≠cio Break</a>

# Aula 30 ‚Äì Estruturas de Repeti√ß√£o pt 04: Exerc√≠cio com `break`

üì∫ **Link do v√≠deo:** [Assista no YouTube](https://www.youtube.com/watch?v=RaEO2YsqFII)

## üß† Conte√∫do Abordado

Nesta aula, o instrutor William Suane prop√µe um exerc√≠cio pr√°tico para refor√ßar o entendimento da instru√ß√£o `break` em Java. O objetivo √© aplicar o conhecimento adquirido na aula anterior, utilizando o `break` para controlar o fluxo de execu√ß√£o em estruturas de repeti√ß√£o.

### üîπ Descri√ß√£o do Exerc√≠cio

**Objetivo:** Criar um programa que exiba os n√∫meros de 1 a 50, mas interrompa a execu√ß√£o quando encontrar um n√∫mero divis√≠vel por 25.

**Requisitos:**

- Utilizar a estrutura `for`.
- Exibir os n√∫meros de 1 a 50.
- Interromper a execu√ß√£o ao encontrar um n√∫mero divis√≠vel por 25.

### üîπ Implementa√ß√£o em Java

```java
public class BreakExercicio {
    public static void main(String[] args) {
        for (int i = 1; i <= 50; i++) {
            if (i % 25 == 0) {
                System.out.println("N√∫mero divis√≠vel por 25 encontrado: " + i);
                break;
            }
            System.out.println("i = " + i);
        }
    }
}
```

**Explica√ß√£o:**

- A vari√°vel `i` √© inicializada com 1 e incrementada at√© 50.
- A condi√ß√£o `i % 25 == 0` verifica se o n√∫mero √© divis√≠vel por 25.
- Se a condi√ß√£o for verdadeira, o n√∫mero √© exibido e a execu√ß√£o √© interrompida com o `break`.
- Caso contr√°rio, o n√∫mero √© exibido normalmente.

### üîπ Sa√≠da Esperada

```
i = 1
i = 2
...
i = 24
N√∫mero divis√≠vel por 25 encontrado: 25
```

## ‚ö†Ô∏è Observa√ß√µes Importantes

- **Uso do `break`:** A instru√ß√£o `break` √© utilizada para interromper a execu√ß√£o de loops (`for`, `while`, `do-while`) ou de um bloco `switch` quando uma condi√ß√£o espec√≠fica √© atendida.
- **Legibilidade:** Utilizar o `break` de forma adequada pode melhorar a legibilidade e efici√™ncia do c√≥digo, evitando execu√ß√µes desnecess√°rias.
- **Loops Infinitos:** Em loops sem condi√ß√£o de t√©rmino expl√≠cita, o `break` pode ser utilizado para definir uma condi√ß√£o de sa√≠da.


[Voltar ao √çndice](#indice)

---


## <a name="parte32">32 - 031 - Estruturas de Repeti√ß√£o pt 05 - Continue</a>

# Aula 31 ‚Äì Estruturas de Repeti√ß√£o pt 05: Continue

üì∫ **Link do v√≠deo:** [Assista no YouTube](https://www.youtube.com/watch?v=f65R-lQ4NpY)

## üß† Conte√∫do Abordado

Nesta aula, o instrutor William Suane apresenta a instru√ß√£o `continue` em Java, que √© utilizada para pular a execu√ß√£o do restante do c√≥digo dentro de um loop e iniciar a pr√≥xima itera√ß√£o.

### üîπ O que √© o `continue`?

O `continue` √© uma instru√ß√£o de controle de fluxo que, quando executada dentro de um loop (`for`, `while` ou `do-while`), faz com que o loop pule o restante do c√≥digo na itera√ß√£o atual e prossiga para a pr√≥xima itera√ß√£o.

### üîπ Uso do `continue` em loops

**Exemplo com `for`:**

```java
for (int i = 0; i < 10; i++) {
    if (i == 5) {
        continue;
    }
    System.out.println("i: " + i);
}
```

**Sa√≠da:**

```
i: 0
i: 1
i: 2
i: 3
i: 4
i: 6
i: 7
i: 8
i: 9
```

**Exemplo com `while`:**

```java
int i = 0;
while (i < 10) {
    i++;
    if (i == 5) {
        continue;
    }
    System.out.println("i: " + i);
}
```

**Sa√≠da:**

```
i: 1
i: 2
i: 3
i: 4
i: 6
i: 7
i: 8
i: 9
i: 10
```

**Exemplo com `do-while`:**

```java
int i = 0;
do {
    i++;
    if (i == 5) {
        continue;
    }
    System.out.println("i: " + i);
} while (i < 10);
```

**Sa√≠da:**

```
i: 1
i: 2
i: 3
i: 4
i: 6
i: 7
i: 8
i: 9
i: 10
```

### üîπ Uso do `continue` em loops aninhados

Em loops aninhados, o `continue` afeta apenas o loop mais interno. Para controlar loops externos, utiliza-se r√≥tulos:

```java
externo:
for (int i = 0; i < 3; i++) {
    for (int j = 0; j < 3; j++) {
        if (i == 1 && j == 1) {
            continue externo;
        }
        System.out.println("i: " + i + ", j: " + j);
    }
}
```

**Sa√≠da:**

```
i: 0, j: 0
i: 0, j: 1
i: 0, j: 2
i: 1, j: 0
i: 2, j: 0
i: 2, j: 1
i: 2, j: 2
```

## ‚ö†Ô∏è Observa√ß√µes Importantes

- **Uso adequado:** Utilize o `continue` para pular determinadas itera√ß√µes com base em condi√ß√µes espec√≠ficas.
- **Legibilidade:** Evite o uso excessivo de `continue`, pois pode dificultar a leitura e manuten√ß√£o do c√≥digo.
- **Loops infinitos:** Certifique-se de que o uso de `continue` n√£o interfira na l√≥gica de t√©rmino do loop, evitando loops infinitos.


[Voltar ao √çndice](#indice)

---


## <a name="parte33">33 - 032 - Arrays pt 01</a>

# Aula 32 ‚Äì Arrays pt 01

üì∫ **Link do v√≠deo:** [Assista no YouTube](https://www.youtube.com/watch?v=fvw4bmihZHA)

## üß† Conte√∫do Abordado

Nesta aula, o instrutor William Suane introduz o conceito de arrays em Java, abordando sua declara√ß√£o, inicializa√ß√£o e acesso aos elementos.

### üîπ O que s√£o Arrays?

Arrays s√£o estruturas de dados que armazenam m√∫ltiplos valores do mesmo tipo em uma √∫nica vari√°vel. Eles s√£o √∫teis quando precisamos trabalhar com cole√ß√µes de dados homog√™neos.

### üîπ Declara√ß√£o e Inicializa√ß√£o de Arrays

**Forma 1: Declara√ß√£o e atribui√ß√£o separadas**

```java
int[] numeros; // declara√ß√£o
numeros = new int[5]; // inicializa√ß√£o com tamanho 5
```

**Forma 2: Declara√ß√£o e inicializa√ß√£o conjunta**

```java
int[] numeros = new int[5];
```

**Forma 3: Inicializa√ß√£o com valores definidos**

```java
int[] numeros = {1, 2, 3, 4, 5};
```

### üîπ Acessando Elementos de um Array

Os elementos de um array s√£o acessados por √≠ndices, que come√ßam em 0.

```java
System.out.println(numeros[0]); // Acessa o primeiro elemento
```

### üîπ Iterando sobre Arrays

Podemos utilizar loops para percorrer os elementos de um array.

**Exemplo com `for`:**

```java
for (int i = 0; i < numeros.length; i++) {
    System.out.println(numeros[i]);
}
```

**Exemplo com `for-each`:**

```java
for (int numero : numeros) {
    System.out.println(numero);
}
```

### üîπ Tamanho do Array

O tamanho de um array √© acessado atrav√©s da propriedade `length`.

```java
int tamanho = numeros.length;
System.out.println("Tamanho do array: " + tamanho);
```

## ‚ö†Ô∏è Observa√ß√µes Importantes

- **Tipo homog√™neo:** Arrays armazenam elementos do mesmo tipo.
- **Tamanho fixo:** Ap√≥s a inicializa√ß√£o, o tamanho do array n√£o pode ser alterado.
- **√çndices:** Os √≠ndices come√ßam em 0 e v√£o at√© `length - 1`.



[Voltar ao √çndice](#indice)

---


## <a name="parte34">34 - 033 - Arrays pt 02</a>

# Aula 33 ‚Äì Arrays pt 02

üì∫ **Link do v√≠deo:** [Assista no YouTube](https://www.youtube.com/watch?v=S8Eaq6uxnd8)

## üß† Conte√∫do Abordado

Nesta aula, o instrutor William Suane aprofunda o estudo sobre arrays em Java, abordando conceitos como:

- Acessando elementos de arrays
- Iterando sobre arrays com diferentes estruturas de repeti√ß√£o
- Utilizando a propriedade `length` para determinar o tamanho do array
- Pr√°ticas recomendadas ao trabalhar com arrays

### üîπ Acessando Elementos de um Array

Os elementos de um array s√£o acessados por √≠ndices, que come√ßam em 0.

```java
int[] numeros = {10, 20, 30, 40, 50};
System.out.println(numeros[0]); // Sa√≠da: 10
System.out.println(numeros[4]); // Sa√≠da: 50
```

### üîπ Iterando sobre Arrays

Podemos utilizar diferentes estruturas de repeti√ß√£o para percorrer os elementos de um array.

**Usando o loop `for`:**

```java
for (int i = 0; i < numeros.length; i++) {
    System.out.println("Elemento na posi√ß√£o " + i + ": " + numeros[i]);
}
```

**Usando o loop `while`:**

```java
int i = 0;
while (i < numeros.length) {
    System.out.println("Elemento na posi√ß√£o " + i + ": " + numeros[i]);
    i++;
}
```

**Usando o loop `do-while`:**

```java
int i = 0;
do {
    System.out.println("Elemento na posi√ß√£o " + i + ": " + numeros[i]);
    i++;
} while (i < numeros.length);
```

### üîπ Propriedade `length`

A propriedade `length` retorna o tamanho do array, ou seja, o n√∫mero de elementos que ele pode armazenar.

```java
System.out.println("Tamanho do array: " + numeros.length); // Sa√≠da: 5
```

### üîπ Pr√°ticas Recomendadas

- **Evite acessar √≠ndices fora do intervalo:** Certifique-se de que os √≠ndices utilizados est√£o dentro do intervalo v√°lido (0 a `length - 1`) para evitar `ArrayIndexOutOfBoundsException`.
- **Utilize loops apropriados:** Escolha a estrutura de repeti√ß√£o que melhor se adequa √† l√≥gica do seu programa.
- **Inicialize arrays corretamente:** Ao declarar arrays, certifique-se de inicializ√°-los antes de acessar seus elementos.


[Voltar ao √çndice](#indice)

---


## <a name="parte35">35 - 034 - Arrays pt 03</a>

# Aula 33 ‚Äì Arrays pt 02

üì∫ **Link do v√≠deo:** [Assista no YouTube](https://www.youtube.com/watch?v=S8Eaq6uxnd8)

## üß† Conte√∫do Abordado

Nesta aula, o instrutor William Suane aprofunda o estudo sobre arrays em Java, abordando conceitos como:

- Acessando elementos de arrays
- Iterando sobre arrays com diferentes estruturas de repeti√ß√£o
- Utilizando a propriedade `length` para determinar o tamanho do array
- Pr√°ticas recomendadas ao trabalhar com arrays

### üîπ Acessando Elementos de um Array

Os elementos de um array s√£o acessados por √≠ndices, que come√ßam em 0.

```java
int[] numeros = {10, 20, 30, 40, 50};
System.out.println(numeros[0]); // Sa√≠da: 10
System.out.println(numeros[4]); // Sa√≠da: 50
```

### üîπ Iterando sobre Arrays

Podemos utilizar diferentes estruturas de repeti√ß√£o para percorrer os elementos de um array.

**Usando o loop `for`:**

```java
for (int i = 0; i < numeros.length; i++) {
    System.out.println("Elemento na posi√ß√£o " + i + ": " + numeros[i]);
}
```

**Usando o loop `while`:**

```java
int i = 0;
while (i < numeros.length) {
    System.out.println("Elemento na posi√ß√£o " + i + ": " + numeros[i]);
    i++;
}
```

**Usando o loop `do-while`:**

```java
int i = 0;
do {
    System.out.println("Elemento na posi√ß√£o " + i + ": " + numeros[i]);
    i++;
} while (i < numeros.length);
```

### üîπ Propriedade `length`

A propriedade `length` retorna o tamanho do array, ou seja, o n√∫mero de elementos que ele pode armazenar.

```java
System.out.println("Tamanho do array: " + numeros.length); // Sa√≠da: 5
```

### üîπ Pr√°ticas Recomendadas

- **Evite acessar √≠ndices fora do intervalo:** Certifique-se de que os √≠ndices utilizados est√£o dentro do intervalo v√°lido (0 a `length - 1`) para evitar `ArrayIndexOutOfBoundsException`.
- **Utilize loops apropriados:** Escolha a estrutura de repeti√ß√£o que melhor se adequa √† l√≥gica do seu programa.
- **Inicialize arrays corretamente:** Ao declarar arrays, certifique-se de inicializ√°-los antes de acessar seus elementos.


[Voltar ao √çndice](#indice)

---


## <a name="parte36">36 - 035 - Arrays pt 04 - Foreach</a>

# Aula 35 ‚Äì Arrays pt 04: Foreach

üì∫ **Link do v√≠deo:** [Assista no YouTube](https://www.youtube.com/watch?v=cl47iLWalUw)

## üß† Conte√∫do Abordado

Nesta aula, o instrutor William Suane apresenta o loop `foreach` (tamb√©m conhecido como "enhanced for loop") em Java, uma forma simplificada e mais leg√≠vel de iterar sobre arrays e cole√ß√µes.

---

## üîπ O que √© o `foreach`?

O `foreach` √© uma estrutura de repeti√ß√£o introduzida no Java 5 que permite iterar sobre elementos de arrays ou cole√ß√µes sem a necessidade de utilizar √≠ndices. Embora utilize a palavra-chave `for`, sua estrutura √© diferente do `for` tradicional ‚Äî por isso √© conhecido como **"foreach"**.

---

## üîπ Sintaxe do `foreach`

```java
for (Tipo elemento : arrayOuColecao) {
    // Bloco de c√≥digo a ser executado para cada elemento
}
```

- `Tipo`: tipo do elemento dentro do array ou cole√ß√£o.
- `elemento`: vari√°vel tempor√°ria que armazena o valor atual.
- `arrayOuColecao`: estrutura de dados a ser percorrida.

---

## üîπ Exemplo 1: `foreach` com array de inteiros

```java
int[] numeros = {1, 2, 3, 4, 5};

// foreach para imprimir cada n√∫mero
for (int numero : numeros) {
    System.out.println(numero);
}
```

**Sa√≠da:**

```
1
2
3
4
5
```

---

## üîπ Exemplo 2: `foreach` com array de Strings

```java
String[] nomes = {"Ana", "Bruno", "Carlos"};

// foreach para imprimir cada nome
for (String nome : nomes) {
    System.out.println(nome);
}
```

**Sa√≠da:**

```
Ana
Bruno
Carlos
```

---

## ‚úÖ Vantagens do `foreach`

- C√≥digo mais limpo e leg√≠vel.
- Evita erros de acesso por √≠ndice.
- Ideal para percorrer todos os elementos de forma simples.

---

## ‚ö†Ô∏è Limita√ß√µes do `foreach`

- N√£o permite acesso ao √≠ndice dos elementos.
- N√£o serve para modificar os elementos diretamente (em arrays de tipos primitivos).
- S√≥ percorre os dados do in√≠cio ao fim.

---



[Voltar ao √çndice](#indice)

---


## <a name="parte37">37 - 036 - Arrays Multidimensionais pt 01</a>

# Aula 36 ‚Äì Arrays Multidimensionais pt 01

üì∫ **V√≠deo:** [Arrays Multidimensionais pt 01 - DevDojo](https://www.youtube.com/watch?v=EalQ6X_RtJk&list=PL62G310vn6nFIsOCC0H-C2infYgwm8SWW&index=37)

## üß† O que s√£o Arrays Multidimensionais?

Em Java, arrays multidimensionais s√£o estruturas que armazenam dados em mais de uma dimens√£o ‚Äî como uma **tabela (matriz)** com linhas e colunas. O mais comum √© o array bidimensional, ou seja, com duas dimens√µes.

---

## üß± Declara√ß√£o de um Array Bidimensional

```java
int[][] dias = new int[2][2];
```

- Isso cria um array com **2 linhas** e **2 colunas**.
- Cada elemento do array `dias[i][j]` pode ser acessado e manipulado individualmente.

---

## üõ†Ô∏è Atribuindo valores

```java
dias[0][0] = 1;
dias[0][1] = 2;
dias[1][0] = 3;
dias[1][1] = 4;
```

---

## üîÅ Acessando elementos com `for` aninhado

```java
for (int i = 0; i < dias.length; i++) {
    for (int j = 0; j < dias[i].length; j++) {
        System.out.println("dias[" + i + "][" + j + "] = " + dias[i][j]);
    }
}
```

**Sa√≠da esperada:**

```
dias[0][0] = 1
dias[0][1] = 2
dias[1][0] = 3
dias[1][1] = 4
```

---

## üí° Dicas da Aula

- `dias.length` retorna o n√∫mero de **linhas**.
- `dias[i].length` retorna o n√∫mero de **colunas da linha i**.
- Java permite arrays de arrays com **tamanhos diferentes** em cada linha.

### Exemplo de array com colunas irregulares:

```java
int[][] irregular = new int[2][];
irregular[0] = new int[2]; // 2 colunas na linha 0
irregular[1] = new int[3]; // 3 colunas na linha 1
```

---

## ‚úÖ Vantagens de usar arrays multidimensionais

- Organizam dados em estrutura de grade (matriz).
- √öteis para tabelas, mapas, jogos, hor√°rios, etc.
- Podem ser aninhados com la√ßos para itera√ß√£o completa.

---

## üìå Exerc√≠cio proposto (extra)

Crie uma matriz `3x3` que armazene os n√∫meros de 1 a 9 e imprima o conte√∫do formatado.

```java
public class MatrizExemplo {
    public static void main(String[] args) {
        int[][] matriz = new int[3][3];
        int contador = 1;

        for (int i = 0; i < matriz.length; i++) {
            for (int j = 0; j < matriz[i].length; j++) {
                matriz[i][j] = contador++;
            }
        }

        // Impress√£o formatada
        for (int[] linha : matriz) {
            for (int valor : linha) {
                System.out.print(valor + " ");
            }
            System.out.println();
        }
    }
}
```

**Sa√≠da:**

```
1 2 3
4 5 6
7 8 9
```

---

üß† **Conclus√£o:** Arrays multidimensionais s√£o extremamente √∫teis para representar dados tabulares e devem ser bem compreendidos para manipula√ß√£o de estruturas complexas em Java.

---


[Voltar ao √çndice](#indice)

---


## <a name="parte38">38 - 037 - Arrays Multidimensionais pt 02 - Foreach</a>

# Aula 37 ‚Äì Arrays Multidimensionais pt 02 - Foreach

üì∫ **V√≠deo:** [Arrays Multidimensionais pt 02 - Foreach](https://www.youtube.com/watch?v=TGq3754CsN4&list=PL62G310vn6nFIsOCC0H-C2infYgwm8SWW&index=38)

## üß† O que foi abordado na aula?

Nesta aula, o professor explica como percorrer **arrays multidimensionais** utilizando o **la√ßo `foreach`**, que facilita a leitura de elementos em arrays sem precisar controlar os √≠ndices manualmente.

---

## üîÅ Relembrando o `foreach`

O `foreach` √© um **la√ßo de repeti√ß√£o** utilizado para iterar diretamente sobre os elementos de um array ou cole√ß√£o, sem a necessidade de √≠ndices.

### Sintaxe:

```java
for (tipo variavel : array) {
    // A√ß√µes com a variavel
}
```

---

## üß± Exemplo com array multidimensional

```java
public class AulaForeachMultidimensional {
    public static void main(String[] args) {
        int[][] arrayMultidimensional = {
            {1, 2, 3},
            {4, 5, 6},
            {7, 8, 9}
        };

        for (int[] linha : arrayMultidimensional) {
            for (int valor : linha) {
                System.out.print(valor + " ");
            }
            System.out.println();
        }
    }
}
```

### üñ®Ô∏è Sa√≠da:

```
1 2 3 
4 5 6 
7 8 9 
```

---

## ‚úÖ Vantagens do uso de `foreach`

- C√≥digo mais limpo e leg√≠vel.
- Elimina erros comuns com √≠ndices.
- Ideal para leitura e exibi√ß√£o de dados.

---

## ‚ö†Ô∏è Limita√ß√µes

- N√£o permite acesso direto ao √≠ndice dos elementos.
- N√£o √© poss√≠vel alterar os elementos diretamente do array original (para arrays de tipos primitivos).

---

## üß™ Exerc√≠cio sugerido

Crie um array bidimensional de nomes de frutas e imprima todas as frutas usando `foreach`.

```java
public class ExercicioFrutas {
    public static void main(String[] args) {
        String[][] frutas = {
            {"Ma√ß√£", "Banana"},
            {"Laranja", "Uva"},
            {"Melancia", "Manga"}
        };

        for (String[] linha : frutas) {
            for (String fruta : linha) {
                System.out.print(fruta + " | ");
            }
            System.out.println();
        }
    }
}
```

**Sa√≠da:**

```
Ma√ß√£ | Banana | 
Laranja | Uva | 
Melancia | Manga | 
```

---

## üß† Conclus√£o

Usar `foreach` com arrays multidimensionais deixa o c√≥digo muito mais enxuto e pr√°tico para leitura e exibi√ß√£o de dados. Apesar de suas limita√ß√µes, √© uma ferramenta poderosa especialmente em situa√ß√µes onde o √≠ndice n√£o √© necess√°rio.



[Voltar ao √çndice](#indice)

---


## <a name="parte39">39 - 038 - Arrays Multidimensionais pt 03 - Inicializa√ß√£o</a>

# Aula 38 ‚Äì Arrays Multidimensionais pt 03 - Inicializa√ß√£o

üì∫ **V√≠deo:** [Arrays Multidimensionais pt 03 - Inicializa√ß√£o](https://www.youtube.com/watch?v=vp8bQZomKLo&list=PL62G310vn6nFIsOCC0H-C2infYgwm8SWW&index=39)

## üß† O que foi abordado na aula?

Nesta aula, o professor do DevDojo explica as formas de **inicializa√ß√£o de arrays multidimensionais em Java**, com foco na clareza e praticidade do c√≥digo. Ele mostra como criar e atribuir valores a esses arrays de forma expl√≠cita ou separando a aloca√ß√£o da atribui√ß√£o.

---

## üî¢ O que √© um Array Multidimensional?

Um array multidimensional √© uma estrutura de dados composta por **arrays dentro de arrays**. Em Java, arrays 2D s√£o representados como `tipo[][]`, sendo o tipo mais comum `int[][]`, `String[][]`, etc.

---

## ‚úÖ Formas de inicializa√ß√£o

### 1. Inicializa√ß√£o direta (em linha)

```java
int[][] numeros = {
    {1, 2, 3},
    {4, 5},
    {6, 7, 8, 9}
};
```

- Aqui o array j√° √© criado e preenchido com valores.
- Permite criar "linhas" com diferentes quantidades de colunas (vetores irregulares).

### 2. Inicializa√ß√£o separada (aloca√ß√£o + atribui√ß√£o)

```java
int[][] numeros = new int[3][];
numeros[0] = new int[]{1, 2, 3};
numeros[1] = new int[]{4, 5};
numeros[2] = new int[]{6, 7, 8, 9};
```

- Primeiro √© alocado o array de arrays (`3` linhas).
- Depois, cada linha √© instanciada individualmente com o n√∫mero de colunas desejado.

---

## üîç Exemplo pr√°tico com `String`

```java
public class ExemploArrayMultidimensional {
    public static void main(String[] args) {
        String[][] nomes = {
            {"Ana", "Carlos"},
            {"Bruno"},
            {"Let√≠cia", "Rafael", "Marcos"}
        };

        for (String[] grupo : nomes) {
            for (String nome : grupo) {
                System.out.print(nome + " ");
            }
            System.out.println();
        }
    }
}
```

### üñ®Ô∏è Sa√≠da:

```
Ana Carlos 
Bruno 
Let√≠cia Rafael Marcos 
```

---

## üß™ Dicas e boas pr√°ticas

- **Declare e inicialize em uma linha** sempre que poss√≠vel para melhorar a legibilidade.
- Lembre-se que os arrays internos (colunas) podem ter tamanhos diferentes.
- Para arrays de grandes dimens√µes, mantenha o c√≥digo organizado com indenta√ß√£o adequada.

---

## üß† Conclus√£o

Inicializar corretamente arrays multidimensionais em Java √© essencial para a estrutura√ß√£o de dados mais complexos. A linguagem oferece flexibilidade para criar arrays regulares (matrizes) e irregulares (vetores de vetores). Entender como e quando usar cada forma de inicializa√ß√£o ajuda a escrever um c√≥digo mais limpo e eficiente.



[Voltar ao √çndice](#indice)

---


## <a name="parte40">40 - 039 - Orienta√ß√£o Objetos pt 01 - Introdu√ß√£o classes pt 01</a>

# Aula 39 ‚Äì Orienta√ß√£o a Objetos pt 01: Introdu√ß√£o a Classes (Parte 1)

üì∫ **V√≠deo:** [Orienta√ß√£o Objetos pt 01 - Introdu√ß√£o classes pt 01](https://www.youtube.com/watch?v=EyuPFLuvD7Q&list=PL62G310vn6nFIsOCC0H-C2infYgwm8SWW&index=40)

## üß† O que foi abordado na aula?

Nesta aula, foi feita uma introdu√ß√£o √† **Programa√ß√£o Orientada a Objetos (POO)** em Java, com foco na **defini√ß√£o de classes** e **objetos**, que s√£o os blocos fundamentais dessa abordagem.

O professor explica:
- O que √© uma classe;
- Como criar uma classe;
- Como instanciar objetos a partir de uma classe.

---

## üì¶ O que √© uma Classe?

Uma **classe** √© uma estrutura que define um **tipo de objeto**, incluindo seus **atributos (vari√°veis)** e **comportamentos (m√©todos)**.

```java
public class Carro {
    String modelo;
    String cor;
    int ano;
}
```

Essa classe `Carro` define o modelo gen√©rico de um carro, com seus atributos b√°sicos.

---

## üßç O que √© um Objeto?

Um **objeto** √© uma inst√¢ncia de uma classe. Ap√≥s definir a estrutura com a classe, voc√™ pode criar objetos a partir dela:

```java
public class TesteCarro {
    public static void main(String[] args) {
        Carro carro1 = new Carro();
        carro1.modelo = "Fusca";
        carro1.cor = "Azul";
        carro1.ano = 1975;

        System.out.println("Modelo: " + carro1.modelo);
        System.out.println("Cor: " + carro1.cor);
        System.out.println("Ano: " + carro1.ano);
    }
}
```

### üñ®Ô∏è Sa√≠da:
```
Modelo: Fusca
Cor: Azul
Ano: 1975
```

---

## ‚úçÔ∏è Atributos

Os **atributos** s√£o as vari√°veis que descrevem o estado de um objeto. No exemplo acima: `modelo`, `cor`, e `ano` s√£o atributos da classe `Carro`.

---

## üöÄ Instanciando Objetos

Para criar um objeto a partir de uma classe, usamos a palavra-chave `new`:

```java
Carro meuCarro = new Carro();
```

---

## üìö Detalhes Adicionais

- Uma **classe** √© como uma planta (blueprint).
- Um **objeto** √© como a constru√ß√£o feita a partir dessa planta.
- Voc√™ pode criar v√°rios objetos a partir de uma mesma classe.
- Por padr√£o, os atributos de uma classe t√™m valores padr√£o (como `null` para Strings e `0` para inteiros), caso n√£o sejam atribu√≠dos manualmente.

---

## üß† Conclus√£o

A introdu√ß√£o √†s classes √© o primeiro passo na jornada de **Programa√ß√£o Orientada a Objetos** em Java. Entender como declarar classes e instanciar objetos √© essencial para construir programas organizados, reutiliz√°veis e com maior coes√£o.

Na pr√≥xima aula, o professor continuar√° com o aprofundamento em classes, adicionando **m√©todos** e **comportamentos**.



[Voltar ao √çndice](#indice)

---


## <a name="parte41">41 - 040 - Orienta√ß√£o Objetos - Introdu√ß√£o classes pt 02</a>

# Aula 40 ‚Äì Orienta√ß√£o a Objetos: Introdu√ß√£o a Classes (Parte 2)

üì∫ **V√≠deo:** [Orienta√ß√£o Objetos - Introdu√ß√£o classes pt 02](https://www.youtube.com/watch?v=uB7KvSz6WiA&list=PL62G310vn6nFIsOCC0H-C2infYgwm8SWW&index=41)

## üß† O que foi abordado na aula?

Nesta continua√ß√£o da introdu√ß√£o a **classes em Java**, o professor explora:
- Declara√ß√£o de **m√©todos**;
- Diferen√ßa entre **atributos** e **comportamentos**;
- A import√¢ncia de **modularizar comportamentos** dentro de m√©todos;
- Cria√ß√£o de uma classe com atributos e m√©todos;
- Instancia√ß√£o de objetos que utilizam esses m√©todos.

---

## üß± Exemplo pr√°tico de uma classe com m√©todos

```java
public class Carro {
    String modelo;
    String cor;
    int ano;

    void ligar() {
        System.out.println("O carro est√° ligado!");
    }

    void exibirDetalhes() {
        System.out.println("Modelo: " + modelo);
        System.out.println("Cor: " + cor);
        System.out.println("Ano: " + ano);
    }
}
```

### üß™ Classe de Teste

```java
public class TesteCarro {
    public static void main(String[] args) {
        Carro carro1 = new Carro();
        carro1.modelo = "Gol";
        carro1.cor = "Branco";
        carro1.ano = 2020;

        carro1.ligar();
        carro1.exibirDetalhes();
    }
}
```

### ‚úÖ Sa√≠da esperada:
```
O carro est√° ligado!
Modelo: Gol
Cor: Branco
Ano: 2020
```

---

## üìå Conceitos refor√ßados na aula

- **Atributos**: representam o estado do objeto;
- **M√©todos**: representam a√ß√µes/comportamentos do objeto;
- Os m√©todos s√£o declarados com `void` (quando n√£o retornam valor), seguidos pelo nome e, opcionalmente, par√¢metros;
- Os m√©todos ajudam a **organizar melhor o c√≥digo** e **reutilizar comportamentos**.

---

## üéØ Boas pr√°ticas

- Nomear m√©todos com verbos (ex: `ligar`, `exibirDetalhes`);
- Separar responsabilidades: cada m√©todo deve realizar uma √∫nica tarefa;
- Criar m√©todos para evitar repeti√ß√µes de c√≥digo no `main`.

---

## üß† Conclus√£o

Nessa etapa, al√©m dos atributos, aprendemos como **dar vida aos objetos** com m√©todos. O uso de m√©todos √© essencial na Programa√ß√£o Orientada a Objetos, pois define o **comportamento das classes**, permitindo que elas interajam com outras partes do programa de maneira mais clara, organizada e reutiliz√°vel.

Na pr√≥xima aula, o foco ser√° na cria√ß√£o de **m√©todos com retorno**, introduzindo mais dinamismo √† l√≥gica dos objetos.



[Voltar ao √çndice](#indice)

---


## <a name="parte42">42 - 041 - Orienta√ß√£o Objetos - Coes√£o</a>

# Aula 41 ‚Äì Orienta√ß√£o a Objetos: Coes√£o

üì∫ **V√≠deo:** [Orienta√ß√£o Objetos - Coes√£o](https://www.youtube.com/watch?v=dJLYPP1ExYY&list=PL62G310vn6nFIsOCC0H-C2infYgwm8SWW&index=42)

## üß† O que √© Coes√£o?

**Coes√£o** √© um dos princ√≠pios fundamentais da **Programa√ß√£o Orientada a Objetos (POO)** e se refere ao grau em que os elementos de uma classe est√£o relacionados entre si e com sua **finalidade**.

- Uma classe coesa possui **atributos e m√©todos que fazem sentido juntos**, ou seja, **trabalham por um mesmo objetivo**.
- **Alta coes√£o** resulta em classes **simples, compreens√≠veis e reutiliz√°veis**.
- **Baixa coes√£o** significa que a classe est√° assumindo muitas responsabilidades diferentes e provavelmente precisa ser **refatorada**.

---

## ‚úÖ Exemplo de Alta Coes√£o

```java
public class Impressora {
    void imprimirDocumento(String texto) {
        System.out.println("Imprimindo: " + texto);
    }

    void limparCabecote() {
        System.out.println("Limpando cabe√ßote de impress√£o...");
    }

    void nivelTinta() {
        System.out.println("Verificando n√≠vel de tinta...");
    }
}
```

Essa classe est√° coesa porque todos os m√©todos t√™m rela√ß√£o com a **fun√ß√£o de uma impressora**.

---

## ‚ùå Exemplo de Baixa Coes√£o

```java
public class Util {
    void imprimirDocumento(String texto) {
        System.out.println("Imprimindo: " + texto);
    }

    void calcularSalario(double horas, double valorHora) {
        double salario = horas * valorHora;
        System.out.println("Sal√°rio: " + salario);
    }

    void enviarEmail(String destinatario) {
        System.out.println("Enviando email para: " + destinatario);
    }
}
```

A classe acima tem m√©todos **sem rela√ß√£o entre si** ‚Äì est√° lidando com impress√£o, c√°lculo de sal√°rio e envio de e-mail. Isso **quebra o princ√≠pio da coes√£o**.

---

## üìå Por que Coes√£o √© importante?

- Facilita a **manuten√ß√£o** do c√≥digo;
- Aumenta a **clareza** e legibilidade da classe;
- Permite a **reutiliza√ß√£o** mais eficiente;
- Reduz o **acoplamento** entre diferentes partes do sistema;
- Favorece o uso de **boas pr√°ticas de design**.

---

## üéØ Dica do professor

Pense sempre: **"Minha classe tem uma responsabilidade clara?"**

Se a resposta for **n√£o**, considere **dividir em m√∫ltiplas classes**, cada uma com seu prop√≥sito.

---

## üß† Conclus√£o

A **coes√£o** √© um princ√≠pio essencial na hora de construir boas classes na Programa√ß√£o Orientada a Objetos. Manter a coes√£o ajuda a criar sistemas mais organizados, f√°ceis de manter e evoluir.


[Voltar ao √çndice](#indice)

---


## <a name="parte43">43 - 042 - Orienta√ß√£o Objetos - Exerc√≠cio Classes</a>

# Aula 42 ‚Äì Orienta√ß√£o a Objetos: Exerc√≠cio Classes

üì∫ **V√≠deo:** [Orienta√ß√£o Objetos - Exerc√≠cio Classes](https://www.youtube.com/watch?v=JbL4SAFORco&list=PL62G310vn6nFIsOCC0H-C2infYgwm8SWW&index=43)

## üß† Objetivo da Aula

Nesta aula, √© proposto um exerc√≠cio pr√°tico para refor√ßar os conceitos de **cria√ß√£o de classes**, **instancia√ß√£o de objetos**, **atributos** e **m√©todos** em Java, com base nos princ√≠pios de **orienta√ß√£o a objetos** aprendidos anteriormente.

---

## üß± Estrutura do Exerc√≠cio

O exerc√≠cio consiste em criar uma classe que represente uma pessoa, contendo **atributos**, **m√©todos** e a **utiliza√ß√£o dessa classe no m√©todo `main`**.

---

## üí° Exemplo: Classe `Pessoa`

```java
public class Pessoa {
    String nome;
    int idade;

    void apresentar() {
        System.out.println("Ol√°, meu nome √© " + nome + " e eu tenho " + idade + " anos.");
    }
}
```

---

## üöÄ Utilizando a Classe no `main`

```java
public class Main {
    public static void main(String[] args) {
        Pessoa pessoa1 = new Pessoa();
        pessoa1.nome = "Jo√£o";
        pessoa1.idade = 30;

        Pessoa pessoa2 = new Pessoa();
        pessoa2.nome = "Maria";
        pessoa2.idade = 25;

        pessoa1.apresentar();
        pessoa2.apresentar();
    }
}
```

### üñ®Ô∏è Sa√≠da:
```
Ol√°, meu nome √© Jo√£o e eu tenho 30 anos.
Ol√°, meu nome √© Maria e eu tenho 25 anos.
```

---

## üß± Conceitos Refor√ßados

- Cria√ß√£o de **classes** com atributos e m√©todos.
- Uso do operador `new` para **instanciar objetos**.
- Acesso a atributos e m√©todos de objetos com o operador `.`.
- Separa√ß√£o clara de **responsabilidades**: a classe `Pessoa` representa uma entidade do mundo real.

---

## üìå Boas Pr√°ticas

- A classe deve representar bem o seu conceito do mundo real.
- Os nomes dos m√©todos e atributos devem ser **claros e descritivos**.
- Cada classe deve ser **coesa**, ou seja, focada em uma √∫nica responsabilidade.

---

## ‚úÖ Desafio

Tente adaptar esse exemplo para outras entidades, como `Carro`, `Aluno`, `Produto`, entre outros. Crie novos m√©todos e pratique o uso de diferentes tipos de dados.

---

## üß† Conclus√£o

Esse exerc√≠cio ajuda a fixar os conceitos de orienta√ß√£o a objetos e preparar o terreno para conceitos mais avan√ßados como **encapsulamento, heran√ßa e polimorfismo**.


[Voltar ao √çndice](#indice)

---


## <a name="parte44">44 - 043 - Orienta√ß√£o Objetos - Refer√™ncia de objetos</a>

# Aula 43 ‚Äì Orienta√ß√£o a Objetos: Refer√™ncia de Objetos

üì∫ **V√≠deo:** [Orienta√ß√£o Objetos - Refer√™ncia de objetos](https://www.youtube.com/watch?v=g_SGuMYHgI0&list=PL62G310vn6nFIsOCC0H-C2infYgwm8SWW&index=44)

## üß† Objetivo da Aula

Esta aula aborda como funciona a **refer√™ncia de objetos** em Java. O foco √© entender que quando atribu√≠mos um objeto a outro, **ambos passam a apontar para o mesmo espa√ßo de mem√≥ria**, e **altera√ß√µes feitas por um se refletem no outro**.

---

## üîÑ Conceito: Refer√™ncia

Em Java, vari√°veis de tipo objeto n√£o armazenam o valor diretamente, mas sim uma **refer√™ncia (endere√ßo) para um espa√ßo de mem√≥ria** onde o objeto est√° armazenado.

---

## üí° Exemplo: Refer√™ncia Compartilhada

```java
public class Pessoa {
    String nome;
}

public class Main {
    public static void main(String[] args) {
        Pessoa pessoa1 = new Pessoa();
        pessoa1.nome = "Jo√£o";

        Pessoa pessoa2 = pessoa1; // pessoa2 aponta para o mesmo objeto de pessoa1

        pessoa2.nome = "Maria";

        System.out.println(pessoa1.nome); // Maria
        System.out.println(pessoa2.nome); // Maria
    }
}
```

### üñ®Ô∏è Sa√≠da:
```
Maria
Maria
```

### üìå Explica√ß√£o:

- `pessoa2 = pessoa1` n√£o cria uma nova c√≥pia do objeto.
- Ambas vari√°veis (`pessoa1` e `pessoa2`) apontam para **o mesmo objeto na mem√≥ria**.
- Alterar o atributo `nome` por meio de `pessoa2` tamb√©m altera o que √© visto por `pessoa1`.

---

## üß™ Cuidado com Refer√™ncias!

Se voc√™ quiser **copiar um objeto**, precisa instanciar um novo e copiar manualmente os valores de seus atributos, ou usar t√©cnicas como:

- Construtores de c√≥pia
- M√©todos de clonagem

---

## üîÅ Comparando Refer√™ncias

```java
Pessoa pessoa1 = new Pessoa();
Pessoa pessoa2 = new Pessoa();
Pessoa pessoa3 = pessoa1;

System.out.println(pessoa1 == pessoa2); // false
System.out.println(pessoa1 == pessoa3); // true
```

### ‚úÖ Explica√ß√£o:
- `==` verifica se duas vari√°veis referem-se **ao mesmo objeto** (mesmo endere√ßo de mem√≥ria), e **n√£o o conte√∫do**.

---

## üß† Conclus√£o

Compreender como as refer√™ncias funcionam em Java √© essencial para evitar bugs e comportamentos inesperados em programas orientados a objetos. 

Sempre que estiver manipulando objetos, lembre-se que **voc√™ est√° trabalhando com ponteiros para mem√≥ria**, e n√£o diretamente com os dados em si.



[Voltar ao √çndice](#indice)

---


## <a name="parte45">45 - 044 - Orienta√ß√£o Objetos - M√©todos pt 01</a>

# Aula 44 ‚Äì Orienta√ß√£o a Objetos: M√©todos (Parte 1)

üé• **V√≠deo:** [Orienta√ß√£o Objetos - M√©todos pt 01](https://www.youtube.com/watch?v=ZM0AJhKjLYc&list=PL62G310vn6nFIsOCC0H-C2infYgwm8SWW&index=45)

## üìå Objetivo da Aula

Introdu√ß√£o ao conceito de **m√©todos** em Java no contexto da **Programa√ß√£o Orientada a Objetos (POO)**. A aula demonstra como criar, declarar e utilizar m√©todos dentro de classes, com foco na reutiliza√ß√£o e organiza√ß√£o de c√≥digo.

---

## üß† O que √© um M√©todo?

Um **m√©todo** √© um bloco de c√≥digo que realiza uma a√ß√£o. Pode receber par√¢metros (entradas) e pode retornar um valor (sa√≠da). Os m√©todos ajudam a manter o c√≥digo organizado, reutiliz√°vel e mais f√°cil de manter.

---

## üß± Estrutura de um M√©todo

```java
[modificadorDeAcesso] tipoDeRetorno nomeDoMetodo(par√¢metros) {
    // corpo do m√©todo
}
```

### üîπ Exemplos:

```java
public class Calculadora {

    // M√©todo sem retorno (void) e sem par√¢metros
    void exibirMensagem() {
        System.out.println("Bem-vindo √† Calculadora!");
    }

    // M√©todo com retorno e com par√¢metros
    int somar(int a, int b) {
        return a + b;
    }
}
```

---

## üöÄ Usando M√©todos

```java
public class Main {
    public static void main(String[] args) {
        Calculadora calc = new Calculadora();

        calc.exibirMensagem(); // Chamada de m√©todo sem retorno

        int resultado = calc.somar(10, 5); // Chamada com retorno
        System.out.println("Resultado: " + resultado);
    }
}
```

### üñ®Ô∏è Sa√≠da:
```
Bem-vindo √† Calculadora!
Resultado: 15
```

---

## ‚úÖ Boas Pr√°ticas (Best Practices)

- ‚úÖ **Nomeie m√©todos de forma clara e descritiva.** Use verbos no infinitivo (ex: `calcularMedia`, `exibirMensagem`, `somarValores`).
- ‚úÖ **Cada m√©todo deve ter uma responsabilidade √∫nica.** A coes√£o √© essencial para a clareza do c√≥digo.
- ‚úÖ **Utilize par√¢metros para tornar m√©todos reutiliz√°veis.**
- ‚úÖ **Documente m√©todos** (com `JavaDoc`, por exemplo) para explicar o que eles fazem.
- ‚úÖ **Evite duplica√ß√£o de c√≥digo** utilizando m√©todos sempre que a mesma l√≥gica for repetida.

---

## ‚ùå Pr√°ticas a Evitar (Bad Practices)

- ‚ùå **M√©todos muito longos** e que fazem muitas coisas (baixa coes√£o).
- ‚ùå **Usar nomes gen√©ricos** como `fazerAlgo()` ou `coisa()`.
- ‚ùå **Ignorar o uso de retorno** quando ele pode ser √∫til para reutiliza√ß√£o de resultados.
- ‚ùå **Misturar regras de neg√≥cio com exibi√ß√£o de dados** em um mesmo m√©todo (ex: `calcularResultadoEImprimirNaTela()`).
- ‚ùå **Criar m√©todos est√°ticos sem necessidade**, pois quebra o princ√≠pio de orienta√ß√£o a objetos.

---

## üß† Conclus√£o

Os **m√©todos** s√£o componentes fundamentais para a constru√ß√£o de sistemas orientados a objetos. Eles promovem **organiza√ß√£o, legibilidade, reutiliza√ß√£o e coes√£o** no c√≥digo. Aprender a us√°-los corretamente √© um passo essencial para escrever bons programas em Java.



[Voltar ao √çndice](#indice)

---


## <a name="parte46">46 - 045 - Orienta√ß√£o Objetos - M√©todos pt 02 - Par√¢metros</a>

# Aula 45 ‚Äì Orienta√ß√£o a Objetos: M√©todos (Parte 2 - Par√¢metros)

üé• **V√≠deo:** [Orienta√ß√£o Objetos - M√©todos pt 02 - Par√¢metros](https://www.youtube.com/watch?v=op6inGTMBiw&list=PL62G310vn6nFIsOCC0H-C2infYgwm8SWW&index=46)

## üéØ Objetivo da Aula

Aprender como **par√¢metros** funcionam dentro de **m√©todos** em Java. Entender como pass√°-los, us√°-los e como isso torna os m√©todos mais reutiliz√°veis e din√¢micos. 

---

## üß† O que s√£o Par√¢metros?

Par√¢metros s√£o **vari√°veis declaradas na assinatura de um m√©todo**. Eles permitem a passagem de dados para dentro do m√©todo no momento da chamada, tornando-o mais flex√≠vel.

---

## üß± Sintaxe de um M√©todo com Par√¢metro

```java
[modificadorDeAcesso] tipoDeRetorno nomeDoMetodo(tipo parametro) {
    // corpo do m√©todo
}
```

---

## üí° Exemplo B√°sico

```java
public class Saudacao {
    void exibirMensagem(String nome) {
        System.out.println("Ol√°, " + nome + "!");
    }
}
```

```java
public class Main {
    public static void main(String[] args) {
        Saudacao saudacao = new Saudacao();
        saudacao.exibirMensagem("Ana");
        saudacao.exibirMensagem("Carlos");
    }
}
```

### üñ®Ô∏è Sa√≠da:
```
Ol√°, Ana!
Ol√°, Carlos!
```

---

## üí° Exemplo com M√∫ltiplos Par√¢metros

```java
public class Calculadora {
    int somar(int a, int b) {
        return a + b;
    }
}
```

```java
public class Main {
    public static void main(String[] args) {
        Calculadora calc = new Calculadora();
        int resultado = calc.somar(5, 10);
        System.out.println("Resultado: " + resultado);
    }
}
```

---

## üí° Exemplo Complexo com Objeto como Par√¢metro

```java
public class Produto {
    String nome;
    double preco;

    Produto(String nome, double preco) {
        this.nome = nome;
        this.preco = preco;
    }
}

public class Carrinho {
    void adicionarProduto(Produto produto) {
        System.out.println("Adicionado: " + produto.nome + " por R$" + produto.preco);
    }
}
```

```java
public class Main {
    public static void main(String[] args) {
        Produto p1 = new Produto("Notebook", 3500.00);
        Carrinho carrinho = new Carrinho();
        carrinho.adicionarProduto(p1);
    }
}
```

---

## ‚úÖ Boas Pr√°ticas

- ‚úÖ **Utilize nomes descritivos para os par√¢metros**
  - Exemplo: `nome`, `idade`, `quantidade`.

- ‚úÖ **Mantenha o m√©todo coeso**
  - Um m√©todo deve ter uma √∫nica responsabilidade clara.

- ‚úÖ **Valide os par√¢metros**
  - Principalmente se vierem de entradas do usu√°rio.

- ‚úÖ **Reduza o n√∫mero de par√¢metros**
  - Prefira objetos de transfer√™ncia (DTOs) quando houver muitos par√¢metros.

- ‚úÖ **Documente o que cada par√¢metro representa**
  - Coment√°rios ou Javadoc ajudam na manuten√ß√£o do c√≥digo.

---

## ‚ùå Pr√°ticas a Evitar

- ‚ùå **Nomes gen√©ricos ou confusos para par√¢metros**
  - Exemplo: `x`, `y`, `data1`.

- ‚ùå **M√©todos com muitos par√¢metros**
  - Exemplo: `processar(int a, int b, int c, String nome, double taxa, boolean ativo)`

- ‚ùå **Alterar o valor dos par√¢metros diretamente**
  - Especialmente se o par√¢metro for um objeto mut√°vel.

- ‚ùå **Ignorar valida√ß√µes**
  - Pode causar exce√ß√µes ou l√≥gica incorreta.

---

## üìå Dica Extra

Se voc√™ estiver passando **muitos par√¢metros** para um m√©todo, considere criar uma **classe auxiliar** para encapsular esses dados:

```java
public class PedidoInfo {
    String produto;
    int quantidade;
    double preco;
    // construtor, getters, setters
}
```

```java
public class PedidoService {
    void processarPedido(PedidoInfo info) {
        // l√≥gica usando info.produto, info.quantidade, etc.
    }
}
```

---

## ‚úÖ Conclus√£o

O uso de par√¢metros √© fundamental para a **flexibilidade** e **reutiliza√ß√£o** dos m√©todos em Java. Compreender sua estrutura, boas pr√°ticas e evitar armadilhas comuns s√£o passos importantes na evolu√ß√£o como desenvolvedor orientado a objetos.



[Voltar ao √çndice](#indice)

---


## <a name="parte47">47 - 046 - Orienta√ß√£o Objetos - M√©todos pt 03 - Retorno pt 01</a>

# Aula 46 ‚Äì Orienta√ß√£o a Objetos: M√©todos pt 03 - Retorno (Parte 1)

üé• **V√≠deo:** [M√©todos pt 03 - Retorno pt 01](https://www.youtube.com/watch?v=FCnTsy2EzSw&list=PL62G310vn6nFIsOCC0H-C2infYgwm8SWW&index=47)

## üéØ Objetivo da Aula

Compreender como os **m√©todos com retorno** funcionam em Java, como declarar e utilizar o valor retornado. A aula mostra como m√©todos podem retornar valores √∫teis para outras partes do c√≥digo.

---

## üß† O que √© o Retorno de um M√©todo?

- Um m√©todo pode retornar um **valor** ap√≥s sua execu√ß√£o.
- O tipo de retorno √© declarado na **assinatura do m√©todo**.
- O comando `return` √© usado para devolver o valor.

### Sintaxe:
```java
tipo nomeDoMetodo() {
    return valor;
}
```

---

## üí° Exemplo B√°sico - M√©todo que retorna um n√∫mero

```java
public class Calculadora {
    int somar(int a, int b) {
        return a + b;
    }
}
```

```java
public class Main {
    public static void main(String[] args) {
        Calculadora calc = new Calculadora();
        int resultado = calc.somar(10, 5);
        System.out.println("Resultado da soma: " + resultado);
    }
}
```

---

## üí° Exemplo Intermedi√°rio - Retorno de String

```java
public class Saudacao {
    String mensagemDeBoasVindas(String nome) {
        return "Bem-vindo, " + nome + "!";
    }
}
```

```java
public class Main {
    public static void main(String[] args) {
        Saudacao saudacao = new Saudacao();
        String msg = saudacao.mensagemDeBoasVindas("Maria");
        System.out.println(msg);
    }
}
```

---

## üí° Exemplo Complexo - Retorno de Objeto

```java
public class Produto {
    String nome;
    double preco;

    Produto(String nome, double preco) {
        this.nome = nome;
        this.preco = preco;
    }
}

public class Estoque {
    Produto buscarProdutoMaisCaro() {
        return new Produto("Notebook Gamer", 7500.00);
    }
}
```

```java
public class Main {
    public static void main(String[] args) {
        Estoque estoque = new Estoque();
        Produto p = estoque.buscarProdutoMaisCaro();
        System.out.println("Produto: " + p.nome + ", Pre√ßo: R$" + p.preco);
    }
}
```

---

## ‚úÖ Boas Pr√°ticas

- ‚úÖ **Use o tipo de retorno correto** conforme a l√≥gica do m√©todo.
- ‚úÖ **Documente o retorno** (ex: com Javadoc).
- ‚úÖ **Evite l√≥gica excessiva dentro do m√©todo**, mantenha-o coeso.
- ‚úÖ **Valide os dados antes de retornar**, quando necess√°rio.
- ‚úÖ **Prefira retornar objetos ao inv√©s de m√∫ltiplos valores soltos**.

---

## ‚ùå M√°s Pr√°ticas a Evitar

- ‚ùå **Retornar valores irrelevantes** ou sempre fixos (ex: sempre `0` ou `null`).
- ‚ùå **Executar v√°rias tarefas no m√©todo al√©m do necess√°rio** (falta de coes√£o).
- ‚ùå **Retornar dados modificados inesperadamente** (quebra de encapsulamento).
- ‚ùå **Deixar c√≥digo duplicado em m√©todos semelhantes**.

---

## üìå Dica Extra

Se um m√©todo **n√£o precisar retornar nada**, use o tipo `void`:

```java
void imprimirMensagem(String msg) {
    System.out.println(msg);
}
```

Se quiser retornar algo depois de algum c√°lculo ou processo, troque o `void` pelo tipo necess√°rio e use `return`.

---

## ‚úÖ Conclus√£o

Entender o uso do `return` e m√©todos com retorno √© fundamental para criar sistemas **modulares, reutiliz√°veis e f√°ceis de manter**. Eles ajudam a separar responsabilidades e permitem reutilizar l√≥gicas complexas com simplicidade.



[Voltar ao √çndice](#indice)

---


## <a name="parte48">48 - 047 - Orienta√ß√£o Objetos - M√©todos pt 04 - Retorno pt 02</a>

# Aula 47 ‚Äì Orienta√ß√£o a Objetos: M√©todos pt 04 - Retorno (Parte 2)

üé• **V√≠deo:** [M√©todos pt 04 - Retorno pt 02](https://www.youtube.com/watch?v=d0BO5mBBFK8&list=PL62G310vn6nFIsOCC0H-C2infYgwm8SWW&index=48)

## üéØ Objetivo da Aula

Aprofundar o entendimento sobre m√©todos que retornam valores em Java, explorando diferentes tipos de retorno, boas pr√°ticas e erros comuns a serem evitados.

---

## üß† Conceitos Fundamentais

- **Tipo de Retorno:** O tipo especificado na assinatura do m√©todo deve corresponder ao tipo do valor retornado.
- **Uso do `return`:** A instru√ß√£o `return` √© utilizada para devolver um valor ao chamador do m√©todo.
- **M√©todos `void`:** M√©todos declarados com `void` n√£o retornam valor e n√£o precisam de uma instru√ß√£o `return`, embora possam us√°-la para sair antecipadamente do m√©todo.

---

## üí° Exemplo B√°sico - Retorno de Valor Primitivo

```java
public class Calculadora {
    public int multiplicar(int a, int b) {
        return a * b;
    }
}
```

```java
public class Main {
    public static void main(String[] args) {
        Calculadora calc = new Calculadora();
        int resultado = calc.multiplicar(4, 5);
        System.out.println("Resultado: " + resultado);
    }
}
```

---

## üí° Exemplo Intermedi√°rio - Retorno de Objeto

```java
public class Produto {
    String nome;
    double preco;

    Produto(String nome, double preco) {
        this.nome = nome;
        this.preco = preco;
    }
}

public class Estoque {
    public Produto obterProdutoMaisCaro() {
        return new Produto("Notebook", 3500.00);
    }
}
```

```java
public class Main {
    public static void main(String[] args) {
        Estoque estoque = new Estoque();
        Produto produto = estoque.obterProdutoMaisCaro();
        System.out.println("Produto: " + produto.nome + ", Pre√ßo: R$" + produto.preco);
    }
}
```

---

## üí° Exemplo Avan√ßado - Retorno de Cole√ß√£o

```java
import java.util.ArrayList;
import java.util.List;

public class Carrinho {
    public List<String> listarProdutos() {
        List<String> produtos = new ArrayList<>();
        produtos.add("Mouse");
        produtos.add("Teclado");
        produtos.add("Monitor");
        return produtos;
    }
}
```

```java
public class Main {
    public static void main(String[] args) {
        Carrinho carrinho = new Carrinho();
        List<String> produtos = carrinho.listarProdutos();
        for (String produto : produtos) {
            System.out.println("Produto: " + produto);
        }
    }
}
```

---

## ‚úÖ Boas Pr√°ticas

- **Correspond√™ncia de Tipos:** Certifique-se de que o tipo de retorno declarado corresponde ao tipo do valor retornado.
- **Clareza no Retorno:** Retorne valores significativos que fa√ßam sentido no contexto do m√©todo.
- **Documenta√ß√£o:** Utilize coment√°rios ou Javadoc para descrever o que o m√©todo retorna.
- **Evite Retornar `null`:** Sempre que poss√≠vel, evite retornar `null` para prevenir `NullPointerException`. Considere retornar objetos vazios ou usar `Optional`.
- **Consist√™ncia:** Mantenha consist√™ncia nos tipos de retorno em m√©todos similares.

---

## ‚ùå Pr√°ticas a Evitar

- **Retornar Tipos Incompat√≠veis:** Evite retornar um tipo diferente do declarado na assinatura do m√©todo, pois isso causar√° erros de compila√ß√£o.
- **Retornar `null` Desnecessariamente:** Retornar `null` pode levar a erros em tempo de execu√ß√£o. Prefira retornar objetos vazios ou utilizar `Optional`.
- **M√©todos com M√∫ltiplos Pontos de Retorno Confusos:** Embora m√∫ltiplos `return` possam ser √∫teis, evite us√°-los de forma que torne o c√≥digo dif√≠cil de entender.
- **Ignorar o Valor Retornado:** Se um m√©todo retorna um valor, utilize-o. Ignorar o valor pode indicar que o m√©todo deveria ser `void`.

---

## üìå Dica Extra

Para m√©todos que podem n√£o ter um valor a retornar, considere o uso de `Optional`:

```java
import java.util.Optional;

public class UsuarioService {
    public Optional<Usuario> buscarUsuarioPorId(int id) {
        // L√≥gica para buscar o usu√°rio
        if (/* usu√°rio encontrado */) {
            return Optional.of(usuario);
        } else {
            return Optional.empty();
        }
    }
}
```

---

## ‚úÖ Conclus√£o

Compreender e aplicar corretamente o conceito de retorno em m√©todos √© essencial para escrever c√≥digo Java limpo, eficiente e livre de erros. Utilize os exemplos e pr√°ticas descritas acima para aprimorar suas habilidades em programa√ß√£o orientada a objetos.


[Voltar ao √çndice](#indice)

---


## <a name="parte49">49 - 048 - Orienta√ß√£o Objetos - M√©todos pt 05 - Par√¢metros tipo primitivo</a>

# Aula 48 ‚Äì Orienta√ß√£o a Objetos: M√©todos pt 05 - Par√¢metros Tipo Primitivo

üé• **V√≠deo:** [M√©todos pt 05 - Par√¢metros tipo primitivo](https://www.youtube.com/watch?v=-izqpkaXKx0&list=PL62G310vn6nFIsOCC0H-C2infYgwm8SWW&index=49)

## üéØ Objetivo da Aula

Compreender como os m√©todos em Java recebem e manipulam par√¢metros de tipos primitivos, destacando o comportamento de passagem por valor e suas implica√ß√µes.

---

## üß† Conceitos Fundamentais

- **Tipos Primitivos em Java:** `byte`, `short`, `int`, `long`, `float`, `double`, `char`, `boolean`.
- **Passagem por Valor:** Em Java, todos os par√¢metros s√£o passados por valor. Para tipos primitivos, isso significa que o m√©todo recebe uma c√≥pia do valor original, e altera√ß√µes dentro do m√©todo n√£o afetam a vari√°vel original.

---

## üí° Exemplo B√°sico - Passagem por Valor

```java
public class Exemplo {
    public static void incrementar(int numero) {
        numero++;
        System.out.println("Dentro do m√©todo: " + numero);
    }

    public static void main(String[] args) {
        int valor = 5;
        incrementar(valor);
        System.out.println("Fora do m√©todo: " + valor);
    }
}
```

**Sa√≠da:**
```
Dentro do m√©todo: 6
Fora do m√©todo: 5
```

*Explica√ß√£o:* O m√©todo `incrementar` recebe uma c√≥pia do valor de `valor`. Altera√ß√µes em `numero` dentro do m√©todo n√£o afetam `valor` fora dele.

---

## üí° Exemplo Intermedi√°rio - Opera√ß√µes com V√°rios Par√¢metros Primitivos

```java
public class Calculadora {
    public static int somar(int a, int b) {
        return a + b;
    }

    public static void main(String[] args) {
        int resultado = somar(10, 20);
        System.out.println("Resultado da soma: " + resultado);
    }
}
```

*Explica√ß√£o:* O m√©todo `somar` recebe dois par√¢metros primitivos, realiza a opera√ß√£o e retorna o resultado. Os valores originais n√£o s√£o modificados.

---

## üí° Exemplo Avan√ßado - Utilizando Tipos Primitivos em C√°lculos Complexos

```java
public class ConversorTemperatura {
    public static double celsiusParaFahrenheit(double celsius) {
        return (celsius * 9/5) + 32;
    }

    public static void main(String[] args) {
        double celsius = 25.0;
        double fahrenheit = celsiusParaFahrenheit(celsius);
        System.out.println(celsius + "¬∞C equivalem a " + fahrenheit + "¬∞F");
    }
}
```

*Explica√ß√£o:* O m√©todo `celsiusParaFahrenheit` realiza uma convers√£o utilizando um par√¢metro primitivo do tipo `double`.

---

## ‚úÖ Boas Pr√°ticas

- **Utilize Tipos Primitivos Quando Poss√≠vel:** Eles s√£o mais eficientes em termos de desempenho e uso de mem√≥ria.
- **Evite Modificar Par√¢metros Primitivos Dentro do M√©todo:** Como s√£o passados por valor, altera√ß√µes n√£o afetam o valor original, o que pode levar a confus√µes.
- **Documente o Comportamento dos M√©todos:** Especifique claramente se o m√©todo modifica ou n√£o os valores passados.
- **Escolha o Tipo Primitivo Adequado:** Utilize o tipo que melhor representa o dado e evita desperd√≠cio de mem√≥ria.

---

## ‚ùå Pr√°ticas a Evitar

- **N√£o Presuma que Altera√ß√µes em Par√¢metros Primitivos Afetam o Valor Original:** Lembre-se que s√£o passados por valor.
- **Evite Usar Tipos Primitivos em Contextos que Requerem Objetos:** Por exemplo, ao trabalhar com cole√ß√µes gen√©ricas, utilize as classes wrapper correspondentes (`Integer`, `Double`, etc.).
- **N√£o Utilize Tipos Primitivos para Representar Estados Complexos:** Prefira enums ou objetos para representar estados ou comportamentos mais complexos.

---

## üìå Dica Extra

Ao trabalhar com cole√ß√µes ou APIs que exigem objetos, utilize as classes wrapper correspondentes aos tipos primitivos:

```java
List<Integer> numeros = new ArrayList<>();
numeros.add(10); // Autoboxing de int para Integer
```

*Explica√ß√£o:* O Java realiza automaticamente a convers√£o de tipos primitivos para suas classes wrapper correspondentes (autoboxing) quando necess√°rio.

---

## ‚úÖ Conclus√£o

Entender como os par√¢metros de tipos primitivos s√£o passados e manipulados em m√©todos √© fundamental para evitar comportamentos inesperados e escrever c√≥digo Java eficiente e claro.



[Voltar ao √çndice](#indice)

---


## <a name="parte50">50 - 049 - Orienta√ß√£o Objetos - M√©todos pt 06 - Par√¢metros tipo refer√™ncia</a>

# Aula 49 ‚Äì Orienta√ß√£o a Objetos: M√©todos pt 06 - Par√¢metros Tipo Refer√™ncia

üé• **V√≠deo:** [M√©todos pt 06 - Par√¢metros tipo refer√™ncia](https://www.youtube.com/watch?v=C-tmxo4FcKs)

## üéØ Objetivo da Aula

Compreender como os m√©todos em Java recebem e manipulam par√¢metros de tipos refer√™ncia (objetos), destacando o comportamento de passagem por valor de refer√™ncias e suas implica√ß√µes.

---

## üß† Conceitos Fundamentais

- **Tipos de Refer√™ncia em Java:** Incluem todas as classes, interfaces, arrays e enumeradores.
- **Passagem por Valor de Refer√™ncia:** Em Java, todos os par√¢metros s√£o passados por valor. No caso de objetos, o valor passado √© a refer√™ncia ao objeto, permitindo que m√©todos modifiquem o estado interno do objeto, mas n√£o a refer√™ncia em si.
- **Imutabilidade da Refer√™ncia:** Alterar a refer√™ncia dentro do m√©todo n√£o afeta a refer√™ncia original fora dele.

---

## üí° Exemplo B√°sico - Modificando o Estado do Objeto

```java
public class Pessoa {
    String nome;
}

public class Exemplo {
    public static void alterarNome(Pessoa p) {
        p.nome = "Jo√£o";
    }

    public static void main(String[] args) {
        Pessoa pessoa = new Pessoa();
        pessoa.nome = "Maria";
        alterarNome(pessoa);
        System.out.println(pessoa.nome); // Sa√≠da: Jo√£o
    }
}
```

*Explica√ß√£o:* O m√©todo `alterarNome` modifica o atributo `nome` do objeto `Pessoa`. Como a refer√™ncia ao objeto √© passada por valor, o m√©todo pode alterar o estado interno do objeto.

---

## üí° Exemplo Intermedi√°rio - Tentando Alterar a Refer√™ncia

```java
public class Pessoa {
    String nome;
}

public class Exemplo {
    public static void criarNovaPessoa(Pessoa p) {
        p = new Pessoa();
        p.nome = "Carlos";
    }

    public static void main(String[] args) {
        Pessoa pessoa = new Pessoa();
        pessoa.nome = "Ana";
        criarNovaPessoa(pessoa);
        System.out.println(pessoa.nome); // Sa√≠da: Ana
    }
}
```

*Explica√ß√£o:* O m√©todo `criarNovaPessoa` atribui uma nova inst√¢ncia √† vari√°vel `p`, mas essa altera√ß√£o n√£o afeta a vari√°vel `pessoa` no m√©todo `main`, pois a refer√™ncia √© passada por valor.

---

## üí° Exemplo Avan√ßado - Modificando Objetos em Cole√ß√µes

```java
import java.util.ArrayList;
import java.util.List;

public class Exemplo {
    public static void adicionarElemento(List<String> lista) {
        lista.add("Novo Elemento");
    }

    public static void main(String[] args) {
        List<String> minhaLista = new ArrayList<>();
        minhaLista.add("Elemento 1");
        adicionarElemento(minhaLista);
        System.out.println(minhaLista); // Sa√≠da: [Elemento 1, Novo Elemento]
    }
}
```

*Explica√ß√£o:* O m√©todo `adicionarElemento` modifica o conte√∫do da lista, e essa modifica√ß√£o √© refletida fora do m√©todo, pois a lista √© um objeto e sua refer√™ncia √© passada por valor.

---

## ‚úÖ Boas Pr√°ticas

- **Compreens√£o Clara da Passagem por Valor de Refer√™ncia:** Entenda que, embora a refer√™ncia seja passada por valor, o objeto referenciado pode ser modificado dentro do m√©todo.
- **Evite Alterar a Refer√™ncia Dentro do M√©todo:** Alterar a refer√™ncia dentro do m√©todo n√£o afeta a refer√™ncia original e pode causar confus√£o.
- **Documente o Comportamento dos M√©todos:** Especifique claramente se o m√©todo modifica ou n√£o o estado dos objetos passados como par√¢metros.
- **Utilize Objetos Imut√°veis Quando Apropriado:** Para evitar efeitos colaterais indesejados, considere o uso de objetos imut√°veis.

---

## ‚ùå Pr√°ticas a Evitar

- **Supor que a Refer√™ncia Pode Ser Alterada Dentro do M√©todo:** Lembre-se de que alterar a refer√™ncia dentro do m√©todo n√£o afeta a refer√™ncia original.
- **Modificar Objetos Sem Necessidade:** Evite modificar o estado de objetos passados como par√¢metros se isso n√£o for necess√°rio, para manter a previsibilidade do c√≥digo.
- **Falta de Clareza no Comportamento do M√©todo:** M√©todos que modificam objetos passados como par√¢metros devem deixar isso claro em sua documenta√ß√£o e nome.

---

## üìå Dica Extra

Para evitar modifica√ß√µes indesejadas em objetos passados como par√¢metros, considere criar c√≥pias dos objetos dentro do m√©todo:

```java
public class Pessoa {
    String nome;

    public Pessoa(String nome) {
        this.nome = nome;
    }

    public Pessoa(Pessoa outra) {
        this.nome = outra.nome;
    }
}

public class Exemplo {
    public static void alterarNome(Pessoa p) {
        Pessoa copia = new Pessoa(p);
        copia.nome = "Jo√£o";
        // Modifica√ß√µes em 'copia' n√£o afetam o objeto original
    }
}
```

*Explica√ß√£o:* Criar uma c√≥pia do objeto dentro do m√©todo permite que modifica√ß√µes sejam feitas sem afetar o objeto original.

---

## ‚úÖ Conclus√£o

Entender como os par√¢metros de tipos refer√™ncia s√£o passados e manipulados em m√©todos √© fundamental para evitar comportamentos inesperados e escrever c√≥digo Java eficiente e claro.



[Voltar ao √çndice](#indice)

---


## <a name="parte51">51 - 050 - Orienta√ß√£o Objetos - M√©todos pt 07 - Par√¢metros tipo refer√™ncia pt 02</a>

# Aula 50 ‚Äì Orienta√ß√£o a Objetos: M√©todos pt 07 - Par√¢metros Tipo Refer√™ncia pt 02

üé• **V√≠deo:** [M√©todos pt 07 - Par√¢metros tipo refer√™ncia pt 02](https://www.youtube.com/watch?v=OMuzOoHAEpg)

## üéØ Objetivo da Aula

Aprofundar o entendimento sobre a passagem de par√¢metros de tipo refer√™ncia em m√©todos Java, destacando como altera√ß√µes nos objetos passados como par√¢metros afetam o estado desses objetos fora do m√©todo.

---

## üß† Conceitos Fundamentais

- **Passagem por Valor de Refer√™ncia:** Em Java, os par√¢metros s√£o passados por valor. No caso de objetos, o valor passado √© a refer√™ncia ao objeto, permitindo que m√©todos modifiquem o estado interno do objeto, mas n√£o a refer√™ncia em si.
- **Imutabilidade da Refer√™ncia:** Alterar a refer√™ncia dentro do m√©todo n√£o afeta a refer√™ncia original fora dele.
- **Mutabilidade do Objeto:** Altera√ß√µes no estado do objeto dentro do m√©todo s√£o refletidas fora dele, pois ambos os m√©todos compartilham a mesma refer√™ncia.

---

## üí° Exemplo B√°sico - Modificando o Estado do Objeto

```java
public class Carro {
    String modelo;
}

public class Exemplo {
    public static void alterarModelo(Carro carro) {
        carro.modelo = "Fusca";
    }

    public static void main(String[] args) {
        Carro meuCarro = new Carro();
        meuCarro.modelo = "Civic";
        alterarModelo(meuCarro);
        System.out.println(meuCarro.modelo); // Sa√≠da: Fusca
    }
}
```

*Explica√ß√£o:* O m√©todo `alterarModelo` modifica o atributo `modelo` do objeto `Carro`. Como a refer√™ncia ao objeto √© passada por valor, o m√©todo pode alterar o estado interno do objeto.

---

## üí° Exemplo Intermedi√°rio - Tentando Alterar a Refer√™ncia

```java
public class Carro {
    String modelo;
}

public class Exemplo {
    public static void criarNovoCarro(Carro carro) {
        carro = new Carro();
        carro.modelo = "Gol";
    }

    public static void main(String[] args) {
        Carro meuCarro = new Carro();
        meuCarro.modelo = "Civic";
        criarNovoCarro(meuCarro);
        System.out.println(meuCarro.modelo); // Sa√≠da: Civic
    }
}
```

*Explica√ß√£o:* O m√©todo `criarNovoCarro` atribui uma nova inst√¢ncia √† vari√°vel `carro`, mas essa altera√ß√£o n√£o afeta a vari√°vel `meuCarro` no m√©todo `main`, pois a refer√™ncia √© passada por valor.

---

## üí° Exemplo Avan√ßado - Modificando Objetos em Cole√ß√µes

```java
import java.util.ArrayList;
import java.util.List;

public class Exemplo {
    public static void adicionarElemento(List<String> lista) {
        lista.add("Novo Elemento");
    }

    public static void main(String[] args) {
        List<String> minhaLista = new ArrayList<>();
        minhaLista.add("Elemento 1");
        adicionarElemento(minhaLista);
        System.out.println(minhaLista); // Sa√≠da: [Elemento 1, Novo Elemento]
    }
}
```

*Explica√ß√£o:* O m√©todo `adicionarElemento` modifica o conte√∫do da lista, e essa modifica√ß√£o √© refletida fora do m√©todo, pois a lista √© um objeto e sua refer√™ncia √© passada por valor.

---

## ‚úÖ Boas Pr√°ticas

- **Compreens√£o Clara da Passagem por Valor de Refer√™ncia:** Entenda que, embora a refer√™ncia seja passada por valor, o objeto referenciado pode ser modificado dentro do m√©todo.
- **Evite Alterar a Refer√™ncia Dentro do M√©todo:** Alterar a refer√™ncia dentro do m√©todo n√£o afeta a refer√™ncia original e pode causar confus√£o.
- **Documente o Comportamento dos M√©todos:** Especifique claramente se o m√©todo modifica ou n√£o o estado dos objetos passados como par√¢metros.
- **Utilize Objetos Imut√°veis Quando Apropriado:** Para evitar efeitos colaterais indesejados, considere o uso de objetos imut√°veis.

---

## ‚ùå Pr√°ticas a Evitar

- **Supor que a Refer√™ncia Pode Ser Alterada Dentro do M√©todo:** Lembre-se de que alterar a refer√™ncia dentro do m√©todo n√£o afeta a refer√™ncia original.
- **Modificar Objetos Sem Necessidade:** Evite modificar o estado de objetos passados como par√¢metros se isso n√£o for necess√°rio, para manter a previsibilidade do c√≥digo.
- **Falta de Clareza no Comportamento do M√©todo:** M√©todos que modificam objetos passados como par√¢metros devem deixar isso claro em sua documenta√ß√£o e nome.

---

## üìå Dica Extra

Para evitar modifica√ß√µes indesejadas em objetos passados como par√¢metros, considere criar c√≥pias dos objetos dentro do m√©todo:

```java
public class Carro {
    String modelo;

    public Carro(String modelo) {
        this.modelo = modelo;
    }

    public Carro(Carro outro) {
        this.modelo = outro.modelo;
    }
}

public class Exemplo {
    public static void alterarModelo(Carro carro) {
        Carro copia = new Carro(carro);
        copia.modelo = "Fusca";
        // Modifica√ß√µes em 'copia' n√£o afetam o objeto original
    }
}
```

*Explica√ß√£o:* Criar uma c√≥pia do objeto dentro do m√©todo permite que modifica√ß√µes sejam feitas sem afetar o objeto original.

---

## ‚úÖ Conclus√£o

Entender como os par√¢metros de tipos refer√™ncia s√£o passados e manipulados em m√©todos √© fundamental para evitar comportamentos inesperados e escrever c√≥digo Java eficiente e claro.



[Voltar ao √çndice](#indice)

---


## <a name="parte52">52 - 051 - Orienta√ß√£o Objetos - M√©todos pt 08 - Refer√™ncia this</a>

# Aula 51 ‚Äì Orienta√ß√£o a Objetos: M√©todos pt 08 - Refer√™ncia `this`

üì∫ **V√≠deo:** [Refer√™ncia this](https://www.youtube.com/watch?v=0fVZlarZ-Lg&list=PL62G310vn6nFIsOCC0H-C2infYgwm8SWW&index=53)

## üéØ Objetivo

Entender como funciona a palavra-chave `this` em Java, utilizada para referenciar o pr√≥prio objeto dentro de m√©todos e construtores. A aula mostra como usar `this` para resolver ambiguidades, chamar construtores sobrecarregados e aplicar em m√©todos encadeados (method chaining).

---

## üîπ O que √© `this`?

A palavra-chave `this` √© uma refer√™ncia ao objeto atual da classe. Ela √© usada para:

- Diferenciar vari√°veis de inst√¢ncia de par√¢metros com o mesmo nome.
- Chamar outro construtor dentro da mesma classe (`this(...)`).
- Retornar o pr√≥prio objeto, permitindo encadeamento de m√©todos.

---

## üí° Exemplo B√°sico ‚Äì Resolvendo Ambiguidade

```java
public class Produto {
    String nome;

    public void setNome(String nome) {
        this.nome = nome; // "this.nome" se refere √† vari√°vel de inst√¢ncia
    }

    public void imprimir() {
        System.out.println(this.nome);
    }
}
```

### Explica√ß√£o:
Sem `this`, o Java entende que `nome = nome` se refere ao par√¢metro da fun√ß√£o, causando erro l√≥gico. Com `this.nome`, deixamos claro que estamos acessando o atributo do objeto.

---

## üí° Exemplo Intermedi√°rio ‚Äì Chamando outro Construtor

```java
public class Pessoa {
    String nome;
    int idade;

    public Pessoa(String nome) {
        this(nome, 0); // chama o outro construtor com idade 0
    }

    public Pessoa(String nome, int idade) {
        this.nome = nome;
        this.idade = idade;
    }
}
```

### Explica√ß√£o:
Utilizando `this(...)`, chamamos outro construtor da mesma classe, evitando repeti√ß√£o de c√≥digo e garantindo consist√™ncia de inicializa√ß√£o.

---

## üí° Exemplo Avan√ßado ‚Äì Method Chaining (Encadeamento de M√©todos)

```java
public class Carro {
    String modelo;
    int ano;

    public Carro setModelo(String modelo) {
        this.modelo = modelo;
        return this;
    }

    public Carro setAno(int ano) {
        this.ano = ano;
        return this;
    }

    public void mostrar() {
        System.out.println("Modelo: " + this.modelo + ", Ano: " + this.ano);
    }
}
```

### Uso:
```java
Carro carro = new Carro();
carro.setModelo("Fusca").setAno(1975).mostrar();
```

### Explica√ß√£o:
Ao retornar `this`, √© poss√≠vel encadear chamadas de m√©todos em uma √∫nica linha de c√≥digo, o que melhora a legibilidade em alguns contextos.

---

## ‚úÖ Boas Pr√°ticas

- Utilize `this` para deixar o c√≥digo claro quando h√° ambiguidade entre par√¢metros e atributos.
- Prefira `this(...)` para reusar l√≥gica de construtores.
- Encadeie m√©todos (`method chaining`) quando isso deixar o c√≥digo mais leg√≠vel.
- Use `this` em contextos onde voc√™ deseja destacar explicitamente que est√° lidando com atributos do objeto.

---

## ‚ùå Piores Pr√°ticas

- ‚ùå Usar `this` em m√©todos `static` (isso gera erro, pois n√£o h√° objeto associado).
- ‚ùå Criar par√¢metros com os mesmos nomes dos atributos e esquecer de usar `this`, o que causa erros de l√≥gica.
- ‚ùå Usar encadeamento de m√©todos em excesso, o que pode dificultar a leitura se os m√©todos forem muitos ou complexos.
- ‚ùå Criar muitos construtores com l√≥gica duplicada ao inv√©s de usar `this(...)`.

---

## üìå Dica Extra

`this` tamb√©m pode ser passado como argumento para outros m√©todos ou classes, representando o pr√≥prio objeto atual. Exemplo:

```java
public class Teste {
    public void mostrar() {
        util(this); // passa o objeto atual
    }

    public void util(Teste obj) {
        System.out.println("Objeto recebido!");
    }
}
```

---

## üß† Conclus√£o

A refer√™ncia `this` √© essencial para escrever c√≥digo orientado a objetos limpo e bem estruturado em Java. Ela evita ambiguidades, melhora a clareza e permite padr√µes como method chaining e reutiliza√ß√£o de construtores.



[Voltar ao √çndice](#indice)

---


## <a name="parte53">53 - 052 - Orienta√ß√£o Objetos - M√©todos pt 09 - Varargs</a>

# Aula 52 ‚Äì Orienta√ß√£o a Objetos: M√©todos pt 09 - Varargs

üé• **V√≠deo:** [M√©todos pt 09 - Varargs](https://www.youtube.com/watch?v=T0E4Ewwz1IY&list=PL62G310vn6nFIsOCC0H-C2infYgwm8SWW&index=53)

## üéØ Objetivo da Aula

Compreender o uso de **Varargs** (argumentos de comprimento vari√°vel) em Java, que permitem a cria√ß√£o de m√©todos capazes de receber um n√∫mero vari√°vel de argumentos, proporcionando maior flexibilidade e legibilidade ao c√≥digo.

---

## üß† Conceitos Fundamentais

- **Varargs** (introduced in Java 5) permitem que m√©todos aceitem um n√∫mero vari√°vel de argumentos do mesmo tipo, utilizando a sintaxe `tipo... nomeParametro`.
- Internamente, o compilador Java trata os varargs como arrays, permitindo itera√ß√£o e manipula√ß√£o como em arrays comuns.
- Um m√©todo pode ter **apenas um par√¢metro varargs**, e este deve ser o **√∫ltimo** na lista de par√¢metros.

---

## üí° Exemplo B√°sico ‚Äì M√©todo com Varargs

```java
public class ExemploVarargs {
    public static void imprimirNomes(String... nomes) {
        for (String nome : nomes) {
            System.out.println(nome);
        }
    }

    public static void main(String[] args) {
        imprimirNomes("Ana", "Bruno", "Carlos");
    }
}
```

### Explica√ß√£o:
O m√©todo `imprimirNomes` pode receber qualquer n√∫mero de argumentos do tipo `String`. No exemplo, s√£o passados tr√™s nomes, mas poderia ser nenhum ou muitos mais.

---

## üí° Exemplo Intermedi√°rio ‚Äì Varargs com Outros Par√¢metros

```java
public class ExemploVarargs {
    public static void exibirInformacoes(String titulo, int... numeros) {
        System.out.println("T√≠tulo: " + titulo);
        for (int numero : numeros) {
            System.out.println("N√∫mero: " + numero);
        }
    }

    public static void main(String[] args) {
        exibirInformacoes("N√∫meros Importantes", 10, 20, 30);
    }
}
```

### Explica√ß√£o:
O m√©todo `exibirInformacoes` possui um par√¢metro fixo (`titulo`) e um varargs (`numeros`). O varargs deve ser sempre o √∫ltimo par√¢metro na assinatura do m√©todo.

---

## üí° Exemplo Avan√ßado ‚Äì Uso de Varargs com Tipos Gen√©ricos

```java
public class ExemploVarargs {
    @SafeVarargs
    public static <T> void imprimirElementos(T... elementos) {
        for (T elemento : elementos) {
            System.out.println(elemento);
        }
    }

    public static void main(String[] args) {
        imprimirElementos(1, 2, 3);
        imprimirElementos("A", "B", "C");
    }
}
```

### Explica√ß√£o:
Utilizando varargs com tipos gen√©ricos, √© poss√≠vel criar m√©todos mais flex√≠veis. A anota√ß√£o `@SafeVarargs` √© usada para suprimir avisos de seguran√ßa relacionados ao uso de varargs com generics.

---

## ‚úÖ Boas Pr√°ticas

- **Colocar o par√¢metro varargs como o √∫ltimo na lista de par√¢metros** para evitar ambiguidades na chamada do m√©todo.
- **Usar varargs quando o n√∫mero de argumentos pode variar**, proporcionando maior flexibilidade e legibilidade.
- **Adicionar a anota√ß√£o `@SafeVarargs`** em m√©todos est√°ticos ou finais que utilizam varargs com tipos gen√©ricos para evitar avisos de seguran√ßa.
- **Documentar claramente o comportamento do m√©todo** ao utilizar varargs, especialmente se o m√©todo aceitar zero argumentos.

---

## ‚ùå Pr√°ticas a Evitar

- ‚ùå **Ter mais de um par√¢metro varargs** em um √∫nico m√©todo, o que n√£o √© permitido e causar√° erro de compila√ß√£o.
- ‚ùå **Colocar o par√¢metro varargs antes de outros par√¢metros**, o que pode levar a ambiguidades na chamada do m√©todo.
- ‚ùå **Usar varargs em m√©todos de desempenho cr√≠tico**, pois cada chamada cria um novo array, o que pode impactar a performance.
- ‚ùå **Passar arrays diretamente para m√©todos varargs** sem considerar que o array ser√° tratado como um √∫nico argumento, o que pode n√£o ser o comportamento desejado.

---

## üìå Dica Extra

Embora varargs sejam convenientes, em cen√°rios onde o n√∫mero de argumentos √© grande ou indeterminado, considerar o uso de cole√ß√µes como `List` pode ser mais apropriado, proporcionando maior controle e funcionalidade.

---

## ‚úÖ Conclus√£o

O uso de varargs em Java permite a cria√ß√£o de m√©todos mais flex√≠veis e leg√≠veis, capazes de lidar com um n√∫mero vari√°vel de argumentos. Compreender suas regras e melhores pr√°ticas √© essencial para evitar erros e garantir a efici√™ncia do c√≥digo.



[Voltar ao √çndice](#indice)

---


## <a name="parte54">54 - 053 - Orienta√ß√£o Objetos - M√©todos pt 10 - Exercise</a>

# Aula 53 ‚Äì Orienta√ß√£o a Objetos: M√©todos pt 10 - Exercise

üé• **V√≠deo:** [M√©todos pt 10 - Exercise](https://www.youtube.com/watch?v=F2Y867f1J8U&list=PL62G310vn6nFIsOCC0H-C2infYgwm8SWW&index=54)

## üéØ Objetivo da Aula

Fixar o conceito de **m√©todos** em Java atrav√©s de exerc√≠cios pr√°ticos de cria√ß√£o de classes, defini√ß√£o de m√©todos, passagem de par√¢metros e retorno de valores.

---

## üß† Conceitos Abordados

- Cria√ß√£o de m√©todos que recebem par√¢metros.
- M√©todos que retornam valores.
- Uso correto do `return`.
- Pr√°tica de boas pr√°ticas de escrita de m√©todos.
- Trabalho com encapsulamento e organiza√ß√£o do c√≥digo.

---

## üí° Exemplo B√°sico ‚Äì Exerc√≠cio de Soma

```java
public class Calculadora {
    public int somar(int a, int b) {
        return a + b;
    }
}

public class TesteCalculadora {
    public static void main(String[] args) {
        Calculadora calc = new Calculadora();
        int resultado = calc.somar(5, 3);
        System.out.println("Resultado: " + resultado);
    }
}
```

### Explica√ß√£o:
O m√©todo `somar` recebe dois inteiros como par√¢metros e retorna a soma deles.

---

## üí° Exemplo Intermedi√°rio ‚Äì Exerc√≠cio com Verifica√ß√£o

```java
public class Calculadora {
    public boolean ehPar(int numero) {
        return numero % 2 == 0;
    }
}

public class TesteCalculadora {
    public static void main(String[] args) {
        Calculadora calc = new Calculadora();
        boolean resultado = calc.ehPar(10);
        System.out.println("√â par? " + resultado);
    }
}
```

### Explica√ß√£o:
O m√©todo `ehPar` verifica se um n√∫mero √© par e retorna um valor booleano (`true` ou `false`).

---

## üí° Exemplo Avan√ßado ‚Äì Classe com M√∫ltiplos M√©todos

```java
public class CalculadoraAvancada {
    public int somar(int a, int b) {
        return a + b;
    }

    public int subtrair(int a, int b) {
        return a - b;
    }

    public int multiplicar(int a, int b) {
        return a * b;
    }

    public double dividir(int a, int b) {
        if (b == 0) {
            throw new IllegalArgumentException("Divisor n√£o pode ser zero.");
        }
        return (double) a / b;
    }
}

public class TesteCalculadoraAvancada {
    public static void main(String[] args) {
        CalculadoraAvancada calc = new CalculadoraAvancada();
        System.out.println("Soma: " + calc.somar(10, 5));
        System.out.println("Subtra√ß√£o: " + calc.subtrair(10, 5));
        System.out.println("Multiplica√ß√£o: " + calc.multiplicar(10, 5));
        System.out.println("Divis√£o: " + calc.dividir(10, 5));
    }
}
```

### Explica√ß√£o:
Aqui temos v√°rios m√©todos operando de formas diferentes dentro da mesma classe, cada um com sua responsabilidade bem definida.

---

## ‚úÖ Boas Pr√°ticas

- **Nomear m√©todos de forma clara e descritiva**, como `somar`, `subtrair`, `ehPar`.
- **Cada m√©todo deve ter uma √∫nica responsabilidade**, seguindo o princ√≠pio da responsabilidade √∫nica.
- **Validar dados de entrada** (ex: divis√£o por zero) para evitar erros de execu√ß√£o.
- **Separar l√≥gica de c√°lculo e exibi√ß√£o de dados**, ou seja, deixar o m√©todo apenas calcular e n√£o imprimir.
- **Adicionar coment√°rios em m√©todos mais complexos** para facilitar a manuten√ß√£o.

---

## ‚ùå Pr√°ticas a Evitar

- ‚ùå **M√©todos fazendo m√∫ltiplas tarefas**, como calcular e imprimir ao mesmo tempo.
- ‚ùå **Nomes de m√©todos gen√©ricos ou confusos**, como `doStuff` ou `process`.
- ‚ùå **Ignorar valida√ß√µes b√°sicas**, como n√£o tratar divis√µes por zero.
- ‚ùå **M√©todos muito longos**, que dificultam a leitura e manuten√ß√£o do c√≥digo.
- ‚ùå **Excesso de responsabilidade**: m√©todos que fazem diversas opera√ß√µes diferentes.

---

## üìå Dica Extra

Ao praticar a cria√ß√£o de m√©todos:
- **Teste seu m√©todo** em diferentes cen√°rios para garantir que funciona corretamente.
- **Pense na manuten√ß√£o**: algu√©m (ou at√© voc√™ mesmo) ter√° que entender esse c√≥digo no futuro.
- **Priorize legibilidade** sobre "economia" de linhas.

---

## ‚úÖ Conclus√£o

A pr√°tica com exerc√≠cios de m√©todos √© fundamental para entender n√£o apenas como criar fun√ß√µes, mas tamb√©m como estruturar melhor o c√≥digo, tornando-o mais reutiliz√°vel, test√°vel e limpo. M√©todos bem escritos s√£o a base de sistemas robustos e de f√°cil manuten√ß√£o.



[Voltar ao √çndice](#indice)

---


## <a name="parte55">55 - 054 - Orienta√ß√£o Objetos - Modificador de acesso private, get e set pt 01</a>

# Aula 54 ‚Äì Orienta√ß√£o a Objetos: Modificador de acesso private, get e set pt 01

üé• **V√≠deo:** [Modificador de acesso private, get e set pt 01](https://www.youtube.com/watch?v=QDzjgS0r39c&list=PL62G310vn6nFIsOCC0H-C2infYgwm8SWW&index=55)

## üéØ Objetivo da Aula

Introduzir o conceito de **modificadores de acesso** em Java, focando no uso do `private` para proteger atributos e no uso dos m√©todos **getters** e **setters** para acessar ou modificar esses atributos de forma controlada.

---

## üß† Conceitos Abordados

- **Modificador `private`**: torna o atributo ou m√©todo acess√≠vel apenas dentro da pr√≥pria classe.
- **Getter** (`get`): m√©todo p√∫blico para acessar o valor de um atributo privado.
- **Setter** (`set`): m√©todo p√∫blico para modificar o valor de um atributo privado.
- **Encapsulamento**: proteger o acesso direto aos dados da classe, mantendo o controle sobre eles.

---

## üí° Exemplo B√°sico ‚Äì Definindo Atributos Privados

```java
public class Pessoa {
    private String nome;
    private int idade;

    public String getNome() {
        return nome;
    }

    public void setNome(String nome) {
        this.nome = nome;
    }

    public int getIdade() {
        return idade;
    }

    public void setIdade(int idade) {
        if (idade >= 0) {
            this.idade = idade;
        }
    }
}

public class TestePessoa {
    public static void main(String[] args) {
        Pessoa pessoa = new Pessoa();
        pessoa.setNome("Maria");
        pessoa.setIdade(30);

        System.out.println("Nome: " + pessoa.getNome());
        System.out.println("Idade: " + pessoa.getIdade());
    }
}
```

### Explica√ß√£o:
- Atributos `nome` e `idade` s√£o `private`.
- M√©todos `getNome` e `setNome`, `getIdade` e `setIdade` permitem acesso controlado a esses atributos.
- No `setIdade`, existe uma **valida√ß√£o** para garantir que n√£o se atribua uma idade negativa.

---

## üí° Exemplo Complexo ‚Äì Valida√ß√£o mais sofisticada

```java
public class ContaBancaria {
    private double saldo;

    public double getSaldo() {
        return saldo;
    }

    public void depositar(double valor) {
        if (valor > 0) {
            saldo += valor;
        } else {
            System.out.println("Valor de dep√≥sito inv√°lido!");
        }
    }

    public void sacar(double valor) {
        if (valor > 0 && valor <= saldo) {
            saldo -= valor;
        } else {
            System.out.println("Saque inv√°lido!");
        }
    }
}

public class TesteConta {
    public static void main(String[] args) {
        ContaBancaria conta = new ContaBancaria();
        conta.depositar(500);
        conta.sacar(200);
        System.out.println("Saldo atual: R$ " + conta.getSaldo());
    }
}
```

### Explica√ß√£o:
- `saldo` √© protegido.
- M√©todos p√∫blicos controlam a altera√ß√£o do saldo (depositar e sacar) com **regras de neg√≥cio**.

---

## ‚úÖ Boas Pr√°ticas

- ‚úÖ Sempre use `private` para atributos, aplicando **encapsulamento**.
- ‚úÖ Crie **getters e setters** claros e objetivos para atributos que precisam ser acessados de fora da classe.
- ‚úÖ No **setter**, fa√ßa valida√ß√µes sempre que poss√≠vel para proteger os dados da classe.
- ‚úÖ Nomeie getters e setters seguindo o padr√£o: `getNomeAtributo()` e `setNomeAtributo()`.
- ‚úÖ Use m√©todos que garantam a consist√™ncia dos dados internos da classe.

---

## ‚ùå Pr√°ticas a Evitar

- ‚ùå Deixar atributos `public`, quebrando o encapsulamento.
- ‚ùå Criar getters e setters sem necessidade real para atributos que n√£o precisam ser expostos.
- ‚ùå N√£o validar entradas nos setters, permitindo estados inv√°lidos.
- ‚ùå Fazer l√≥gica complexa demais dentro de um getter ou setter ‚Äî eles devem ser simples.

---

## üìå Dica Extra

- Se voc√™ quiser criar getters e setters rapidamente no Eclipse ou IntelliJ, pode usar **atalhos autom√°ticos** como `Generate Getter and Setter`.
- Em projetos maiores, usar frameworks como **Lombok** pode ajudar a reduzir a verbosidade do c√≥digo com anota√ß√µes como `@Getter` e `@Setter`.

---

## ‚úÖ Conclus√£o

Entender e aplicar corretamente os modificadores de acesso, al√©m de criar getters e setters apropriados, √© um passo fundamental para escrever c√≥digos seguros, organizados e f√°ceis de manter em Java.


[Voltar ao √çndice](#indice)

---


## <a name="parte56">56 - 055 - Orienta√ß√£o Objetos - Modificador de acesso private, get e set pt 02</a>

# Aula 55 ‚Äì Orienta√ß√£o a Objetos: Modificador de acesso private, get e set pt 02

üé• **V√≠deo:** [Modificador de acesso private, get e set pt 02](https://www.youtube.com/watch?v=hJNlMh9ktQ4&list=PL62G310vn6nFIsOCC0H-C2infYgwm8SWW&index=56)

## üéØ Objetivo da Aula

Aprofundar o conceito de **encapsulamento** usando `private`, `getters` e `setters` em Java, demonstrando como aplicar essas pr√°ticas em uma estrutura de classes mais realista e com exemplos de controle de acesso e valida√ß√µes internas.

---

## üß† Conceitos Abordados

- **Refinamento de encapsulamento**: Prote√ß√£o total dos atributos sens√≠veis da classe.
- **Controle de entrada de dados**: Uso de valida√ß√µes nos setters.
- **Visibilidade seletiva**: Algumas informa√ß√µes podem ser apenas lidas (getter sem setter).
- **Design de API de classe**: Pensar quais atributos devem ser expostos e como.

---

## üí° Exemplo B√°sico ‚Äì Atributos com Getter e Setter

```java
public class Produto {
    private String nome;
    private double preco;

    public String getNome() {
        return nome;
    }

    public void setNome(String nome) {
        if (nome != null && !nome.isEmpty()) {
            this.nome = nome;
        }
    }

    public double getPreco() {
        return preco;
    }

    public void setPreco(double preco) {
        if (preco > 0) {
            this.preco = preco;
        }
    }
}

public class TesteProduto {
    public static void main(String[] args) {
        Produto produto = new Produto();
        produto.setNome("Notebook");
        produto.setPreco(3000);

        System.out.println("Produto: " + produto.getNome());
        System.out.println("Pre√ßo: R$" + produto.getPreco());
    }
}
```

### Explica√ß√£o:
- O atributo `nome` s√≥ √© alterado se n√£o for nulo ou vazio.
- O atributo `preco` s√≥ aceita valores positivos.

---

## üí° Exemplo Complexo ‚Äì Encapsulamento Avan√ßado

```java
public class Aluno {
    private String nome;
    private double[] notas;

    public Aluno(String nome, int quantidadeProvas) {
        this.nome = nome;
        this.notas = new double[quantidadeProvas];
    }

    public String getNome() {
        return nome;
    }

    public void setNota(int indice, double nota) {
        if (indice >= 0 && indice < notas.length && nota >= 0 && nota <= 10) {
            notas[indice] = nota;
        } else {
            System.out.println("Nota inv√°lida ou √≠ndice inv√°lido!");
        }
    }

    public double calcularMedia() {
        double total = 0;
        for (double nota : notas) {
            total += nota;
        }
        return total / notas.length;
    }
}

public class TesteAluno {
    public static void main(String[] args) {
        Aluno aluno = new Aluno("Carlos", 3);
        aluno.setNota(0, 8.5);
        aluno.setNota(1, 7.0);
        aluno.setNota(2, 9.0);

        System.out.println("M√©dia de " + aluno.getNome() + ": " + aluno.calcularMedia());
    }
}
```

### Explica√ß√£o:
- O acesso direto ao array de notas √© proibido.
- As notas s√£o controladas por m√©todos seguros que garantem valores v√°lidos.

---

## ‚úÖ Boas Pr√°ticas

- ‚úÖ Sempre encapsule atributos com `private`.
- ‚úÖ Crie **getters** e **setters** apenas quando realmente necess√°rios.
- ‚úÖ Adicione **valida√ß√£o** nos setters para garantir integridade dos dados.
- ‚úÖ Pense nas opera√ß√µes que a classe deve oferecer e crie m√©todos que fa√ßam sentido para a regra de neg√≥cio.
- ‚úÖ Proteja a l√≥gica interna da classe contra estados inv√°lidos.

---

## ‚ùå Pr√°ticas a Evitar

- ‚ùå Expor atributos diretamente com `public`.
- ‚ùå Permitir que atributos sejam modificados sem qualquer valida√ß√£o.
- ‚ùå Gerar m√©todos `get` e `set` autom√°ticos para todos os atributos sem necessidade (n√£o usar getters/setters indiscriminadamente).
- ‚ùå Deixar a l√≥gica de valida√ß√£o espalhada fora da classe.

---

## üìå Dica Extra

- Getter e Setter n√£o precisam ser obrigatoriamente criados para todos os atributos.
- Pense bem sobre a **responsabilidade da classe** e o que realmente precisa ser acessado ou modificado de fora.
- Getter ou Setter podem ser omitidos para refor√ßar o **princ√≠pio da imutabilidade** em certos casos.

---

## ‚úÖ Conclus√£o

Usar `private`, `getters` e `setters` da maneira correta promove seguran√ßa, organiza√ß√£o e robustez no seu c√≥digo. Al√©m disso, permite que as classes sejam usadas de maneira previs√≠vel e consistente.


[Voltar ao √çndice](#indice)

---


## <a name="parte57">57 - 056 - Orienta√ß√£o Objetos - Modificador de acesso private, get e set pt 03</a>

# Aula 56 ‚Äì Orienta√ß√£o a Objetos: Modificador de acesso private, get e set pt 03

üé• **V√≠deo:** [Modificador de acesso private, get e set pt 03](https://www.youtube.com/watch?v=kuvg8JixRp4&list=PL62G310vn6nFIsOCC0H-C2infYgwm8SWW&index=57)

## üéØ Objetivo da Aula

Finalizar o estudo sobre o uso do modificador de acesso `private`, `getters` e `setters`, refor√ßando a import√¢ncia do **encapsulamento** para proteger os dados e criar APIs de classes mais controladas e seguras.

---

## üß† Conceitos Abordados

- **Encapsulamento completo**: restringir o acesso direto aos atributos da classe.
- **Prote√ß√£o contra estados inv√°lidos**: validando altera√ß√µes dos atributos.
- **Getters e Setters customizados**: adaptando comportamento de leitura ou escrita dos dados.
- **Implementa√ß√£o de regras de neg√≥cio simples nos m√©todos de acesso**.

---

## üí° Exemplo B√°sico ‚Äì Valida√ß√£o no Setter

```java
public class ContaBancaria {
    private double saldo;

    public double getSaldo() {
        return saldo;
    }

    public void depositar(double valor) {
        if (valor > 0) {
            saldo += valor;
        }
    }

    public void sacar(double valor) {
        if (valor > 0 && saldo >= valor) {
            saldo -= valor;
        } else {
            System.out.println("Saque inv√°lido!");
        }
    }
}

public class TesteConta {
    public static void main(String[] args) {
        ContaBancaria conta = new ContaBancaria();
        conta.depositar(1000);
        conta.sacar(500);

        System.out.println("Saldo atual: R$" + conta.getSaldo());
    }
}
```

### Explica√ß√£o:
- O m√©todo `depositar` s√≥ permite valores positivos.
- O m√©todo `sacar` verifica se h√° saldo suficiente antes de sacar.
- O saldo nunca √© alterado diretamente, protegendo a integridade da conta.

---

## üí° Exemplo Complexo ‚Äì Setter Inteligente com Ajustes

```java
public class Produto {
    private String nome;
    private double preco;
    private double desconto; // Desconto em percentual

    public Produto(String nome, double preco) {
        this.nome = nome;
        setPreco(preco); // Aplica valida√ß√£o inicial
    }

    public String getNome() {
        return nome;
    }

    public double getPreco() {
        return preco - (preco * desconto / 100);
    }

    public void setPreco(double preco) {
        if (preco > 0) {
            this.preco = preco;
        }
    }

    public void aplicarDesconto(double desconto) {
        if (desconto >= 0 && desconto <= 50) {
            this.desconto = desconto;
        } else {
            System.out.println("Desconto inv√°lido! M√°ximo permitido: 50%");
        }
    }
}

public class TesteProduto {
    public static void main(String[] args) {
        Produto produto = new Produto("Smartphone", 2000);
        produto.aplicarDesconto(10);

        System.out.println("Pre√ßo com desconto: R$" + produto.getPreco());
    }
}
```

### Explica√ß√£o:
- O pre√ßo retornado j√° considera o desconto aplicado.
- A valida√ß√£o impede descontos abusivos (> 50%).

---

## ‚úÖ Boas Pr√°ticas

- ‚úÖ Sempre proteger atributos sens√≠veis com `private`.
- ‚úÖ Validar corretamente as altera√ß√µes dos atributos usando setters.
- ‚úÖ Utilizar getters para retornar informa√ß√µes tratadas, se necess√°rio.
- ‚úÖ Deixar a responsabilidade da integridade dos dados para dentro da classe.
- ‚úÖ Pensar nas **regras de neg√≥cio** enquanto desenha os m√©todos de acesso.

---

## ‚ùå Pr√°ticas a Evitar

- ‚ùå Deixar atributos p√∫blicos (`public`) sem necessidade.
- ‚ùå Aceitar valores inv√°lidos sem valida√ß√£o nos setters (ex: pre√ßo negativo, desconto acima do permitido).
- ‚ùå Escrever getters e setters desnecessariamente sem prop√≥sito claro.
- ‚ùå Permitir que objetos externos alterem o estado da classe diretamente.

---

## üìå Dica Extra

- Setter n√£o precisa ser obrigat√≥rio! Em casos onde o atributo √© **imut√°vel**, forne√ßa apenas o getter.
- Getters podem realizar c√°lculos simples ou ajustes antes de devolver o valor, tornando o acesso mais seguro e controlado.

---

## ‚úÖ Conclus√£o

Usar `private`, `getters` e `setters` de maneira adequada √© essencial para proteger os dados internos das classes e para construir programas robustos, seguros e f√°ceis de manter.


[Voltar ao √çndice](#indice)

---


## <a name="parte58">58 - 057 - Orienta√ß√£o Objetos - Sobrecarga de m√©todos</a>

# Aula 57 ‚Äì Orienta√ß√£o a Objetos: Sobrecarga de m√©todos

üé• **V√≠deo:** [Sobrecarga de m√©todos](https://www.youtube.com/watch?v=UNPh61FYFrA&list=PL62G310vn6nFIsOCC0H-C2infYgwm8SWW&index=58)

## üéØ Objetivo da Aula

Explicar o conceito de **Sobrecarga de M√©todos** (*Method Overloading*) em Java, mostrando como criar v√°rios m√©todos com o mesmo nome mas com **par√¢metros diferentes**.

---

## üß† Conceitos Abordados

- **Sobrecarga de m√©todos** √© quando dois ou mais m√©todos na mesma classe t√™m o **mesmo nome**, mas **assinaturas diferentes** (quantidade ou tipo de par√¢metros diferente).
- N√£o √© permitido diferenciar m√©todos apenas pelo **tipo de retorno**.
- Sobrecarga melhora a legibilidade e facilita o uso da classe, oferecendo m√∫ltiplas formas de executar uma opera√ß√£o.

---

## üí° Exemplo B√°sico ‚Äì Sobrecarga simples

```java
public class Calculadora {

    // M√©todo que soma dois inteiros
    int somar(int a, int b) {
        return a + b;
    }

    // M√©todo que soma tr√™s inteiros
    int somar(int a, int b, int c) {
        return a + b + c;
    }

    // M√©todo que soma dois n√∫meros double
    double somar(double a, double b) {
        return a + b;
    }
}

public class TesteCalculadora {
    public static void main(String[] args) {
        Calculadora calc = new Calculadora();
        
        System.out.println(calc.somar(2, 3));         // Chama somar(int, int)
        System.out.println(calc.somar(2, 3, 4));      // Chama somar(int, int, int)
        System.out.println(calc.somar(2.5, 3.5));     // Chama somar(double, double)
    }
}
```

---

## üí° Exemplo Complexo ‚Äì Sobrecarga aplicando tipos variados

```java
public class Impressora {

    void imprimir(String texto) {
        System.out.println("Texto: " + texto);
    }

    void imprimir(int numero) {
        System.out.println("N√∫mero inteiro: " + numero);
    }

    void imprimir(double numero) {
        System.out.println("N√∫mero decimal: " + numero);
    }

    void imprimir(boolean valor) {
        System.out.println("Valor booleano: " + valor);
    }
}

public class TesteImpressora {
    public static void main(String[] args) {
        Impressora impressora = new Impressora();
        
        impressora.imprimir("Ol√° Mundo!");
        impressora.imprimir(100);
        impressora.imprimir(45.67);
        impressora.imprimir(true);
    }
}
```

---

## ‚úÖ Boas Pr√°ticas

- ‚úÖ Criar sobrecargas quando realmente faz sentido sem√¢ntico: o m√©todo representa a **mesma a√ß√£o**, s√≥ que para dados diferentes.
- ‚úÖ Manter **nomes claros** e seguir o padr√£o de **mesmo nome** para refor√ßar a ideia de opera√ß√£o semelhante.
- ‚úÖ Manter a **consist√™ncia** no comportamento esperado dos m√©todos sobrecarregados.
- ‚úÖ Documentar diferen√ßas importantes entre vers√µes do m√©todo, caso necess√°rio.

---

## ‚ùå Pr√°ticas a Evitar

- ‚ùå Criar sobrecarga apenas para "encher c√≥digo" sem necessidade real.
- ‚ùå Diferenciar m√©todos apenas pelo **tipo de retorno** ‚Äî isso n√£o √© permitido em Java e causar√° erro de compila√ß√£o.
- ‚ùå Tornar m√©todos sobrecarregados muito diferentes entre si no comportamento ‚Äî isso confunde o usu√°rio da classe.
- ‚ùå Criar muitas vers√µes desnecess√°rias, poluindo a classe e dificultando a manuten√ß√£o.

---

## üìå Dica Extra

- A sobrecarga √© especialmente √∫til quando queremos **oferecer flexibilidade** sem obrigar o usu√°rio da classe a fornecer sempre todos os par√¢metros.
- M√©todos sobrecarregados podem tamb√©m **chamar uns aos outros** para evitar repeti√ß√£o de c√≥digo.

```java
void imprimir() {
    imprimir("Sem conte√∫do!");
}
```

---

## ‚úÖ Conclus√£o

Sobrecarga de m√©todos √© uma ferramenta poderosa da programa√ß√£o orientada a objetos em Java, ajudando a criar APIs mais intuitivas e f√°ceis de usar. Quando usada com responsabilidade, melhora muito a **legibilidade**, a **manuten√ß√£o** e a **efici√™ncia** do c√≥digo.


[Voltar ao √çndice](#indice)

---


## <a name="parte59">59 - 058 - Orienta√ß√£o Objetos - Construtores pt 01</a>

# Aula 58 ‚Äì Orienta√ß√£o a Objetos: Construtores pt 01

üé• **V√≠deo:** [Construtores pt 01](https://www.youtube.com/watch?v=zErSZzgYY_g&list=PL62G310vn6nFIsOCC0H-C2infYgwm8SWW&index=59)

## üéØ Objetivo da Aula

Explicar o conceito e a utiliza√ß√£o de **Construtores** em Java ‚Äî m√©todos especiais utilizados para inicializar objetos.

---

## üß† Conceitos Abordados

- **Construtor** √© um m√©todo especial chamado automaticamente quando criamos um objeto.
- Ele possui o **mesmo nome** da classe e **n√£o tem tipo de retorno** (nem `void`).
- Usamos construtores para definir valores iniciais dos atributos de um objeto.
- Se nenhum construtor for definido, o Java fornece um **construtor padr√£o** (sem par√¢metros).

---

## üí° Exemplo B√°sico ‚Äì Construtor sem par√¢metros

```java
public class Carro {
    String modelo;
    int ano;

    // Construtor padr√£o
    Carro() {
        modelo = "Modelo n√£o definido";
        ano = 2020;
    }
}

public class TesteCarro {
    public static void main(String[] args) {
        Carro carro1 = new Carro();
        System.out.println(carro1.modelo); // Modelo n√£o definido
        System.out.println(carro1.ano);    // 2020
    }
}
```

---

## üí° Exemplo Complexo ‚Äì Construtor com par√¢metros

```java
public class Carro {
    String modelo;
    int ano;

    // Construtor com par√¢metros
    Carro(String modelo, int ano) {
        this.modelo = modelo;
        this.ano = ano;
    }
}

public class TesteCarro {
    public static void main(String[] args) {
        Carro carro1 = new Carro("Civic", 2022);
        Carro carro2 = new Carro("Corolla", 2023);
        
        System.out.println(carro1.modelo + " - " + carro1.ano); // Civic - 2022
        System.out.println(carro2.modelo + " - " + carro2.ano); // Corolla - 2023
    }
}
```

---

## ‚úÖ Boas Pr√°ticas

- ‚úÖ Sempre inicializar os atributos importantes no construtor.
- ‚úÖ Usar **`this`** para deixar claro que voc√™ est√° se referindo ao atributo da inst√¢ncia.
- ‚úÖ Criar construtores que facilitem o uso correto do objeto (evitando objetos com estado inv√°lido).
- ‚úÖ Se poss√≠vel, fornecer tanto um **construtor padr√£o** quanto construtores com par√¢metros, para dar flexibilidade.
- ‚úÖ Documentar bem os construtores, especialmente quando houver v√°rios.

---

## ‚ùå Pr√°ticas a Evitar

- ‚ùå Criar muitos construtores sem necessidade, complicando o uso da classe.
- ‚ùå Inicializar valores incorretos ou inv√°lidos no construtor.
- ‚ùå Esquecer de usar `this` e acabar confundindo vari√°vel local com atributo de classe.
- ‚ùå Deixar atributos obrigat√≥rios sem inicializa√ß√£o, causando poss√≠veis `NullPointerException` mais tarde.

---

## üìå Dica Extra

- Voc√™ pode criar m√∫ltiplos construtores na mesma classe, variando o n√∫mero ou tipo de par√¢metros (**Sobrecarga de Construtores**).
- Sempre pense no **estado m√≠nimo v√°lido** que o objeto precisa ter para funcionar corretamente.

```java
Carro carroDefault = new Carro(); // Sem par√¢metros
Carro carroEspecifico = new Carro("Fiesta", 2021); // Com par√¢metros
```

---

## ‚úÖ Conclus√£o

Construtores tornam o processo de cria√ß√£o de objetos mais seguro e organizado, garantindo que os atributos essenciais sejam devidamente inicializados logo no nascimento do objeto.


[Voltar ao √çndice](#indice)

---


## <a name="parte60">60 - 059 - Orienta√ß√£o Objetos - Construtores pt 02 - Sobrecarga</a>

# Aula 59 ‚Äì Orienta√ß√£o a Objetos: Construtores pt 02 - Sobrecarga

üé• **V√≠deo:** [Construtores pt 02 - Sobrecarga](https://www.youtube.com/watch?v=rW11EAkxFnc&list=PL62G310vn6nFIsOCC0H-C2infYgwm8SWW&index=60)

## üéØ Objetivo da Aula

Apresentar o conceito de **sobrecarga de construtores** em Java: a capacidade de criar m√∫ltiplos construtores na mesma classe, variando a quantidade e tipos de par√¢metros.

---

## üß† Conceitos Abordados

- **Sobrecarga** significa ter **m√©todos** (ou **construtores**) com o **mesmo nome**, mas **diferentes listas de par√¢metros** (tipo, quantidade ou ordem).
- Em Java, √© poss√≠vel ter v√°rios construtores dentro da mesma classe para dar **flexibilidade** na cria√ß√£o dos objetos.
- Cada construtor pode inicializar o objeto de uma maneira diferente, dependendo dos dados fornecidos.

---

## üí° Exemplo B√°sico ‚Äì Sobrecarga de Construtores

```java
public class Carro {
    String modelo;
    int ano;

    // Construtor padr√£o
    Carro() {
        modelo = "Modelo padr√£o";
        ano = 2020;
    }

    // Construtor com 1 par√¢metro
    Carro(String modelo) {
        this.modelo = modelo;
        this.ano = 2020;
    }

    // Construtor com 2 par√¢metros
    Carro(String modelo, int ano) {
        this.modelo = modelo;
        this.ano = ano;
    }
}

public class TesteCarro {
    public static void main(String[] args) {
        Carro carro1 = new Carro();
        Carro carro2 = new Carro("Civic");
        Carro carro3 = new Carro("Corolla", 2023);

        System.out.println(carro1.modelo + " - " + carro1.ano); // Modelo padr√£o - 2020
        System.out.println(carro2.modelo + " - " + carro2.ano); // Civic - 2020
        System.out.println(carro3.modelo + " - " + carro3.ano); // Corolla - 2023
    }
}
```

---

## üí° Exemplo Complexo ‚Äì Usando Sobrecarga + Valida√ß√£o

```java
public class Produto {
    String nome;
    double preco;

    // Construtor padr√£o
    Produto() {
        this("Produto Gen√©rico", 0.0);
    }

    // Construtor com 1 par√¢metro
    Produto(String nome) {
        this(nome, 0.0);
    }

    // Construtor com 2 par√¢metros
    Produto(String nome, double preco) {
        this.nome = nome;
        if (preco >= 0) {
            this.preco = preco;
        } else {
            this.preco = 0.0;
        }
    }
}

public class TesteProduto {
    public static void main(String[] args) {
        Produto p1 = new Produto();
        Produto p2 = new Produto("Notebook");
        Produto p3 = new Produto("Celular", 2500.00);

        System.out.println(p1.nome + " - " + p1.preco);
        System.out.println(p2.nome + " - " + p2.preco);
        System.out.println(p3.nome + " - " + p3.preco);
    }
}
```

---

## ‚úÖ Boas Pr√°ticas

- ‚úÖ Usar a **chamada de construtores** dentro de outro construtor (`this(...)`) para **reutilizar** c√≥digo e evitar repeti√ß√£o.
- ‚úÖ Criar construtores sobrecarregados apenas se fizer sentido para diferentes formas de inicializar o objeto.
- ‚úÖ Manter a ordem l√≥gica dos par√¢metros para evitar confus√£o na cria√ß√£o dos objetos.
- ‚úÖ Usar valida√ß√µes dentro do construtor quando necess√°rio (ex: checar valores inv√°lidos).

---

## ‚ùå Pr√°ticas a Evitar

- ‚ùå Criar muitos construtores sem necessidade real, complicando o entendimento da classe.
- ‚ùå N√£o reutilizar c√≥digo, duplicando a l√≥gica de inicializa√ß√£o entre construtores.
- ‚ùå Deixar estados inconsistentes por meio de inicializa√ß√µes parciais incorretas.
- ‚ùå N√£o documentar a inten√ß√£o de cada construtor quando houver v√°rios.

---

## üìå Dica Extra

- √â uma pr√°tica recomendada criar **um construtor principal** (o mais completo) e fazer os outros construtores chamarem este utilizando `this(...)`.
- Exemplo:

```java
Produto() {
    this("Produto Gen√©rico", 0.0);
}

Produto(String nome) {
    this(nome, 0.0);
}

Produto(String nome, double preco) {
    this.nome = nome;
    this.preco = preco;
}
```

Assim o c√≥digo fica **organizado, limpo** e **f√°cil de manter**!

---

## ‚úÖ Conclus√£o

A **sobrecarga de construtores** torna a classe mais flex√≠vel e pr√°tica para diferentes cen√°rios de cria√ß√£o de objetos, desde que usada com responsabilidade e organiza√ß√£o.


[Voltar ao √çndice](#indice)

---


## <a name="parte61">61 - 060 - Orienta√ß√£o Objetos - Blocos de inicializa√ß√£o</a>

# Aula 60 ‚Äì Orienta√ß√£o a Objetos: Blocos de Inicializa√ß√£o

üé• **V√≠deo:** [Blocos de Inicializa√ß√£o](https://www.youtube.com/watch?v=HGB02nLvgKU&list=PL62G310vn6nFIsOCC0H-C2infYgwm8SWW&index=61)

## üéØ Objetivo da Aula

Entender o que s√£o **blocos de inicializa√ß√£o** em Java, como eles funcionam, quando s√£o executados e para que servem no ciclo de vida de um objeto.

---

## üß† Conceitos Abordados

- **Blocos de inicializa√ß√£o** s√£o usados para **executar c√≥digo** sempre que uma **inst√¢ncia da classe √© criada**.
- Existem dois tipos principais:
  - **Bloco de inicializa√ß√£o de inst√¢ncia** (`{}`): Executado toda vez que um objeto √© instanciado.
  - **Bloco de inicializa√ß√£o est√°tico** (`static {}`): Executado apenas **uma vez**, quando a classe √© carregada pela primeira vez.

---

## üí° Exemplo B√°sico ‚Äì Bloco de Inicializa√ß√£o de Inst√¢ncia

```java
public class Pessoa {
    String nome;
    int idade;

    {
        System.out.println("Bloco de inicializa√ß√£o chamado!");
        nome = "Nome padr√£o";
        idade = 18;
    }

    public Pessoa() {
        System.out.println("Construtor chamado!");
    }
}

public class TestePessoa {
    public static void main(String[] args) {
        Pessoa p1 = new Pessoa();
        Pessoa p2 = new Pessoa();
    }
}
```

**Sa√≠da:**
```
Bloco de inicializa√ß√£o chamado!
Construtor chamado!
Bloco de inicializa√ß√£o chamado!
Construtor chamado!
```

---

## üí° Exemplo Complexo ‚Äì Bloco Est√°tico + Bloco de Inst√¢ncia

```java
public class Carro {
    String modelo;
    static int totalDeCarros;

    static {
        System.out.println("Bloco est√°tico chamado!");
        totalDeCarros = 0;
    }

    {
        System.out.println("Bloco de inicializa√ß√£o chamado!");
        modelo = "Modelo gen√©rico";
        totalDeCarros++;
    }

    public Carro() {
        System.out.println("Construtor chamado!");
    }
}

public class TesteCarro {
    public static void main(String[] args) {
        Carro c1 = new Carro();
        Carro c2 = new Carro();
        System.out.println("Total de carros: " + Carro.totalDeCarros);
    }
}
```

**Sa√≠da:**
```
Bloco est√°tico chamado!
Bloco de inicializa√ß√£o chamado!
Construtor chamado!
Bloco de inicializa√ß√£o chamado!
Construtor chamado!
Total de carros: 2
```

---

## ‚úÖ Boas Pr√°ticas

- ‚úÖ Use blocos de inicializa√ß√£o para configurar **valores padr√£o** ou **l√≥gicas comuns** que n√£o dependem dos argumentos do construtor.
- ‚úÖ Em inicializa√ß√£o de vari√°veis est√°ticas importantes, utilize o **bloco est√°tico** para garantir consist√™ncia.
- ‚úÖ Deixe o c√≥digo dos blocos **simples e leg√≠vel** para evitar confus√£o.

---

## ‚ùå Pr√°ticas a Evitar

- ‚ùå Colocar **l√≥gica complexa** ou **processamentos pesados** nos blocos de inicializa√ß√£o ‚Äî isso dificulta a leitura e manuten√ß√£o.
- ‚ùå Abusar de blocos de inicializa√ß√£o ao inv√©s de usar **m√©todos pr√≥prios** ou **construtores** para l√≥gicas espec√≠ficas.
- ‚ùå N√£o misturar a responsabilidade de blocos com outras partes da classe (por exemplo, l√≥gica de neg√≥cio dentro de bloco de inicializa√ß√£o).

---

## üìå Dica Extra

- Se puder escolher, **prefira inicializar valores diretamente nos atributos** ou dentro do **construtor**. Use blocos de inicializa√ß√£o apenas para casos onde **m√∫ltiplos construtores** precisam de um comportamento comum.

Exemplo:
```java
private String nome = "Nome padr√£o";
```

ao inv√©s de:

```java
{
    nome = "Nome padr√£o";
}
```

---

## ‚úÖ Conclus√£o

Os **blocos de inicializa√ß√£o** s√£o ferramentas poderosas para configurar o estado de objetos e classes, mas devem ser usados com modera√ß√£o e clareza. Entender o **momento de execu√ß√£o** de cada tipo (est√°tico e de inst√¢ncia) √© fundamental para escrever c√≥digos mais organizados e previs√≠veis.


[Voltar ao √çndice](#indice)

---


## <a name="parte62">62 - 061 - Orienta√ß√£o Objetos - Modificador static</a>

# Aula 61 ‚Äì Orienta√ß√£o a Objetos: Modificador `static`

üé• **V√≠deo:** [Modificador static](https://www.youtube.com/watch?v=WBBbsEdzzmA&list=PL62G310vn6nFIsOCC0H-C2infYgwm8SWW&index=63)

## üéØ Objetivo da Aula

Entender como o **modificador `static`** funciona em Java, tanto para **atributos** quanto para **m√©todos**, e a diferen√ßa entre membros de inst√¢ncia e membros est√°ticos.

---

## üß† Conceitos Abordados

- **Atributos est√°ticos** (`static`) pertencem **√† classe** e **n√£o** a uma inst√¢ncia (objeto).
- **M√©todos est√°ticos** podem ser chamados **sem criar objetos** da classe.
- Utilizamos o `static` para **compartilhar** valores ou comportamentos comuns a **todas as inst√¢ncias**.

---

## üí° Exemplo B√°sico ‚Äì Atributo `static`

```java
public class Carro {
    String modelo;
    static int velocidadeMaxima = 240;
}

public class TesteCarro {
    public static void main(String[] args) {
        System.out.println("Velocidade m√°xima: " + Carro.velocidadeMaxima);
    }
}
```
> **Observa√ß√£o**: `velocidadeMaxima` pode ser acessado diretamente pelo nome da classe.

---

## üí° Exemplo Complexo ‚Äì M√©todo `static`

```java
public class Utilidade {
    public static int soma(int a, int b) {
        return a + b;
    }
}

public class TesteUtilidade {
    public static void main(String[] args) {
        int resultado = Utilidade.soma(10, 20);
        System.out.println("Resultado da soma: " + resultado);
    }
}
```
> **M√©todos est√°ticos** s√£o ideais para fun√ß√µes utilit√°rias que **n√£o dependem de estado** de inst√¢ncia.

---

## ‚úÖ Boas Pr√°ticas

- ‚úÖ Use `static` para **atributos ou m√©todos que s√£o iguais para todas as inst√¢ncias**.
- ‚úÖ M√©todos utilit√°rios que **n√£o precisam acessar atributos de inst√¢ncia** devem ser `static`.
- ‚úÖ Nomeie vari√°veis/m√©todos est√°ticos de forma clara para indicar seu **uso compartilhado**.

---

## ‚ùå Pr√°ticas a Evitar

- ‚ùå N√£o use `static` indiscriminadamente ‚Äî **nem tudo** precisa ser compartilhado entre inst√¢ncias.
- ‚ùå Evite acessar atributos de inst√¢ncia dentro de m√©todos `static` (n√£o √© permitido sem passar o objeto como refer√™ncia).
- ‚ùå N√£o misture l√≥gica de neg√≥cio com `static` sem necessidade ‚Äî **separa√ß√£o de responsabilidades** √© essencial.

---

## üìå Dica Extra

Se voc√™ usa muito `static` em m√©todos dentro de uma classe, talvez esteja **violando o princ√≠pio da orienta√ß√£o a objetos**. Pode ser um sinal de que esse c√≥digo deveria estar em uma **classe utilit√°ria** ou ser refatorado.

Exemplo de m√° pr√°tica:

```java
public class Pessoa {
    static String nome;
}
```
> Aqui, cada pessoa deveria ter um **nome diferente**, logo, **n√£o deveria ser est√°tico**.

---

## ‚úÖ Conclus√£o

O modificador `static` √© uma ferramenta poderosa em Java para compartilhamento de dados e m√©todos, mas deve ser usado com crit√©rio. Ele promove economia de mem√≥ria e facilita acesso a comportamentos comuns, por√©m, **um uso inadequado pode prejudicar a orienta√ß√£o a objetos**.



[Voltar ao √çndice](#indice)

---


## <a name="parte63">63 - 062 - Orienta√ß√£o Objetos - M√©todos est√°ticos</a>

# Aula 62 ‚Äì Orienta√ß√£o a Objetos: M√©todos Est√°ticos

üé• **V√≠deo:** [M√©todos est√°ticos](https://www.youtube.com/watch?v=jowlUssbJmk&list=PL62G310vn6nFIsOCC0H-C2infYgwm8SWW&index=64)

## üéØ Objetivo da Aula

Aprender a utilizar corretamente **m√©todos est√°ticos** (`static`) em Java, entender suas aplica√ß√µes pr√°ticas, vantagens, desvantagens e diferen√ßas em rela√ß√£o aos m√©todos de inst√¢ncia.

---

## üß† Conceitos Abordados

- M√©todos `static` pertencem **√† classe**, n√£o ao objeto.
- M√©todos `static` **n√£o podem acessar diretamente atributos de inst√¢ncia**.
- √öteis para opera√ß√µes que **n√£o dependem** do estado de um objeto.
- Normalmente usados em **classes utilit√°rias** (ex: `Math`, `Arrays`).

---

## üí° Exemplo B√°sico ‚Äì M√©todo Est√°tico

```java
public class Calculadora {
    public static int somar(int a, int b) {
        return a + b;
    }
}

public class TesteCalculadora {
    public static void main(String[] args) {
        int resultado = Calculadora.somar(5, 10);
        System.out.println("Resultado da soma: " + resultado);
    }
}
```
> Aqui, n√£o √© necess√°rio criar uma inst√¢ncia de `Calculadora` para usar o m√©todo `somar`.

---

## üí° Exemplo Complexo ‚Äì M√©todos Est√°ticos em Classe Utilit√°ria

```java
public class Conversor {
    public static double celsiusParaFahrenheit(double celsius) {
        return (celsius * 1.8) + 32;
    }

    public static double fahrenheitParaCelsius(double fahrenheit) {
        return (fahrenheit - 32) / 1.8;
    }
}

public class TesteConversor {
    public static void main(String[] args) {
        double tempF = Conversor.celsiusParaFahrenheit(25);
        double tempC = Conversor.fahrenheitParaCelsius(77);

        System.out.println("25¬∞C em Fahrenheit: " + tempF);
        System.out.println("77¬∞F em Celsius: " + tempC);
    }
}
```
> Exemplo cl√°ssico de m√©todos utilit√°rios que fazem convers√£o de valores.

---

## ‚úÖ Boas Pr√°ticas

- ‚úÖ Use `static` para m√©todos que **n√£o precisam acessar ou modificar atributos de inst√¢ncia**.
- ‚úÖ Centralize m√©todos `static` em **classes utilit√°rias** espec√≠ficas (como `Conversor`, `Calculadora`).
- ‚úÖ Documente bem o comportamento dos m√©todos `static`, pois eles podem ser usados **fora do contexto** de objetos.
- ‚úÖ Nomeie as fun√ß√µes de maneira clara e objetiva.

---

## ‚ùå Pr√°ticas a Evitar

- ‚ùå N√£o use `static` em m√©todos que **precisem acessar atributos de inst√¢ncia**.
- ‚ùå Evite misturar m√©todos `static` com l√≥gicas que deveriam ser orientadas a objetos.
- ‚ùå N√£o exagere no uso de `static`, sen√£o sua aplica√ß√£o pode se tornar procedural (perdendo os benef√≠cios da OOP).
- ‚ùå Evite criar depend√™ncia entre m√©todos `static` e estados internos de objetos.

---

## üìå Dica Extra

Se voc√™ precisar de **polimorfismo** (sobrescrever m√©todos em subclasses), **n√£o use `static`**! M√©todos est√°ticos **n√£o s√£o polim√≥rficos** em Java.

---

## ‚úÖ Conclus√£o

M√©todos `static` s√£o essenciais para construir fun√ß√µes independentes do estado de objetos, ideais para opera√ß√µes gen√©ricas, c√°lculos e utilidades. Contudo, o excesso de m√©todos `static` pode prejudicar a boa modelagem orientada a objetos. Use com consci√™ncia!


[Voltar ao √çndice](#indice)

---


## <a name="parte64">64 - 063 - Orienta√ß√£o Objetos - Bloco de inicializa√ß√£o est√°tico</a>

# Bloco de Inicializa√ß√£o Est√°tico em Java

Este documento resume os principais conceitos abordados na videoaula **"63 - Orienta√ß√£o a Objetos - Bloco de Inicializa√ß√£o Est√°tico"** do curso de Java, dispon√≠vel em: [https://www.youtube.com/watch?v=4YE1ewRK-rk](https://www.youtube.com/watch?v=4YE1ewRK-rk).

---

## üìò O que √© um Bloco de Inicializa√ß√£o Est√°tico?

Em Java, um **bloco de inicializa√ß√£o est√°tico** √© um bloco de c√≥digo precedido pela palavra-chave `static`, que √© executado **uma √∫nica vez**, no momento em que a classe √© carregada pela JVM (Java Virtual Machine). ([Static vs. Instance Initializer Block in Java | Baeldung](https://www.baeldung.com/java-static-instance-initializer-blocks?utm_source=chatgpt.com))

√â utilizado para inicializar vari√°veis est√°ticas ou executar opera√ß√µes que precisam ocorrer apenas uma vez, independentemente de quantas inst√¢ncias da classe sejam criadas.

---

## üß™ Exemplos Pr√°ticos

### Exemplo B√°sico

```java
public class ExemploBasico {
    static int contador;

    static {
        contador = 100;
        System.out.println("Bloco est√°tico executado. Contador inicializado com " + contador);
    }

    public static void main(String[] args) {
        System.out.println("Valor do contador: " + contador);
    }
}
```

**Sa√≠da:**
```
Bloco est√°tico executado. Contador inicializado com 100
Valor do contador: 100
```


Neste exemplo, o bloco est√°tico √© executado antes do m√©todo `main`, inicializando a vari√°vel `contador`. ([static block in java- Scaler Topics](https://www.scaler.com/topics/static-block-in-java/?utm_source=chatgpt.com))

---

### Exemplo Avan√ßado

```java
public class Configuracao {
    static Properties propriedades;

    static {
        propriedades = new Properties();
        try (InputStream input = new FileInputStream("config.properties")) {
            propriedades.load(input);
            System.out.println("Configura√ß√µes carregadas com sucesso.");
        } catch (IOException e) {
            System.err.println("Erro ao carregar configura√ß√µes: " + e.getMessage());
        }
    }

    public static String getPropriedade(String chave) {
        return propriedades.getProperty(chave);
    }
}
```


Neste exemplo, o bloco est√°tico √© utilizado para carregar configura√ß√µes de um arquivo externo no momento em que a classe `Configuracao` √© carregada.

---

## ‚úÖ Boas Pr√°ticas

- **Inicializa√ß√µes Simples:** Utilize blocos est√°ticos para inicializa√ß√µes simples e r√°pidas, como configura√ß√£o de constantes ou carregamento de recursos essenciais.

- **Tratamento de Exce√ß√µes:** Sempre trate poss√≠veis exce√ß√µes dentro do bloco est√°tico para evitar falhas na inicializa√ß√£o da classe.

- **Ordem de Execu√ß√£o:** Se houver m√∫ltiplos blocos est√°ticos, eles ser√£o executados na ordem em que aparecem no c√≥digo.

---

## ‚ùå M√°s Pr√°ticas

- **Opera√ß√µes Pesadas:** Evite executar opera√ß√µes demoradas ou complexas dentro de blocos est√°ticos, pois isso pode impactar negativamente o tempo de carregamento da classe.

- **Depend√™ncias Externas:** Minimize depend√™ncias de recursos externos que podem n√£o estar dispon√≠veis no momento da inicializa√ß√£o.

- **Modifica√ß√µes Posteriores:** N√£o utilize blocos est√°ticos para modificar o estado de objetos que ainda n√£o foram inicializados.

---

## üß† Conclus√£o

Blocos de inicializa√ß√£o est√°ticos s√£o uma ferramenta poderosa em Java para configurar o ambiente de uma classe antes de sua utiliza√ß√£o. Quando usados com cautela e seguindo as boas pr√°ticas, podem tornar o c√≥digo mais eficiente e organizado.

---

*Refer√™ncias:*

- [Static Blocks in Java - GeeksforGeeks](https://www.geeksforgeeks.org/static-blocks-in-java/)

- [Static vs. Instance Initializer Block in Java | Baeldung](https://www.baeldung.com/java-static-instance-initializer-blocks)

- [Essential Techniques for Optimizing Your Java Code with Static Blocks](https://medium.com/@tuananhbk1996/essential-techniques-for-optimizing-your-java-code-with-static-blocks-3a478f66a08d)



[Voltar ao √çndice](#indice)

---


## <a name="parte65">65 - 064 - Orienta√ß√£o Objetos - Associa√ß√£o pt 01 - Arrays com Objetos</a>


## Conceito Principal
- **Associa√ß√£o**: Relacionamento entre objetos onde um objeto usa outro para realizar alguma opera√ß√£o.
- **Arrays com Objetos**: Permitem armazenar m√∫ltiplas inst√¢ncias de objetos em uma estrutura de dados linear.

---

## Exemplos B√°sicos

### 1. Classe `Aluno` (Objeto Associado)
```java
public class Aluno {
    private String nome;
    private int idade;

    // Construtor
    public Aluno(String nome, int idade) {
        this.nome = nome;
        this.idade = idade;
    }

    // Getters (boas pr√°ticas)
    public String getNome() { return nome; }
    public int getIdade() { return idade; }
}
```

### 2. Classe `Sala` (Usando Array de Objetos)
```java
public class Sala {
    private Aluno[] alunos; // Associa√ß√£o via array

    public Sala(int capacidade) {
        alunos = new Aluno[capacidade];
    }

    public void adicionarAluno(Aluno aluno, int indice) {
        alunos[indice] = aluno;
    }

    public void listarAlunos() {
        for (Aluno aluno : alunos) {
            if (aluno != null) {
                System.out.println(aluno.getNome());
            }
        }
    }
}
```

---

## Exemplo Complexo (Com Valida√ß√µes)
```java
public class Escola {
    private Sala[] salas;
    private int totalSalas;

    public Escola(int maxSalas) {
        salas = new Sala[maxSalas];
    }

    public void adicionarSala(Sala sala) {
        if (totalSalas < salas.length) {
            salas[totalSalas++] = sala;
        } else {
            System.out.println("Capacidade m√°xima de salas atingida!");
        }
    }

    public void mostrarAlunosPorSala() {
        for (int i = 0; i < totalSalas; i++) {
            System.out.println("Sala " + (i + 1) + ":");
            salas[i].listarAlunos();
        }
    }
}
```

---

## Melhores Pr√°ticas ‚úÖ

1. **Encapsulamento**:
    - Sempre usar `private` para atributos e fornecer getters/setters quando necess√°rio.
    - Exemplo: `alunos` na classe `Sala` √© privado.

2. **Inicializa√ß√£o Segura**:
    - Verificar limites do array antes de inserir (`if (indice >= 0 && indice < alunos.length)`).

3. **Nomenclatura Clara**:
    - Nomes descritivos como `listarAlunos()` em vez de `printAll()`.

4. **Tratamento de Nulos**:
    - Verificar `if (aluno != null)` ao iterar em arrays.

5. **Flexibilidade**:
    - Usar cole√ß√µes din√¢micas (`ArrayList`) em vez de arrays fixos quando poss√≠vel (t√≥pico avan√ßado).

---

## Pr√°ticas a Evitar ‚ùå

1. **Acesso Direto a Atributos**:
   ```java
   // Ruim
   sala.alunos[0] = new Aluno("Nome", 20);

   // Bom
   sala.adicionarAluno(new Aluno("Nome", 20), 0);
   ```

2. **Tamanho Fixo sem Valida√ß√£o**:
    - N√£o verificar limites do array causa `ArrayIndexOutOfBoundsException`.

3. **Ignorar Nulos**:
    - Iterar arrays sem verificar nulos pode gerar `NullPointerException`.

4. **Acoplamento Direto**:
    - Expor o array interno (ex: m√©todo `getAlunos()` que retorna o array) permite modifica√ß√µes inseguras.

5. **M√©todos Longos**:
    - Evitar l√≥gica complexa diretamente nos m√©todos de associa√ß√£o (ex: valida√ß√µes deveriam estar em classes separadas).

---

## Observa√ß√µes da Aula
- Arrays de objetos s√£o a forma mais simples de associa√ß√£o 1:N (um para muitos).
- Em aplica√ß√µes reais, preferir cole√ß√µes como `ArrayList` (ser√° visto em aulas futuras).
- A associa√ß√£o permite modelar rela√ß√µes do mundo real (ex: Escola ‚Üí Salas ‚Üí Alunos).

### Link da Aula
[Assista aqui](https://www.youtube.com/watch?v=HOjV9M6pRQQ&list=PL62G310vn6nFIsOCC0H-C2infYgwm8SWW&index=66)

---


[Voltar ao √çndice](#indice)

---


## <a name="parte66">66 - 065 - Orienta√ß√£o Objetos - Associa√ß√£o pt 02 - Associa√ß√£o unidirecional um para muitos</a>

# Resumo da Aula: Associa√ß√£o Unidirecional Um para Muitos

## Conceito Principal
**Associa√ß√£o Unidirecional 1:N**: Um objeto de uma classe cont√©m/referencia m√∫ltiplos objetos de outra classe, sem que o inverso seja verdadeiro. A rela√ß√£o existe apenas em uma dire√ß√£o.

---

## Exemplo B√°sico: Professor ‚Üí Alunos

### Classe `Aluno` (Classe Independente)
```java
public class Aluno {
    private String nome;
    
    public Aluno(String nome) {
        this.nome = nome;
    }
    
    public String getNome() {
        return nome;
    }
}
```

### Classe `Professor` (Classe Dono da Associa√ß√£o)
```java
public class Professor {
    private String nome;
    private List<Aluno> alunos; // Associa√ß√£o 1 para muitos

    public Professor(String nome) {
        this.nome = nome;
        this.alunos = new ArrayList<>(); // Boa pr√°tica: inicializar a cole√ß√£o
    }

    public void adicionarAluno(Aluno aluno) {
        alunos.add(aluno);
    }

    public void listarAlunos() {
        System.out.println("Alunos do professor " + nome + ":");
        for (Aluno aluno : alunos) {
            System.out.println("- " + aluno.getNome());
        }
    }
}
```

---

## Exemplo Complexo: Departamento ‚Üí Professores ‚Üí Alunos

### Classe `Departamento`
```java
public class Departamento {
    private String nome;
    private List<Professor> professores;

    public Departamento(String nome) {
        this.nome = nome;
        this.professores = new ArrayList<>();
    }

    public void adicionarProfessor(Professor professor) {
        professores.add(professor);
    }

    public void relatorio() {
        System.out.println("Departamento: " + nome);
        System.out.println("Total professores: " + professores.size());
        System.out.println("--- Rela√ß√£o Professores/Alunos ---");
        
        for (Professor prof : professores) {
            prof.listarAlunos();
            System.out.println();
        }
    }
}
```

---

## Melhores Pr√°ticas ‚úÖ

1. **Uso de Collections**:
    - Prefira `List`/`ArrayList` em vez de arrays para flexibilidade (tamanho din√¢mico).

2. **Encapsulamento Rigoroso**:
    - M√©todos modificadores (`adicionarAluno()`) devem ser o √∫nico meio de alterar a associa√ß√£o.

3. **Inicializa√ß√£o no Construtor**:
    - Sempre inicializar cole√ß√µes no construtor para evitar `NullPointerException`.

4. **Navega√ß√£o Unidirecional**:
    - Mantenha a rela√ß√£o em uma s√≥ dire√ß√£o (ex: Professor conhece Alunos, mas Aluno N√ÉO conhece Professor).

5. **Imutabilidade Parcial**:
    - Para atributos b√°sicos como `nome`, considere `final` se n√£o precisarem ser alterados.

---

## Pr√°ticas a Evitar ‚ùå

1. **Expor Cole√ß√µes Internas**:
   ```java
   // RUIM (permite modifica√ß√£o externa incontrolada)
   public List<Aluno> getAlunos() {
       return alunos;
   }

   // ACEIT√ÅVEL (c√≥pia defensiva)
   public List<Aluno> getAlunos() {
       return new ArrayList<>(alunos);
   }
   ```

2. **Bidirecionalidade Acidental**:
    - Evite adicionar refer√™ncia ao Professor na classe Aluno (isso mudaria para bidirecional).

3. **Valida√ß√µes Ausentes**:
    - N√£o verificar `null` em m√©todos como `adicionarAluno(Aluno aluno)`.

4. **M√©todos "Gigantes"**:
    - Evite l√≥gica complexa nas classes de associa√ß√£o (ex: regras de neg√≥cio devem ficar em servi√ßos).

5. **Acoplamento Circular**:
    - N√£o fazer Departamentos conhecerem Alunos diretamente (deve ser via Professores).

---

## Exemplo Completo em Execu√ß√£o

```java
public class Main {
    public static void main(String[] args) {
        // Criando alunos
        Aluno a1 = new Aluno("Ana");
        Aluno a2 = new Aluno("Lucas");
        Aluno a3 = new Aluno("Carlos");

        // Criando professor e associando alunos
        Professor p1 = new Professor("Dr. Silva");
        p1.adicionarAluno(a1);
        p1.adicionarAluno(a2);

        Professor p2 = new Professor("Dra. Santos");
        p2.adicionarAluno(a3);

        // Criando departamento
        Departamento departamento = new Departamento("Ci√™ncia da Computa√ß√£o");
        departamento.adicionarProfessor(p1);
        departamento.adicionarProfessor(p2);

        // Gerando relat√≥rio
        departamento.relatorio();
    }
}
```

### Sa√≠da Esperada:
```
Departamento: Ci√™ncia da Computa√ß√£o
Total professores: 2
--- Rela√ß√£o Professores/Alunos ---
Alunos do professor Dr. Silva:
- Ana
- Lucas

Alunos do professor Dra. Santos:
- Carlos
```

---

## Diferen√ßa Chave para Aula Anterior
- Na associa√ß√£o com arrays (aula 64), o relacionamento era est√°tico (tamanho fixo).
- Nesta aula (65), usando `List`, o relacionamento √© din√¢mico e mais aderente a cen√°rios reais.

**Link da Aula**: [Assista aqui](https://www.youtube.com/watch?v=LFlZcO9qAh8&list=PL62G310vn6nFIsOCC0H-C2infYgwm8SWW&index=67)



[Voltar ao √çndice](#indice)

---


## <a name="parte67">67 - 066 - Orienta√ß√£o Objetos - Associa√ß√£o pt 03 - Associa√ß√£o unidirecional muitos para um</a>

# Resumo da Aula: Associa√ß√£o Unidirecional Muitos para Um (N:1)

## Conceito Principal
**Associa√ß√£o Unidirecional N:1**: M√∫ltiplos objetos de uma classe referenciam um √∫nico objeto de outra classe, sem que o inverso seja verdadeiro. Diferente da aula anterior (1:N), agora a "seta" aponta no sentido inverso.

---

## Exemplo B√°sico: Alunos ‚Üí Escola

### Classe `Escola` (Classe Alvo)
```java
public class Escola {
    private String nome;
    
    public Escola(String nome) {
        this.nome = nome;
    }
    
    public String getNome() {
        return nome;
    }
}
```

### Classe `Aluno` (Classe que Referencia)
```java
public class Aluno {
    private String nome;
    private Escola escola; // Associa√ß√£o muitos-para-um

    public Aluno(String nome, Escola escola) {
        this.nome = nome;
        this.escola = escola;
    }

    public void imprimirDados() {
        System.out.println(nome + " estuda na " + escola.getNome());
    }
}
```

---

## Exemplo Complexo: Funcion√°rios ‚Üí Departamento ‚Üí Empresa

### Classe `Empresa`
```java
public class Empresa {
    private String nome;
    
    public Empresa(String nome) {
        this.nome = nome;
    }
    
    public String getNome() {
        return nome;
    }
}
```

### Classe `Departamento`
```java
public class Departamento {
    private String nome;
    private Empresa empresa; // Associa√ß√£o N:1

    public Departamento(String nome, Empresa empresa) {
        this.nome = nome;
        this.empresa = empresa;
    }

    public void relatorio() {
        System.out.println(nome + " pertence √† " + empresa.getNome());
    }
}
```

### Classe `Funcionario`
```java
public class Funcionario {
    private String nome;
    private Departamento departamento; // Associa√ß√£o N:1

    public Funcionario(String nome, Departamento departamento) {
        this.nome = nome;
        this.departamento = departamento;
    }

    public void mostrarVinculo() {
        System.out.printf("%s trabalha no %s na empresa %s\n",
            nome,
            departamento.getNome(),
            departamento.getEmpresa().getNome());
    }
}
```

---

## Melhores Pr√°ticas ‚úÖ

1. **Constru√ß√£o Segura**:
    - Exigir o objeto obrigat√≥rio no construtor:
      ```java
      public Aluno(String nome, Escola escola) {
          Objects.requireNonNull(escola); // Valida√ß√£o importante
          this.escola = escola;
      }
      ```

2. **Navega√ß√£o Encadeada**:
    - Permite acessar informa√ß√µes hier√°rquicas:
      ```java
      funcionario.getDepartamento().getEmpresa().getNome();
      ```

3. **Imutabilidade das Refer√™ncias**:
    - Considere `final` para refer√™ncias que n√£o devem mudar:
      ```java
      private final Escola escola;
      ```

4. **Separa√ß√£o de Responsabilidades**:
    - A classe `Funcionario` n√£o deve conhecer diretamente `Empresa`, apenas `Departamento`.

5. **Uso de Interfaces**:
    - Se aplic√°vel, usar interfaces para reduzir acoplamento:
      ```java
      private IEmpresa empresa;
      ```

---

## Pr√°ticas a Evitar ‚ùå

1. **Refer√™ncias Nulas sem Valida√ß√£o**:
   ```java
   // RUIM
   public void setEscola(Escola escola) {
       this.escola = escola; // Pode ser null
   }
   ```

2. **Bidirecionalidade Acidental**:
    - Evite adicionar `List<Aluno>` na classe `Escola` (transformaria em bidirecional).

3. **Exposi√ß√£o de Objetos Internos**:
   ```java
   // PERIGOSO (permite modificar o estado interno)
   public Escola getEscola() {
       return escola;
   }
   
   // MELHOR (retornar c√≥pia ou imut√°vel)
   public Escola getEscola() {
       return new Escola(escola.getNome());
   }
   ```

4. **Hierarquias Muito Profundas**:
    - Evite cadeias muito longas (`funcionario.getDepartamento().getEmpresa().getGrupo().getPais()`).

5. **L√≥gica Complexa nos Getters**:
    - N√£o adicione valida√ß√µes/computa√ß√£o pesada em m√©todos de acesso.

---

## Exemplo Completo em Execu√ß√£o

```java
public class Main {
    public static void main(String[] args) {
        // Exemplo B√°sico
        Escola escola1 = new Escola("Escola Municipal");
        Aluno aluno1 = new Aluno("Jo√£o", escola1);
        Aluno aluno2 = new Aluno("Maria", escola1);
        aluno1.imprimirDados();
        aluno2.imprimirDados();

        // Exemplo Complexo
        Empresa empresaX = new Empresa("Tech Solutions");
        Departamento rh = new Departamento("RH", empresaX);
        Departamento ti = new Departamento("TI", empresaX);
        
        Funcionario f1 = new Funcionario("Carlos", ti);
        Funcionario f2 = new Funcionario("Ana", rh);
        
        f1.mostrarVinculo();
        f2.mostrarVinculo();
        ti.relatorio();
    }
}
```

### Sa√≠da Esperada:
```
Jo√£o estuda na Escola Municipal
Maria estuda na Escola Municipal
Carlos trabalha no TI na empresa Tech Solutions
Ana trabalha no RH na empresa Tech Solutions
TI pertence √† Tech Solutions
```

---

## Compara√ß√£o com Padr√µes Anteriores
| Aula 65 (1:N)            | Aula 66 (N:1)            |
|--------------------------|--------------------------|
| Professor tem muitos Alunos | Muitos Alunos t√™m uma Escola |
| Dono da rela√ß√£o guarda cole√ß√£o | Dono √© referenciado por muitos |
| `List<Aluno>` no Professor | `Escola` no Aluno |

**Link da Aula**: [Assista aqui](https://www.youtube.com/watch?v=idIGsMoxfO0&list=PL62G310vn6nFIsOCC0H-C2infYgwm8SWW&index=68)

Este resumo mostra a invers√£o de perspectiva em rela√ß√£o √† aula anterior, mantendo o foco no baixo acoplamento e alta coes√£o. O exemplo complexo demonstra como construir hierarquias de objetos de forma limpa e escal√°vel.

[Voltar ao √çndice](#indice)

---


## <a name="parte68">68 - 067 - Orienta√ß√£o Objetos - Associa√ß√£o pt 04 - Associa√ß√£o bidirecional</a>

# Resumo da Aula: Associa√ß√£o Bidirecional em Java

## Conceito Principal
**Associa√ß√£o Bidirecional**: Rela√ß√£o onde duas classes se referenciam mutuamente, exigindo sincroniza√ß√£o cuidadosa para manter a consist√™ncia dos dados.

---

## Exemplo B√°sico: Aluno ‚Üî Turma (1:N)

### Classe `Aluno` (Implementa√ß√£o Corrigida)
```java
public class Aluno {
    private final String nome;
    private Turma turma;

    public Aluno(String nome) {
        this.nome = nome;
    }

    public void entrarNaTurma(Turma novaTurma) {
        if (this.turma == novaTurma) return;
        
        if (this.turma != null) {
            this.turma.getAlunos().remove(this);
        }
        
        this.turma = novaTurma;
        
        if (novaTurma != null && !novaTurma.getAlunos().contains(this)) {
            novaTurma.getAlunos().add(this);
        }
    }

    public void mostrarSituacao() {
        System.out.println(nome + " - Turma: " + (turma != null ? turma.getNome() : "Sem turma"));
    }
}
```

### Classe `Turma` (Implementa√ß√£o Corrigida)
```java
public class Turma {
    private final String nome;
    private final List<Aluno> alunos = new ArrayList<>();

    public Turma(String nome) {
        this.nome = nome;
    }

    public void adicionarAluno(Aluno aluno) {
        if (aluno == null || alunos.contains(aluno)) return;
        
        alunos.add(aluno);
        if (aluno.getTurma() != this) {
            aluno.entrarNaTurma(this);
        }
    }

    public void listarAlunos() {
        System.out.println("Alunos da " + nome + ":");
        alunos.forEach(Aluno::mostrarSituacao);
    }
}
```

---

## Exemplo Complexo: Departamento ‚Üî Professor ‚Üî Aluno

### Classe `Departamento`
```java
public class Departamento {
    private String nome;
    private List<Professor> professores = new ArrayList<>();

    public void adicionarProfessor(Professor prof) {
        if (!professores.contains(prof)) {
            professores.add(prof);
            if (prof.getDepartamento() != this) {
                prof.setDepartamento(this);
            }
        }
    }
}
```

### Classe `Professor`
```java
public class Professor {
    private String nome;
    private Departamento departamento;
    private List<Aluno> orientandos = new ArrayList<>();

    public void setDepartamento(Departamento depto) {
        if (this.departamento != depto) {
            this.departamento = depto;
            depto.adicionarProfessor(this);
        }
    }
}
```

---

## Melhores Pr√°ticas ‚úÖ

1. **Controle de Duplica√ß√£o**:
    - Use `contains()` antes de adicionar a cole√ß√µes
    - Exemplo: `if (!alunos.contains(aluno)) alunos.add(aluno);`

2. **Sincroniza√ß√£o Bidirecional**:
    - Sempre atualize ambos os lados da rela√ß√£o
    - Verifique `if (aluno.getTurma() != this)` antes de atualizar

3. **Imutabilidade**:
    - Atributos b√°sicos como `nome` devem ser `final`

4. **Null Safety**:
    - Sempre verifique `if (aluno != null)`

5. **Encapsulamento**:
    - Use `Collections.unmodifiableList()` para retornar cole√ß√µes:
   ```java
   public List<Aluno> getAlunos() {
       return Collections.unmodifiableList(alunos);
   }
   ```

---

## Pr√°ticas a Evitar ‚ùå

1. **Exposi√ß√£o Direta de Cole√ß√µes**:
   ```java
   // RUIM
   public List<Aluno> getAlunos() { return alunos; }
   ```

2. **Atualiza√ß√£o Incompleta**:
   ```java
   // PERIGOSO (atualiza s√≥ um lado)
   public void setTurma(Turma turma) { this.turma = turma; }
   ```

3. **Loops Infinitos**:
    - N√£o verificar a rela√ß√£o existente antes de atualizar

4. **Bidirecionalidade Desnecess√°ria**:
    - Implemente apenas quando essencial para o dom√≠nio

---

## Exemplo Completo Funcional

```java
public class Main {
    public static void main(String[] args) {
        Turma turmaPOO = new Turma("POO-2023");
        Aluno aluno1 = new Aluno("Maria");
        Aluno aluno2 = new Aluno("Jo√£o");

        // Associa√ß√£o correta sem duplica√ß√£o
        turmaPOO.adicionarAluno(aluno1);
        aluno2.entrarNaTurma(turmaPOO);

        // Verifica√ß√£o
        turmaPOO.listarAlunos();
    }
}
```

### Sa√≠da Correta:
```
Alunos da POO-2023:
Maria - Turma: POO-2023
Jo√£o - Turma: POO-2023
```

---

## Solu√ß√£o para Problemas Comuns

1. **Duplica√ß√£o em Listas**:
    - Use `contains()` antes de `add()`
    - Considere `Set` se permitido (embora este exemplo use `ArrayList`)

2. **Refer√™ncias Circulares**:
   ```java
   // Na classe Aluno
   public void entrarNaTurma(Turma novaTurma) {
       if (this.turma == novaTurma) return; // Importante!
       // ... resto do c√≥digo
   }
   ```

3. **NullPointerException**:
   ```java
   public void adicionarAluno(Aluno aluno) {
       Objects.requireNonNull(aluno, "Aluno n√£o pode ser nulo");
       // ... resto do c√≥digo
   }
   ```

**Link da Aula**: [Assista aqui](https://www.youtube.com/watch?v=-RtaqvKlH7w&list=PL62G310vn6nFIsOCC0H-C2infYgwm8SWW&index=70)

> Esta implementa√ß√£o corrige os problemas de duplica√ß√£o mantendo a associa√ß√£o bidirecional com `ArrayList`, seguindo as melhores pr√°ticas de OO.


As principais corre√ß√µes em rela√ß√£o ao problema de duplica√ß√£o s√£o:
1. Verifica√ß√£o `contains()` antes de adicionar √† lista
2. Controle rigoroso do fluxo entre `entrarNaTurma()` e `adicionarAluno()`
3. Preven√ß√£o de loops com a condi√ß√£o `if (this.turma == novaTurma) return;`
4. Sincroniza√ß√£o completa dos dois lados da associa√ß√£o

[Voltar ao √çndice](#indice)

---


## <a name="parte69">69 - 068 - Orienta√ß√£o Objetos - Leitura de dados pelo console</a>

# Resumo: Leitura de Dados pelo Console em Java

## üìå Vis√£o Geral
A aula aborda como ler dados do console em Java usando a classe `Scanner`, que pertence ao pacote `java.util`. Essa t√©cnica √© √∫til para intera√ß√µes b√°sicas com o usu√°rio via terminal.

## üìã Exemplos B√°sicos

### 1. Importa√ß√£o e Cria√ß√£o do Scanner
```java
import java.util.Scanner;

public class LeituraDados {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
    }
}
```

### 2. Lendo Diferentes Tipos de Dados
```java
System.out.print("Digite seu nome: ");
String nome = scanner.nextLine();

System.out.print("Digite sua idade: ");
int idade = scanner.nextInt();

System.out.print("Digite sua altura (ex: 1,75): ");
double altura = scanner.nextDouble();
```

## üèóÔ∏è Exemplo Complexo (Valida√ß√£o de Entrada)
```java
import java.util.InputMismatchException;
import java.util.Scanner;

public class LeituraValidada {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int idade = 0;
        boolean entradaValida = false;

        while (!entradaValida) {
            try {
                System.out.print("Digite sua idade: ");
                idade = scanner.nextInt();
                entradaValida = true;
            } catch (InputMismatchException e) {
                System.out.println("Erro: Digite um n√∫mero inteiro v√°lido!");
                scanner.next(); // Limpa o buffer do scanner
            }
        }

        System.out.println("Idade registrada: " + idade);
        scanner.close();
    }
}
```

## ‚úÖ Melhores Pr√°ticas
1. **Sempre fechar o Scanner**: Use `scanner.close()` quando n√£o for mais necess√°rio.
2. **Tratamento de exce√ß√µes**: Capture `InputMismatchException` para entradas inv√°lidas.
3. **Limpar o buffer**: Use `scanner.next()` ap√≥s erros para evitar loops infinitos.
4. **Mensagens claras**: Sempre exiba instru√ß√µes claras para o usu√°rio.
5. **Valida√ß√£o de entrada**: Implemente l√≥gica para garantir que os dados est√£o no formato esperado.

## ‚ùå Piores Pr√°ticas (Evitar)
1. **N√£o validar entradas**: Aceitar qualquer valor sem verifica√ß√£o pode causar erros.
2. **Ignorar exce√ß√µes**: N√£o tratar `InputMismatchException` pode quebrar o programa.
3. **N√£o fechar o Scanner**: Pode causar vazamento de recursos.
4. **Misturar nextLine() com nextInt()/nextDouble()**: Pode causar comportamentos inesperados devido ao buffer.
    - ‚ùå Problema:
      ```java
      int idade = scanner.nextInt();
      String nome = scanner.nextLine(); // Vai capturar o "enter" anterior
      ```
    - ‚úÖ Solu√ß√£o:
      ```java
      int idade = scanner.nextInt();
      scanner.nextLine(); // Consome o "enter"
      String nome = scanner.nextLine();
      ```

5. **Usar Scanner como vari√°vel global**: Pode levar a problemas de concorr√™ncia e dificulta o gerenciamento de recursos.

## üîç Observa√ß√µes Adicionais
- Para sistemas reais, considere usar frameworks mais robustos para entrada de dados.
- O Scanner √© adequado para programas simples e aprendizado.
- Em aplica√ß√µes com muitas entradas, considere criar m√©todos utilit√°rios para leitura e valida√ß√£o.


Este resumo cobre os principais pontos da aula, incluindo exemplos pr√°ticos e dicas importantes para escrever c√≥digo mais robusto ao trabalhar com entrada de dados pelo console em Java.

[Voltar ao √çndice](#indice)

---


## <a name="parte70">70 - 069 - Orienta√ß√£o Objetos - Exerc√≠cio leitura de dados do teclado</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte73">73 - 070 - Orienta√ß√£o Objetos - Associa√ß√£o pt 05 - Exerc√≠cio Associa√ß√£o</a>

[/070-OrientacaoObjetos-Associacaopt05-ExercicioAssociacao](/070-OrientacaoObjetos-Associacaopt05-ExercicioAssociacao)


# Resumo: Associa√ß√£o em Java - Exerc√≠cio Pr√°tico

## üìå Vis√£o Geral
A aula aborda o conceito de **Associa√ß√£o** em Java, que √© um tipo de rela√ß√£o entre objetos onde um objeto "usa" outro, sem que um seja dono do outro (como em composi√ß√£o/agrega√ß√£o). O exerc√≠cio pr√°tico demonstra como modelar rela√ß√µes entre classes usando associa√ß√£o.

---

## üìã Exemplo B√°sico (Modelagem de Classes com Associa√ß√£o)

### Cen√°rio: 
- **Semin√°rio**, **Aluno**, **Professor** e **Local** s√£o classes que se relacionam:
  - Um `Semin√°rio` tem `Alunos`, um `Professor` e um `Local`.
  - Um `Aluno` pode estar em um `Semin√°rio`.
  - Um `Professor` pode ministrar um ou mais `Semin√°rios`.

### C√≥digo das Classes:
#### Classe `Local`
```java
public class Local {
    private String endereco;

    public Local(String endereco) {
        this.endereco = endereco;
    }

    // Getters e Setters
    public String getEndereco() {
        return endereco;
    }
}
```

#### Classe `Aluno`
```java
public class Aluno {
    private String nome;
    private Seminario seminario;

    public Aluno(String nome) {
        this.nome = nome;
    }

    // Associa√ß√£o com Semin√°rio
    public void setSeminario(Seminario seminario) {
        this.seminario = seminario;
    }

    // Getters e Setters
}
```

#### Classe `Professor`
```java
public class Professor {
    private String nome;
    private List<Seminario> seminarios;

    public Professor(String nome) {
        this.nome = nome;
        this.seminarios = new ArrayList<>();
    }

    // Associa√ß√£o com Semin√°rio (um professor pode ter muitos semin√°rios)
    public void addSeminario(Seminario seminario) {
        this.seminarios.add(seminario);
    }
}
```

#### Classe `Seminario`
```java
public class Seminario {
    private String titulo;
    private List<Aluno> alunos;
    private Professor professor;
    private Local local;

    public Seminario(String titulo, Local local) {
        this.titulo = titulo;
        this.local = local;
        this.alunos = new ArrayList<>();
    }

    // Associa√ß√£o com Aluno (um semin√°rio pode ter muitos alunos)
    public void addAluno(Aluno aluno) {
        this.alunos.add(aluno);
        aluno.setSeminario(this); // Bidirecional
    }

    // Getters e Setters
}
```

---

## üèóÔ∏è Exemplo Complexo (Rela√ß√£o Bidirecional e Valida√ß√£o)
```java
public class TesteAssociacao {
    public static void main(String[] args) {
        Local local = new Local("Av. Java, 123");
        Professor professor = new Professor("Jo√£o Silva");
        Seminario seminario = new Seminario("POO com Java", local);

        // Adiciona professor ao semin√°rio
        seminario.setProfessor(professor);
        professor.addSeminario(seminario); // Bidirecional

        // Cria alunos e associa ao semin√°rio
        Aluno aluno1 = new Aluno("Maria");
        Aluno aluno2 = new Aluno("Pedro");

        seminario.addAluno(aluno1);
        seminario.addAluno(aluno2);

        // Exibe informa√ß√µes
        System.out.println("Semin√°rio: " + seminario.getTitulo());
        System.out.println("Local: " + seminario.getLocal().getEndereco());
        System.out.println("Professor: " + seminario.getProfessor().getNome());
        System.out.println("Alunos: " + seminario.getAlunos().stream()
            .map(Aluno::getNome)
            .collect(Collectors.joining(", ")));
    }
}
```

---

## ‚úÖ Melhores Pr√°ticas
1. **Use nomes claros para associa√ß√µes**: Ex: `aluno.setSeminario(seminario)` √© mais intuitivo que `aluno.setRelacao1(seminario)`.
2. **Mantenha a consist√™ncia em rela√ß√µes bidirecionais**: Se `A` conhece `B`, `B` tamb√©m deve conhecer `A` (se necess√°rio).
3. **Valide associa√ß√µes**: Evite adicionar `null` ou objetos inv√°lidos em listas de associa√ß√£o.
4. **Prefira cole√ß√µes (`List`, `Set`) para rela√ß√µes "1-N"**: Em vez de arrays, use estruturas din√¢micas.
5. **Encapsule a l√≥gica de associa√ß√£o**: Ex: `seminario.addAluno(aluno)` deve atualizar ambos os lados (aluno e semin√°rio).

---

## ‚ùå Piores Pr√°ticas (Evitar)
1. **Expor atributos sem encapsulamento**:
    - ‚ùå Ruim:
      ```java
      public class Seminario {
          public List<Aluno> alunos; // Exp√µe a lista diretamente
      }
      ```
    - ‚úÖ Bom:
      ```java
      public class Seminario {
          private List<Aluno> alunos;
          public void addAluno(Aluno aluno) { ... }
      }
      ```

2. **Ignorar rela√ß√µes bidirecionais**:
    - ‚ùå Ruim (associa√ß√£o unilateral):
      ```java
      seminario.getAlunos().add(aluno); // Aluno n√£o sabe que est√° no semin√°rio
      ```

3. **Ciclos de depend√™ncia desnecess√°rios**:
    - Evite criar estruturas onde `A` depende de `B`, `B` depende de `C` e `C` depende de `A`.

4. **N√£o inicializar cole√ß√µes**:
    - ‚ùå Ruim:
      ```java
      private List<Aluno> alunos; // Pode causar NullPointerException
      ```
    - ‚úÖ Bom:
      ```java
      private List<Aluno> alunos = new ArrayList<>();
      ```

5. **M√©todos de associa√ß√£o sem valida√ß√£o**:
    - ‚ùå Ruim:
      ```java
      public void setProfessor(Professor professor) {
          this.professor = professor; // Aceita null ou professor inv√°lido
      }
      ```

---

## üîç Observa√ß√µes Adicionais
- **Associa√ß√£o ‚â† Heran√ßa**: Associa√ß√£o √© "ter um", heran√ßa √© "ser um".
- **Grau de acoplamento**: Associa√ß√£o aumenta o acoplamento, mas √© essencial para modelagem OO.
- **Para rela√ß√µes mais fortes**, considere **Composi√ß√£o** (o objeto dono gerencia o ciclo de vida do outro).

Este resumo cobre o exerc√≠cio pr√°tico de associa√ß√£o entre objetos em Java, incluindo exemplos, boas pr√°ticas e armadilhas comuns.

[Voltar ao √çndice](#indice)

---


## <a name="parte74">74 - 071 - Orienta√ß√£o Objetos - Heran√ßa pt 01</a>

# Resumo: Heran√ßa em Java - Parte 1

## üìå Vis√£o Geral
A aula introduz o conceito de **Heran√ßa** em Java, um dos pilares da Orienta√ß√£o a Objetos que permite que uma classe (subclasse) herde atributos e m√©todos de outra classe (superclasse), promovendo reutiliza√ß√£o de c√≥digo e organiza√ß√£o hier√°rquica.

---

## üìã Exemplo B√°sico

### Superclasse `Pessoa`
```java
public class Pessoa {
    private String nome;
    private String cpf;

    public Pessoa(String nome, String cpf) {
        this.nome = nome;
        this.cpf = cpf;
    }

    public void imprimirDados() {
        System.out.println("Nome: " + nome);
        System.out.println("CPF: " + cpf);
    }
}
```

### Subclasse `Funcionario` (herda de `Pessoa`)
```java
public class Funcionario extends Pessoa {
    private double salario;

    public Funcionario(String nome, String cpf, double salario) {
        super(nome, cpf); // Chama o construtor da superclasse
        this.salario = salario;
    }

    @Override
    public void imprimirDados() {
        super.imprimirDados(); // Reusa o m√©todo da superclasse
        System.out.println("Sal√°rio: " + salario);
    }
}
```

### Uso
```java
Funcionario func = new Funcionario("Jo√£o", "123.456.789-00", 2500.0);
func.imprimirDados();
```

---

## üèóÔ∏è Exemplo Complexo (Heran√ßa M√∫ltipla N√≠vels)

### Hierarquia: `Veiculo` ‚Üí `VeiculoTerrestre` ‚Üí `Carro`
```java
// N√≠vel 1
public class Veiculo {
    private String marca;
    public Veiculo(String marca) {
        this.marca = marca;
    }
    public void ligar() {
        System.out.println("Ve√≠culo ligado");
    }
}

// N√≠vel 2
public class VeiculoTerrestre extends Veiculo {
    private int rodas;
    public VeiculoTerrestre(String marca, int rodas) {
        super(marca);
        this.rodas = rodas;
    }
}

// N√≠vel 3
public class Carro extends VeiculoTerrestre {
    private int portas;
    public Carro(String marca, int portas) {
        super(marca, 4); // Todos os carros t√™m 4 rodas
        this.portas = portas;
    }
    @Override
    public void ligar() {
        System.out.println("Carro ligado com chave");
    }
}
```

---

## ‚úÖ Melhores Pr√°ticas

1. **Use `@Override`**: Sempre anote m√©todos sobrescritos para melhor legibilidade.
2. **Chame `super()` corretamente**: Inicialize a superclasse no construtor.
3. **Prefira composi√ß√£o sobre heran√ßa**: Herde apenas quando houver rela√ß√£o "√©-um".
4. **Mantenha hierarquias rasas**: Evite mais de 3 n√≠veis de heran√ßa.
5. **Use m√©todos protegidos**: Para m√©todos usados apenas por subclasses:
   ```java
   protected void metodoInterno() { ... }
   ```

---

## ‚ùå Piores Pr√°ticas (Evitar)

1. **Heran√ßa para reutiliza√ß√£o apenas**:
    - ‚ùå Ruim: Herdar `ArrayList` s√≥ para usar seus m√©todos.
    - ‚úÖ Melhor: Usar composi√ß√£o (`private List list = new ArrayList()`).

2. **Quebrar LSP (Princ√≠pio de Substitui√ß√£o de Liskov)**:
    - ‚ùå Ruim:
      ```java
      @Override
      public void ligar() {
          throw new UnsupportedOperationException(); // Subclasse n√£o deveria invalidar superclasse
      }
      ```

3. **Acessar atributos diretamente**:
    - ‚ùå Ruim:
      ```java
      public class SubClasse extends SuperClasse {
          public void metodo() {
              System.out.println(super.atributo); // Deveria usar getter
          }
      }
      ```

4. **Heran√ßa m√∫ltipla simulada** (Java n√£o suporta):
    - ‚ùå Ruim: Usar `default` em interfaces para simular heran√ßa m√∫ltiplia complexa.

5. **Classes/m√©todos `final` ignorados**:
    - N√£o tente herdar de classes marcadas como `final` como `String`.

---

## üîç Observa√ß√µes Adicionais

- **`super` vs `this`**:
    - `super` acessa a superclasse
    - `this` acessa a classe atual

- **Heran√ßa de Interfaces**: Uma classe pode implementar m√∫ltiplas interfaces.

- **Classes Abstratas**: √öteis quando a superclasse n√£o deve ser instanciada diretamente:
  ```java
  public abstract class Animal {
      public abstract void emitirSom();
  }
  ```

Este resumo cobre os principais conceitos de heran√ßa em Java conforme abordado na aula, com exemplos pr√°ticos e boas pr√°ticas para aplica√ß√£o correta do conceito.



[Voltar ao √çndice](#indice)

---


## <a name="parte75">75 - 072 - Orienta√ß√£o Objetos - Heran√ßa pt 02 - Super</a>

# Resumo: Heran√ßa em Java - Parte 2 (Palavra-chave `super`)

## üìå Vis√£o Geral
Esta aula explora o uso avan√ßado da palavra-chave `super` em heran√ßa Java, demonstrando como:
1. Acessar membros da superclasse
2. Invocar construtores parentais
3. Diferenciar membros com nomes duplicados
4. Construir hierarquias de objetos corretamente

## üìã Exemplos B√°sicos

### 1. Chamada de Construtor Parental
```java
class Veiculo {
    private String placa;
    
    public Veiculo(String placa) {
        this.placa = placa;
    }
}

class Carro extends Veiculo {
    private int portas;
    
    public Carro(String placa, int portas) {
        super(placa);  // Obrigat√≥rio (Veiculo n√£o tem construtor padr√£o)
        this.portas = portas;
    }
}
```

### 2. Acesso a M√©todo da Superclasse
```java
class Instrumento {
    void afinar() {
        System.out.println("Afinando instrumento gen√©rico");
    }
}

class Violao extends Instrumento {
    @Override
    void afinar() {
        super.afinar();  // Reutiliza comportamento parental
        System.out.println("Afinando cordas do viol√£o");
    }
}
```

## üèóÔ∏è Exemplo Complexo (Hierarquia de Inicializa√ß√£o)

```java
class Dispositivo {
    private String serial;
    
    public Dispositivo(String serial) {
        this.serial = serial;
        System.out.println("Construindo Dispositivo");
    }
}

class Smartphone extends Dispositivo {
    private String sistema;
    
    public Smartphone(String serial, String sistema) {
        super(serial);  // Chamada obrigat√≥ria primeiro
        this.sistema = sistema;
        System.out.println("Construindo Smartphone");
    }
    
    public void mostrarInfo() {
        System.out.println("S/N: " + super.serial);  // Erro: serial √© private
        System.out.println("OS: " + this.sistema);
    }
}
```

## ‚úÖ Melhores Pr√°ticas

1. **Ordem de Constru√ß√£o**:
   ```java
   public SubClasse() {
       super();  // Sempre deve ser a primeira instru√ß√£o
       // Demais inicializa√ß√µes
   }
   ```

2. **Uso de `@Override`**:
   ```java
   @Override
   void metodo() {
       super.metodo();  // Clareza na sobrescrita
   }
   ```

3. **Encapsulamento Protegido**:
   ```java
   protected String serial;  // Acess√≠vel apenas na hierarquia
   ```

4. **Encadeamento Limpo**:
   ```java
   class A {
       A(int x) { ... }
   }
   
   class B extends A {
       B() {
           super(10);  // Expl√≠cito quando necess√°rio
       }
   }
   ```

## ‚ùå Piores Pr√°ticas (Evitar)

1. **Ordem Incorreta**:
   ```java
   public SubClasse() {
       this.inicializar();  // ‚ùå Antes de super()
       super();            // Erro de compila√ß√£o
   }
   ```

2. **Acesso Direto a Privados**:
   ```java
   super.atributoPrivado;  // ‚ùå N√£o compila
   ```

3. **Abuso de Heran√ßa**:
   ```java
   class StringUtils extends String {  // ‚ùå String √© final
       // ...
   }
   ```

4. **Construtores Fantasmas**:
   ```java
   class Pai {
       Pai(int x) { ... }
   }
   
   class Filho extends Pai {
       Filho() { }  // ‚ùå Falta super(x)
   }
   ```

5. **Confus√£o This/Super**:
   ```java
   this.metodo();  // Pode ser sobrescrito
   super.metodo(); // Vers√£o espec√≠fica da superclasse
   ```

## üîç Observa√ß√µes Avan√ßadas

1. **Heran√ßa Multin√≠vel**:
   ```java
   class A { void m() {} }
   class B extends A { @Override void m() {} }
   class C extends B { 
       void test() {
           super.m();  // Chama B.m()
       }
   }
   ```

2. **Inicializa√ß√£o com Par√¢metros**:
   ```java
   class Database {
       Database(String url) { ... }
   }
   
   class MySQL extends Database {
       MySQL() {
           super("jdbc:mysql://localhost");  // Par√¢metro fixo
       }
   }
   ```

3. **Padr√£o Template Method**:
   ```java
   abstract class Template {
       void execute() {
           init();
           run();
           end();
       }
       abstract void run();
   }
   ```

4. **Problema do Diamante**:
   ```java
   interface A { default void m() {} }
   interface B { default void m() {} }
   class C implements A, B {  // ‚ùå Conflito
       @Override
       public void m() {
           A.super.m();  // Solu√ß√£o expl√≠cita
       }
   }
   ```

5. **Serializa√ß√£o**:
   ```java
   class Parent implements Serializable { ... }
   class Child extends Parent {
       private void readObject(ObjectInputStream ois) 
           throws IOException, ClassNotFoundException {
           ois.defaultReadObject();
           super.validate();  // P√≥s-processamento
       }
   }
   ```


Este resumo cobre desde os usos b√°sicos at√© padr√µes avan√ßados com `super`, incluindo armadilhas comuns e solu√ß√µes recomendadas para constru√ß√£o robusta de hierarquias de classes.

[Voltar ao √çndice](#indice)

---


## <a name="parte76">76 - 073 - Orienta√ß√£o Objetos - Heran√ßa pt 03 - protected</a>

# Resumo: Modificador `protected` em Java - Heran√ßa Parte 3

## üìå Vis√£o Geral
A aula explora o modificador de acesso `protected`, que permite:
- Acesso √†s classes do mesmo pacote
- Acesso √†s subclasses (mesmo em pacotes diferentes)
- Um meio-termo entre `public` e `private`

## üìã Exemplos B√°sicos

### 1. Uso B√°sico de `protected`
```java
package br.com.dev;
public class Pessoa {
    protected String nome;  // Acess√≠vel por subclasses
    
    protected void imprimir() {
        System.out.println("Nome: " + nome);
    }
}
```

### 2. Acesso em Subclasse (pacote diferente)
```java
package br.com.outro;
import br.com.dev.Pessoa;

public class Aluno extends Pessoa {
    public void mostrarDados() {
        System.out.println(this.nome);  // Acesso permitido
        this.imprimir();  // M√©todo protected acess√≠vel
    }
}
```

## üèóÔ∏è Exemplo Complexo (Hierarquia com `protected`)

```java
package br.com.veiculos;

public abstract class Veiculo {
    protected String modelo;
    protected int ano;
    
    protected abstract void ligar();
    
    protected void imprimirDetalhes() {
        System.out.println("Modelo: " + modelo);
    }
}

public class Carro extends Veiculo {
    public Carro(String modelo, int ano) {
        this.modelo = modelo;  // Acesso direto
        this.ano = ano;
    }
    
    @Override
    protected void ligar() {
        System.out.println("Ligando carro " + modelo);
    }
    
    public void mostrar() {
        this.ligar();  // Chama m√©todo protected
        super.imprimirDetalhes();  // Usando super
    }
}
```

## ‚úÖ Melhores Pr√°ticas

1. **Use para membros de framework**:
   ```java
   protected void initialize() { // Para ser sobrescrito
       // C√≥digo padr√£o
   }
   ```

2. **Documente o contrato**:
   ```java
   /**
    * @protected Este m√©todo deve ser sobrescrito para configurar a view
    */
   protected void setupView() {...}
   ```

3. **Prefira `protected` a `public`** para m√©todos internos da hierarquia

4. **Para atributos constantes**:
   ```java
   protected static final int DEFAULT_SIZE = 10;
   ```

5. **Combine com abstract**:
   ```java
   public abstract class Animal {
       protected abstract void comer();
   }
   ```

## ‚ùå Piores Pr√°ticas (Evitar)

1. **Expor atributos sem necessidade**:
   ```java
   protected List<String> dadosInternos;  // ‚ùå Exp√µe implementa√ß√£o
   ```

2. **Usar em classes `final`** (contradit√≥rio):
   ```java
   public final class Util {
       protected static void helper() {}  // ‚ùå Nunca ser√° herdado
   }
   ```

3. **Violar encapsulamento**:
   ```java
   public class Conta {
       protected double saldo;  // ‚ùå Perigoso expor diretamente
   }
   ```

4. **Ignorar pacotes**:
   ```java
   protected void metodo() {}  // ‚ùå Se a classe for package-private
   ```

5. **Confundir com default (package-private)**:
   ```java
   void metodo() {}       // S√≥ mesmo pacote
   protected void m() {}  // S√≥ mesmo pacote + subclasses
   ```

## üîç Observa√ß√µes Avan√ßadas

1. **Heran√ßa cruzando pacotes**:
   ```java
   // Pacote A
   public class Pai {
       protected int x;
   }
   
   // Pacote B
   public class Filho extends Pai {
       void teste() {
           System.out.println(x);  // OK
           Pai p = new Pai();
           System.out.println(p.x);  // ‚ùå Erro (acesso via inst√¢ncia)
       }
   }
   ```

2. **Padr√£o Template Method**:
   ```java
   public abstract class Template {
       public final void process() {
           init();
           execute();
           end();
       }
       
       protected abstract void execute();  // Hook method
       protected void init() {}  // Opcional
   }
   ```

3. **Serializa√ß√£o protegida**:
   ```java
   public class Base implements Serializable {
       protected void readData(ObjectInputStream in) 
           throws IOException {
           // Leitura segura para subclasses
       }
   }
   ```

4. **Classes abstratas**:
   ```java
   public abstract class Figura {
       protected int lados;
       
       protected Figura(int lados) {
           this.lados = lados;
       }
   }
   ```

5. **Enums com comportamento protegido**:
   ```java
   public enum Nivel {
       BASIC {
           protected void show() { /* impl */ }
       };
       
       protected abstract void show();
   }
   ```

## ‚ö†Ô∏è Cuidados Especiais

1. **Visibilidade em tempo de design**:
   ```plantuml
   class Parent {
     #protectedField
     #protectedMethod()
   }
   
   class Child {
     .. usa ..
     -> Parent#protectedField
     -> Parent#protectedMethod()
   }
   ```

2. **Refatora√ß√£o segura**:
    - Alterar de `private` para `protected` = compat√≠vel
    - Alterar de `protected` para `private` = quebra compatibilidade

3. **Testabilidade**:
   ```java
   @Test
   public void testProtectedMethod() throws Exception {
       Method method = Classe.class.getDeclaredMethod("metodoProtegido");
       method.setAccessible(true);  // Reflection para testes
   }
   ```


Este resumo cobre desde os conceitos fundamentais at√© padr√µes avan√ßados de uso do modificador `protected`, incluindo os principais cuidados no design de hierarquias de classes em Java.

[Voltar ao √çndice](#indice)

---


## <a name="parte77">77 - 074 - Orienta√ß√£o Objetos - Heran√ßa pt 04 - Construtores</a>

# Resumo: Heran√ßa e Construtores em Java - Parte 4

## üìå Vis√£o Geral
Esta aula aborda o comportamento de construtores em hierarquias de heran√ßa, destacando:
- A cadeia de chamadas de construtores
- O uso obrigat√≥rio de `super()`
- Padr√µes para inicializa√ß√£o segura
- Problemas comuns e suas solu√ß√µes

## üìã Exemplos B√°sicos

### 1. Chamada Impl√≠cita a super()
```java
class Animal {
    Animal() {
        System.out.println("Construtor Animal");
    }
}

class Cachorro extends Animal {
    Cachorro() {
        // super() chamado implicitamente
        System.out.println("Construtor Cachorro");
    }
}
```
**Sa√≠da:**
```
Construtor Animal
Construtor Cachorro
```

### 2. Construtor Parametrizado
```java
class Veiculo {
    private String placa;
    
    Veiculo(String placa) {
        this.placa = placa;
    }
}

class Carro extends Veiculo {
    Carro(String placa) {
        super(placa); // Obrigat√≥rio expl√≠cito
    }
}
```

## üèóÔ∏è Exemplo Complexo (Inicializa√ß√£o em 3 N√≠veis)

```java
class Eletronico {
    private int voltagem;
    
    Eletronico(int voltagem) {
        this.voltagem = voltagem;
        System.out.println("Eletronico: " + voltagem + "V");
    }
}

class Computador extends Eletronico {
    private String modelo;
    
    Computador(int voltagem, String modelo) {
        super(voltagem);
        this.modelo = modelo;
        System.out.println("Computador: " + modelo);
    }
}

class Notebook extends Computador {
    private int bateria;
    
    Notebook() {
        super(110, "UltraBook"); // Chama Computador(int, String)
        this.bateria = 5000;
        System.out.println("Notebook: " + bateria + "mAh");
    }
}
```

## ‚úÖ Melhores Pr√°ticas

1. **Encadeamento claro**:
   ```java
   public SubClasse(params) {
       super(paramsPai); // Sempre na primeira linha
       // Inicializa√ß√µes espec√≠ficas
   }
   ```

2. **Construtores m√≠nimos**:
   ```java
   public class Pai {
       // Um √∫nico construtor bem definido
       public Pai(parametrosEssenciais) { ... }
   }
   ```

3. **Factory Methods**:
   ```java
   public static CriarInstanciaPadrao() {
       return new SubClasse(valoresPadrao);
   }
   ```

4. **Valida√ß√£o em um n√≠vel**:
   ```java
   public Pai(int valor) {
       if (valor < 0) throw... // Valida aqui
   }
   ```

5. **Documenta√ß√£o clara**:
   ```java
   /**
    * @throws IllegalArgumentException se X ocorrer
    */
   public Pai(int x) { ... }
   ```

## ‚ùå Piores Pr√°ticas (Evitar)

1. **Ordem incorreta**:
   ```java
   public SubClasse() {
       inicializar(); // ‚ùå Antes de super()
       super();      // Erro de compila√ß√£o
   }
   ```

2. **Construtores desnecess√°rios**:
   ```java
   public class Pai {
       public Pai() {} // Vazio s√≥ para compilar
       public Pai(int x) { ... }
   }
   ```

3. **L√≥gica complexa em construtores**:
   ```java
   public Pai() {
       this.connection = new Connection(); // ‚ùå Inje√ß√£o seria melhor
       this.config = loadConfigFile();    // ‚ùå Pode falhar
   }
   ```

4. **Ignorar exce√ß√µes**:
   ```java
   public SubClasse() {
       try { super(); } catch(Exception e) {} // ‚ùå Esconde erros
   }
   ```

5. **Acoplamento temporal**:
   ```java
   public Pai() {
       init(); // ‚ùå Requer chamada adicional
   }
   ```

## üîç Casos Especiais

### 1. Classes sem construtor expl√≠cito
```java
class A { }
class B extends A { } // Ambos t√™m construtor padr√£o
```

### 2. Construtores privados
```java
class Singleton {
    private Singleton() {}
    public static Singleton getInstance() { ... }
}
```

### 3. Heran√ßa com classes internas
```java
class Externa {
    class Interna extends Pai {
        Interna() {
            Externa.this.super(); // Sintaxe especial
        }
    }
}
```

### 4. Serializa√ß√£o
```java
class Pai implements Serializable {
    public Pai() { ... } // Chamado na desserializa√ß√£o
}
```

### 5. Padr√£o Builder
```java
class Produto {
    private Produto(Builder b) { ... }
    
    static class Builder {
        Produto build() {
            return new Produto(this);
        }
    }
}
```

## ‚ö†Ô∏è Regras Fundamentais

1. **Primeira linha deve ser this() ou super()**
2. **Se nenhum construtor for definido, Java insere um padr√£o**
3. **Classes abstratas podem ter construtores (chamados pelas concretas)**
4. **Construtores n√£o s√£o herdados**
5. **Final fields devem ser inicializados em todos os construtores**


Este resumo cobre desde os conceitos b√°sicos at√© padr√µes avan√ßados de constru√ß√£o de objetos em hierarquias de heran√ßa, incluindo armadilhas comuns e melhores pr√°ticas para um design robusto.



[Voltar ao √çndice](#indice)

---


## <a name="parte78">78 - 075 - Orienta√ß√£o Objetos - Heran√ßa pt 05 - Sequ√™ncia de inicializa√ß√£o</a>

# Resumo: Sequ√™ncia de Inicializa√ß√£o em Heran√ßa Java

## üìå Vis√£o Geral
A aula explica a ordem exata de execu√ß√£o durante a constru√ß√£o de objetos em hierarquias de heran√ßa, mostrando como Java inicializa:
1. Blocos est√°ticos
2. Atributos de classe
3. Construtores
4. Blocos de inst√¢ncia

## üìã Exemplo B√°sico (Ordem Simples)

```java
class A {
    static { System.out.println("Bloco est√°tico A"); }
    { System.out.println("Bloco inst√¢ncia A"); }
    A() { System.out.println("Construtor A"); }
}

class B extends A {
    static { System.out.println("Bloco est√°tico B"); }
    { System.out.println("Bloco inst√¢ncia B"); }
    B() { System.out.println("Construtor B"); }
}

// Sa√≠da quando new B() √© chamado:
// Bloco est√°tico A
// Bloco est√°tico B
// Bloco inst√¢ncia A
// Construtor A
// Bloco inst√¢ncia B
// Construtor B
```

## üèóÔ∏è Exemplo Complexo (Inicializa√ß√£o Multin√≠vel)

```java
class Raiz {
    private static String staticRaiz = initStatic("Static Raiz");
    private String instanciaRaiz = initInstancia("Inst√¢ncia Raiz");
    
    static { System.out.println("Bloco est√°tico Raiz"); }
    { System.out.println("Bloco inst√¢ncia Raiz"); }
    
    Raiz() { System.out.println("Construtor Raiz"); }
    
    static String initStatic(String msg) {
        System.out.println(msg);
        return msg;
    }
    
    String initInstancia(String msg) {
        System.out.println(msg);
        return msg;
    }
}

class Nivel1 extends Raiz {
    // Membros similares com "Nivel1"...
}

class Nivel2 extends Nivel1 {
    // Membros similares com "Nivel2"...
}

// Sa√≠da para new Nivel2() mostra a ordem completa
// de inicializa√ß√£o em 3 n√≠veis de heran√ßa
```

## ‚úÖ Melhores Pr√°ticas

1. **Organize inicializa√ß√µes complexas**:
   ```java
   private List<String> dados = new ArrayList<>(); // Inicializa√ß√£o direta
   ```

2. **Use m√©todos auxiliares para l√≥gica complexa**:
   ```java
   private Connection conn = initConnection();
   private Connection initConnection() { ... }
   ```

3. **Documente depend√™ncias de inicializa√ß√£o**:
   ```java
   /**
    * @depends BancoDeDados.inicializar() 
    * deve ser chamado primeiro
    */
   ```

4. **Para inicializa√ß√£o lazy**:
   ```java
   private Data dataCarregada;
   public Data getData() {
       if (dataCarregada == null) {
           dataCarregada = carregarData();
       }
       return dataCarregada;
   }
   ```

## ‚ùå Piores Pr√°ticas (Evitar)

1. **Ordem dependente de inicializa√ß√£o**:
   ```java
   private static int A = B + 1; // ‚ùå B ainda n√£o inicializado
   private static int B = 2;
   ```

2. **Blocos de inst√¢ncia ap√≥s construtor**:
   ```java
   class X {
       X() { System.out.println(a); } // ‚ùå a ainda n√£o existe
       { a = 10; }
       private int a;
   }
   ```

3. **Inicializa√ß√£o circular**:
   ```java
   class A { static final int X = B.Y + 1; }
   class B { static final int Y = A.X + 1; } // ‚ùå StackOverflow
   ```

4. **Construtores que chamam m√©todos sobrescritos**:
   ```java
   class Pai {
       Pai() { metodo(); } // ‚ùå Perigoso se sobrescrito
   }
   ```

## üîç Detalhes de Inicializa√ß√£o

### Ordem Completa:
1. Blocos `static` e atributos est√°ticos da superclasse
2. Blocos `static` e atributos est√°ticos da subclasse
3. Atributos de inst√¢ncia e blocos n√£o-est√°ticos da superclasse
4. Construtor da superclasse
5. Atributos de inst√¢ncia e blocos n√£o-est√°ticos da subclasse
6. Construtor da subclasse

### Exemplo com Threads:
```java
class Singleton {
    private static Singleton instance = new Singleton();
    public static int COUNT_A;
    public static int COUNT_B = 0;
    
    private Singleton() {
        COUNT_A++;
        COUNT_B++;
    }
    
    public static Singleton getInstance() {
        return instance;
    }
}
// Resultado: COUNT_A=1, COUNT_B=0 (devido √† ordem)
```

### Inicializa√ß√£o de Interfaces:
```java
interface I {
    int VAL = new Random().nextInt(10);
}
// VAL √© inicializado quando a interface √© carregada
```

### Caso Especial - Heran√ßa + Interfaces:
```java
interface A { default void m() {} }
class B { public void m() {} }
class C extends B implements A {
    // N√£o precisa implementar m()
}
```

Este resumo cobre os principais aspectos da sequ√™ncia de inicializa√ß√£o em Java, mostrando desde exemplos b√°sicos at√© casos complexos com heran√ßa multin√≠vel, incluindo armadilhas comuns e boas pr√°ticas para um c√≥digo robusto.

#### Sequ√™ncia de Inicializa√ß√£o em Heran√ßa Java

##### Ordem de Execu√ß√£o:

``` 

// 0 - Bloco de inicializa√ß√£o est√°tico da super classe √© executado quando a JVM carregar classe pai
// 1 - Bloco de inicializa√ß√£o est√°tico da subclasse √© executado quando a JVM carregar classe filha
// 2 - Alocado espa√ßo em mem√≥ria pro objeto da superclasse
// 3 - Cada atributo de superclasse √© criado e inicializado com valores default ou o quer for passado
// 4 - Bloco de inicializa√ß√£o da superclasse √© executado na ordem em que aparece
// 5 - Construtor √© executado da superclasse
// 6 - Alocado espa√ßo em mem√≥ria pro objeto da subclasse
// 7 - Cada atributo de subclasse √© criado e inicializado com valores default ou o quer for passado
// 8 - Bloco de inicializa√ß√£o da subclasse √© executado na ordem em que aparece
// 9 - Construtor √© executado da subclasse

```
[Voltar ao √çndice](#indice)

---


## <a name="parte79">79 - 076 - Orienta√ß√£o Objetos - Sobrescrita do m√©todo toString</a>

# Resumo: Sobrescrita do M√©todo `toString()` em Java

## üìå Vis√£o Geral
A aula aborda a import√¢ncia e implementa√ß√£o da sobrescrita do m√©todo `toString()` para:
- Representa√ß√£o textual significativa de objetos
- Depura√ß√£o mais eficiente
- Sa√≠da leg√≠vel em logs e interfaces

## üìã Exemplo B√°sico

### Classe sem `toString()`
```java
class Pessoa {
    String nome;
    int idade;
}

// Sa√≠da padr√£o quando impressa: Pessoa@15db9742
```

### Classe com `toString()` sobrescrito
```java
@Override
public String toString() {
    return "Pessoa{nome='" + nome + "', idade=" + idade + "}";
}

// Sa√≠da: Pessoa{nome='Jo√£o', idade=30}
```

## üèóÔ∏è Exemplo Complexo (Composi√ß√£o de Objetos)

```java
class Endereco {
    String rua;
    int numero;
    
    @Override
    public String toString() {
        return rua + ", " + numero;
    }
}

class Cliente {
    String nome;
    Endereco endereco;
    List<String> telefones;
    
    @Override
    public String toString() {
        return "Cliente{" +
               "nome='" + nome + '\'' +
               ", endereco=" + endereco +
               ", telefones=" + telefones +
               '}';
    }
}

// Sa√≠da: Cliente{nome='Maria', endereco=Av. Java, 123, telefones=[1199999, 1188888]}
```

## ‚úÖ Melhores Pr√°ticas

1. **Inclua todos os campos relevantes**:
   ```java
   @Override
   public String toString() {
       return "Produto{" +
              "id=" + id +
              ", nome='" + nome + '\'' +
              ", preco=" + preco +
              '}';
   }
   ```

2. **Mantenha formato consistente**:
    - Escolha um padr√£o (ex: JSON-style) e mantenha em todas as classes

3. **Use `StringBuilder` para objetos complexos**:
   ```java
   @Override
   public String toString() {
       StringBuilder sb = new StringBuilder("Pedido{");
       sb.append("itens=").append(itens);
       // outros campos
       return sb.append('}').toString();
   }
   ```

4. **Documente o formato**:
   ```java
   /**
    * @return String no formato "Nome(id)", ex: "ProdutoX(123)"
    */
   @Override
   public String toString() { ... }
   ```

5. **Para cole√ß√µes, use `Arrays.toString()` ou similar**:
   ```java
   "telefones=" + Arrays.toString(telefones)
   ```

## ‚ùå Piores Pr√°ticas (Evitar)

1. **Expor dados sens√≠veis**:
   ```java
   @Override
   public String toString() {
       return "Usuario{" +
              "login='" + login + '\'' +
              ", senha='" + senha + '\'' + // ‚ùå Perigoso!
              '}';
   }
   ```

2. **Formato inconsistente**:
   ```java
   // Na classe A: "Nome: "+nome
   // Na classe B: "{nome:value}" 
   ```

3. **Alta complexidade computacional**:
   ```java
   @Override
   public String toString() {
       return calcularRelatorioComplexo(); // ‚ùå Pode ser pesado
   }
   ```

4. **Quebrar contrato do `toString()`**:
   ```java
   @Override
   public String toString() {
       return null; // ‚ùå Nunca retorne null
   }
   ```

5. **Depender de locale/formata√ß√£o**:
   ```java
   @Override
   public String toString() {
       return "Pre√ßo: " + NumberFormat.getCurrencyInstance().format(preco); // ‚ùå Locale-dependent
   }
   ```

## üîç Observa√ß√µes Avan√ßadas

1. **Gera√ß√£o autom√°tica**:
    - IDEs geram `toString()` automaticamente:
      ```java
      // Eclipse/IntelliJ generation
      @Override
      public String toString() {
          return "Cliente [nome=" + nome + ", idade=" + idade + "]";
      }
      ```

2. **Bibliotecas √∫teis**:
    - `ToStringBuilder` do Apache Commons:
      ```java
      public String toString() {
          return ToStringBuilder.reflectionToString(this);
      }
      ```

3. **Heran√ßa com `toString()`**:
   ```java
   @Override
   public String toString() {
       return super.toString() + " SubClasse{campo=" + campo + "}";
   }
   ```

4. **Para enumera√ß√µes**:
   ```java
   @Override
   public String toString() {
       return name().toLowerCase(); // Formato customizado
   }
   ```

5. **Contrato oficial** (JavaDoc):
    - Deve retornar "texto representativo e informativo"
    - Recomendado sobrescrever para todas as classes

Este resumo cobre desde os conceitos b√°sicos at√© t√©cnicas avan√ßadas de implementa√ß√£o do `toString()`, incluindo melhores pr√°ticas e armadilhas comuns, conforme apresentado na aula.

[Voltar ao √çndice](#indice)

---


## <a name="parte80">80 - 077 - Orienta√ß√£o Objetos - Modificador final pt 01 - Tipo primitivo</a>

# Resumo: Modificador `final` em Java - Tipos Primitivos

## üìå Vis√£o Geral
A aula aborda o uso do modificador `final` com tipos primitivos, que:
- Transforma a vari√°vel em uma constante (valor n√£o pode ser alterado ap√≥s inicializa√ß√£o)
- Deve ser inicializada no momento da declara√ß√£o ou no construtor (para vari√°veis de inst√¢ncia)
- Pode melhorar a legibilidade e seguran√ßa do c√≥digo

## üìã Exemplos B√°sicos

### 1. Constante primitiva
```java
final double PI = 3.14159;  // Deve ser inicializada
// PI = 3.15;  // ‚ùå Erro de compila√ß√£o (n√£o pode reatribuir)
```

### 2. Par√¢metro final
```java
void calcular(final int valor) {
    // valor = 10;  // ‚ùå Erro (par√¢metro final n√£o pode ser modificado)
    System.out.println(valor * 2);
}
```

## üèóÔ∏è Exemplo Complexo (Uso em Contextos Diferentes)

### 1. Bloco de inicializa√ß√£o
```java
class Circulo {
    final double RAIO;
    
    {  // Bloco de inicializa√ß√£o
        RAIO = 10.0;  // OK (antes do construtor)
    }
}
```

### 2. Switch com final
```java
final int opcao = 2;
switch(opcao) {
    case 1: System.out.println("Op√ß√£o 1"); break;
    case 2: System.out.println("Op√ß√£o 2"); break;  // ‚úîÔ∏è Uso v√°lido
}
```

### 3. Final em estruturas de controle
```java
for(final int i = 0; i < 5; i++) {  // ‚ùå i++ viola o final
    System.out.println(i);
}
```

## ‚úÖ Melhores Pr√°ticas

1. **Nomes em MAI√öSCULAS** para constantes:
   ```java
   final int MAX_TENTATIVAS = 3;
   ```

2. **Inicializa√ß√£o no construtor** para vari√°veis de inst√¢ncia:
   ```java
   class Pagamento {
       final double VALOR;
       
       Pagamento(double v) {
           this.VALOR = v;  // OK no construtor
       }
   }
   ```

3. **Use final para par√¢metros** quando n√£o devem ser modificados:
   ```java
   void processar(final int codigo) { ... }
   ```

4. **Final + static** para constantes globais:
   ```java
   public static final double VELOCIDADE_LUZ = 299792458;
   ```

5. **Documente o prop√≥sito**:
   ```java
   /** Tempo m√°ximo em segundos antes do timeout */
   final int TIMEOUT = 30;
   ```

## ‚ùå Piores Pr√°ticas (Evitar)

1. **Reatribui√ß√£o disfar√ßada**:
   ```java
   final int[] nums = {1, 2, 3};
   nums[0] = 10;  // ‚ùå Permitido (mas enganoso)
   ```

2. **Final sem inicializa√ß√£o** (vari√°veis locais):
   ```java
   final int x;  // ‚ùå Erro se n√£o for inicializada antes do uso
   ```

3. **Uso desnecess√°rio** em vari√°veis ef√™meras:
   ```java
   for(final int j = 0; j < 10; j++) {  // ‚ùå j n√£o precisa ser final
       // ...
   }
   ```

4. **Confundir imutabilidade**:
   ```java
   final List<String> nomes = new ArrayList<>();
   nomes.add("Novo");  // ‚ùå Permitido (aponta para o mesmo objeto)
   ```

5. **Nomes enganosos**:
   ```java
   final int temp = 30;  // ‚ùå Parece vari√°vel, mas √© constante
   ```

## üîç Observa√ß√µes Avan√ßadas

1. **Performance**: Vari√°veis `final` podem ser otimizadas pelo JVM

2. **Thread-safe**: Valores `final` s√£o vis√≠veis para todas threads ap√≥s constru√ß√£o

3. **M√©todos locais**:
   ```java
   void metodo() {
       final int y;  // Pode ser inicializada depois
       if(condicao) {
           y = 10;
       } else {
           y = 20;
       }
   }
   ```

4. **Lambda expressions**:
   ```java
   final int z = 5;
   Runnable r = () -> System.out.println(z);  // S√≥ funciona com final/effectively final
   ```

5. **Pattern Matching** (Java 17+):
   ```java
   if(obj instanceof final String s) {  // s √© final
       System.out.println(s.toLowerCase());
   }
   ```

6. **Record** (Java 16+):
   ```java
   record Ponto(final int x, final int y) {}  // Campos j√° s√£o implicitamente final
   ```


Este resumo cobre desde os usos b√°sicos at√© aplica√ß√µes avan√ßadas do `final` com tipos primitivos, incluindo melhores pr√°ticas e armadilhas comuns, conforme apresentado na aula.

[Voltar ao √çndice](#indice)

---


## <a name="parte81">81 - 078 - Orienta√ß√£o Objetos - Modificador final pt 02 - Tipo refer√™ncia</a>

# Resumo: Modificador `final` com Tipos Refer√™ncia em Java

## üìå Vis√£o Geral
A aula explora o comportamento do modificador `final` quando aplicado a tipos refer√™ncia, destacando que:
- A refer√™ncia torna-se constante (n√£o pode apontar para outro objeto)
- O estado do objeto referenciado PODE ser modificado
- Aplic√°vel a classes, atributos, par√¢metros e vari√°veis locais

## üìã Exemplos B√°sicos

### 1. Refer√™ncia final a objeto mut√°vel
```java
final List<String> lista = new ArrayList<>();
lista.add("Java");  // ‚úîÔ∏è V√°lido (modifica√ß√£o interna)
// lista = new LinkedList<>();  // ‚ùå Erro (reatribui√ß√£o)
```

### 2. Par√¢metro final
```java
void processar(final Pessoa pessoa) {
    pessoa.setNome("Novo");  // ‚úîÔ∏è V√°lido
    // pessoa = new Pessoa();  // ‚ùå Erro
}
```

## üèóÔ∏è Exemplos Complexos

### 1. Padr√£o de Classe Imut√°vel
```java
public final class Endereco {
    private final String rua;
    private final int numero;
    
    public Endereco(String rua, int numero) {
        this.rua = rua;
        this.numero = numero;
    }
    
    // Apenas getters
}
```

### 2. Cole√ß√£o Defensiva
```java
public class Time {
    private final List<Jogador> jogadores;
    
    public Time(List<Jogador> jogadores) {
        this.jogadores = Collections.unmodifiableList(new ArrayList<>(jogadores));
    }
    
    public List<Jogador> getJogadores() {
        return jogadores; // Lista imut√°vel
    }
}
```

## ‚úÖ Melhores Pr√°ticas

1. **Para imutabilidade**:
   ```java
   private final List<String> dados = List.of("A", "B"); // Java 9+
   ```

2. **Documenta√ß√£o clara**:
   ```java
   /**
    * @final A refer√™ncia n√£o pode mudar, mas o objeto pode ser modificado
    */
   private final Configuracao config;
   ```

3. **C√≥pia defensiva**:
   ```java
   public MinhaClasse(final Map<String, Integer> valores) {
       this.valores = new HashMap<>(valores);
   }
   ```

4. **Classes utilit√°rias**:
   ```java
   public final class MathUtils {
       private MathUtils() {} // Previne instancia√ß√£o
   }
   ```

## ‚ùå Piores Pr√°ticas (Evitar)

1. **Expor estado interno**:
   ```java
   public final class Caixa {
       private final List<Item> itens;
       
       public List<Item> getItens() {
           return itens; // ‚ùå Exp√µe lista mut√°vel
       }
   }
   ```

2. **Assumir imutabilidade**:
   ```java
   final int[] valores = {1, 2, 3};
   valores[0] = 10; // ‚ùå Permitido (pode causar bugs)
   ```

3. **Uso redundante**:
   ```java
   public void salvar(final String texto) { // ‚ùå Desnecess√°rio se n√£o reatribu√≠do
       arquivo.write(texto);
   }
   ```

4. **Vazamento de refer√™ncia**:
   ```java
   public class Exemplo {
       final int x;
       
       public Exemplo() {
           this.x = 10;
           registrar(this); // ‚ùå 'this' vaza antes da inicializa√ß√£o completa
       }
   }
   ```

## üîç T√©cnicas Avan√ßadas

1. **Classes seladas (Java 17+)**:
   ```java
   public sealed class Forma permits Circulo, Quadrado {}
   ```

2. **Records (Java 16+)**:
   ```java
   public record Pessoa(String nome, int idade) {} // Campos implicitamente final
   ```

3. **M√©todos final**:
   ```java
   public class Pai {
       public final void metodo() {} // N√£o pode ser sobrescrito
   }
   ```

4. **VarHandle para atomicidade**:
   ```java
   private static final VarHandle CONTADOR;
   static {
       try {
           CONTADOR = MethodHandles.lookup().findVarHandle(...);
       } catch (Exception e) { ... }
   }
   ```

5. **Pattern Matching (Java 17+)**:
   ```java
   if(obj instanceof final String s) {
       System.out.println(s.toLowerCase());
   }
   ```


[Voltar ao √çndice](#indice)

---


## <a name="parte82">82 - 079 - Orienta√ß√£o Objetos - Modificador final pt 03 - Classes e m√©todos</a>

# Resumo: Modificador `final` em Classes e M√©todos Java

## üìå Vis√£o Geral
A aula explora o uso do modificador `final` em classes e m√©todos, destacando que:
- **Classes final**: N√£o podem ser estendidas/herdadas
- **M√©todos final**: N√£o podem ser sobrescritos por subclasses
- Objetivos principais: seguran√ßa, design intencional e otimiza√ß√£o

## üìã Exemplos B√°sicos

### 1. Classe Final (N√£o pode ser herdada)
```java
public final class String { // Classe core do Java
    // implementa√ß√£o...
}

// class MinhaString extends String {} // ‚ùå Erro de compila√ß√£o
```

### 2. M√©todo Final (N√£o pode ser sobrescrito)
```java
class Pagamento {
    public final void processar() { // Bloqueia sobrescrita
        System.out.println("Processamento base");
    }
}

class PagamentoCartao extends Pagamento {
    // @Override public void processar() {} // ‚ùå Erro
}
```

## üèóÔ∏è Exemplos Complexos

### 1. Padr√£o Template Method com final
```java
public abstract class TemplateProcessamento {
    // M√©todo final que define o fluxo
    public final void executarFluxo() {
        iniciar();
        processar(); // M√©todo abstrato
        finalizar();
    }
    
    protected abstract void processar(); // Hook method
    
    private void iniciar() { /* implementa√ß√£o */ }
    private void finalizar() { /* implementa√ß√£o */ }
}
```

### 2. Hierarquia de Classes Imut√°veis
```java
public final class EnderecoImutavel {
    private final String rua;
    private final int numero;
    
    public EnderecoImutavel(String rua, int numero) {
        this.rua = rua;
        this.numero = numero;
    }
    // Apenas getters
}

// N√£o pode ser estendida (final)
```

## ‚úÖ Melhores Pr√°ticas

1. **Use final para classes utilit√°rias**:
   ```java
   public final class MathUtils {
       private MathUtils() {} // Construtor privado
       public static double calcular(...) { ... }
   }
   ```

2. **Documente a inten√ß√£o**:
   ```java
   /**
    * @final Esta classe n√£o deve ser estendida
    * pois implementa algoritmo cr√≠tico
    */
   public final class AlgoritmoSeguro { ... }
   ```

3. **Combine com sealed classes (Java 17+)**:
   ```java
   public sealed class Forma permits Circulo, Quadrado { ... }
   ```

4. **Para m√©todos cr√≠ticos**:
   ```java
   public class Autenticador {
       public final boolean validarCredenciais(...) { ... }
   }
   ```

5. **Em frameworks**:
   ```java
   public abstract class ServicoBase {
       public final void iniciar() { ... } // Fluxo fixo
   }
   ```

## ‚ùå Piores Pr√°ticas (Evitar)

1. **Usar final sem motivo**:
   ```java
   public final class ClasseQualquer {} // ‚ùå Sem raz√£o clara
   ```

2. **Impedir extensibilidade √∫til**:
   ```java
   public final class MinhaLista {} // ‚ùå Pode limitar reuso
   ```

3. **M√©todos final em classes abstratas**:
   ```java
   public abstract class Figura {
       public final void desenhar() { ... } // ‚ùå Contradit√≥rio
   }
   ```

4. **Quebrar LSP (Princ√≠pio de Substitui√ß√£o)**:
   ```java
   class Pai {
       public final void metodo() { ... }
   }
   class Filha extends Pai {
       // N√£o pode sobrescrever m√©todo necess√°rio
   }
   ```

5. **Ignorar alternativas modernas**:
   ```java
   // Preferir:
   public sealed class Animal permits Cachorro, Gato {}
   // Em vez de:
   public final class Animal {}
   ```

## üîç T√©cnicas Avan√ßadas

1. **Records (Java 16+)**:
   ```java
   public record Pessoa(String nome, int idade) {} 
   // Implicitamente final
   ```

2. **Enums com m√©todos final**:
   ```java
   public enum Nivel {
       BASIC {
           @Override final void show() { ... }
       };
       abstract void show();
   }
   ```

3. **Padr√£o Strategy com final**:
   ```java
   public final class PagamentoCredito implements EstrategiaPagamento {
       @Override public final void pagar() { ... }
   }
   ```

4. **Inje√ß√£o de Depend√™ncia**:
   ```java
   @Service
   public final class ServicoEmail {
       // Garante que ningu√©m altere o comportamento
       public final void enviar(...) { ... }
   }
   ```

5. **Classes de Utilidade**:
   ```java
   public final class Strings {
       private Strings() {}
       public static boolean isBlank(String s) { ... }
   }
   ```


[Voltar ao √çndice](#indice)

---


## <a name="parte83">83 - 080 - Orienta√ß√£o Objetos - Enumera√ß√£o pt 01 - Introdu√ß√£o</a>

```java
package dominio;

public enum dominio.TipoCliente {
    PESSOA_FISCA, PESSOA_JURIDICA
}

```

```java
import dominio.TipoCliente;

public class Cliente {
    private String nome;
    private TipoCliente tipoCliente;

    public Cliente(String nome, TipoCliente tipoCliente) {
        this.nome = nome;
        this.tipoCliente = tipoCliente;
    }

```

```java
import dominio.TipoCliente;

public class ClienteTeste01 {
    public static void main(String[] args) {
        Cliente cliente1 = new Cliente("Tsubasa", TipoCliente.PESSOA_FISCA);
        Cliente cliente2 = new Cliente("Tsubasa", TipoCliente.PESSOA_JURIDICA);
        Cliente cliente3 = new Cliente("Tsubasa", TipoCliente.PESSOA_FISCA);
        Cliente cliente4 = new Cliente("Tsubasa", TipoCliente.PESSOA_JURIDICA);

```

---

Resumo GEMINI

## Resumo sobre Enumera√ß√µes (Enums) em Java ‚òï

Enumera√ß√µes em Java (declaradas com a palavra-chave `enum`) s√£o um tipo de dado especial usado para definir um conjunto de **constantes nomeadas**. Elas s√£o muito √∫teis quando voc√™ tem um n√∫mero fixo de valores que uma vari√°vel pode assumir, como dias da semana, naipes de um baralho, ou estados de um pedido.

Em ess√™ncia, um `enum` √© uma **classe especial**. Os valores definidos em um `enum` s√£o **inst√¢ncias** dessa classe `enum`. Isso significa que `enums` podem ter construtores, campos (vari√°veis) e m√©todos, tornando-os muito mais poderosos do que as constantes est√°ticas (`public static final`) tradicionais.

---

### Exemplos de C√≥digo

#### Exemplo B√°sico: Dias da Semana

```java
public enum DiaSemana {
    DOMINGO,
    SEGUNDA,
    TERCA,
    QUARTA,
    QUINTA,
    SEXTA,
    SABADO
}

public class TesteEnumBasico {
    public static void main(String[] args) {
        DiaSemana hoje = DiaSemana.SEXTA;
        System.out.println("Hoje √©: " + hoje); // Sa√≠da: Hoje √©: SEXTA

        // Iterando sobre os valores do enum
        System.out.println("\nDias da semana:");
        for (DiaSemana dia : DiaSemana.values()) {
            System.out.println(dia);
        }

        // Usando enum em um switch
        switch (hoje) {
            case SEGUNDA:
                System.out.println("\nCome√ßo da semana de trabalho.");
                break;
            case SEXTA:
                System.out.println("\nSextou!");
                break;
            default:
                System.out.println("\nUm dia qualquer.");
        }
    }
}
```

#### Exemplo Complexo: Planetas com Atributos e M√©todos

Neste exemplo, cada constante do `enum` `Planeta` ter√° atributos (massa e raio) e um m√©todo para calcular a gravidade superficial.

```java
public enum Planeta {
    MERCURIO (3.303e+23, 2.4397e6),
    VENUS    (4.869e+24, 6.0518e6),
    TERRA    (5.976e+24, 6.37814e6),
    MARTE    (6.421e+23, 3.3972e6),
    JUPITER  (1.9e+27,   7.1492e7),
    SATURNO  (5.688e+26, 6.0268e7),
    URANO    (8.686e+25, 2.5559e7),
    NETUNO   (1.024e+26, 2.4746e7);

    private final double massa;   // em quilogramas
    private final double raio;    // em metros
    public static final double G = 6.67300E-11; // Constante gravitacional

    Planeta(double massa, double raio) {
        this.massa = massa;
        this.raio = raio;
    }

    public double getMassa() {
        return massa;
    }

    public double getRaio() {
        return raio;
    }

    public double gravidadeSuperficial() {
        return G * massa / (raio * raio);
    }

    public double pesoSuperficial(double outraMassa) {
        return outraMassa * gravidadeSuperficial();
    }
}

public class TesteEnumComplexo {
    public static void main(String[] args) {
        double pesoNaTerra = 75.0; // kg

        for (Planeta p : Planeta.values()) {
            System.out.printf("Seu peso em %s √© %.2f N%n",
                              p, p.pesoSuperficial(pesoNaTerra));
            System.out.printf("A gravidade superficial de %s √© %.2f m/s^2%n%n",
                              p, p.gravidadeSuperficial());
        }

        Planeta meuPlaneta = Planeta.TERRA;
        System.out.println("Meu planeta: " + meuPlaneta);
        System.out.println("Massa do meu planeta: " + meuPlaneta.getMassa() + " kg");
    }
}
```

---

### Melhores Pr√°ticas (O que fazer üëç)

1.  **Use `enums` em vez de constantes `int` ou `String`**: `Enums` fornecem seguran√ßa de tipo (type safety). Com constantes `int`, voc√™ pode acidentalmente passar um valor inv√°lido. `Enums` garantem que apenas os valores definidos sejam usados.
    ```java
    // Ruim: usando constantes int
    public static final int ESTADO_PENDENTE = 0;
    public static final int ESTADO_APROVADO = 1;
    public static final int ESTADO_REJEITADO = 2;
    // void processarPedido(int estado) { ... }

    // Bom: usando enum
    public enum EstadoPedido { PENDENTE, APROVADO, REJEITADO }
    // void processarPedido(EstadoPedido estado) { ... }
    ```
2.  **Nomeie as constantes `enum` em MAI√öSCULAS**: Por conven√ß√£o, constantes em Java (incluindo valores de `enum`) s√£o nomeadas com todas as letras mai√∫sculas, com palavras separadas por underscores (`_`).
    ```java
    public enum Cor { VERMELHO, VERDE_ESCURO, AZUL_CELESTE }
    ```
3.  **Use `enums` em instru√ß√µes `switch`**: `Enums` funcionam muito bem com `switch`, tornando o c√≥digo mais leg√≠vel.
    ```java
    Nivel prioridade = Nivel.ALTO;
    switch (prioridade) {
        case BAIXO:
            System.out.println("Prioridade baixa.");
            break;
        case MEDIO:
            System.out.println("Prioridade m√©dia.");
            break;
        case ALTO:
            System.out.println("Prioridade alta.");
            break;
    }
    ```
4.  **Adicione campos e m√©todos aos `enums` quando necess√°rio**: Como mostrado no exemplo `Planeta`, `enums` podem ter construtores, campos e m√©todos, permitindo que voc√™ associe dados e comportamento a cada constante. O construtor de um `enum` deve ser `private` ou package-private (o padr√£o).
5.  **Use `EnumSet` e `EnumMap` para cole√ß√µes de `enums`**: Se voc√™ precisa de um `Set` ou `Map` cujas chaves s√£o `enums`, `EnumSet` e `EnumMap` s√£o implementa√ß√µes altamente otimizadas.
    ```java
    import java.util.EnumSet;
    import java.util.EnumMap;
    import java.util.Map;

    public enum DiaUtil { SEGUNDA, TERCA, QUARTA, QUINTA, SEXTA }

    // EnumSet
    EnumSet<DiaUtil> diasDeTrabalho = EnumSet.of(DiaUtil.SEGUNDA, DiaUtil.TERCA, DiaUtil.QUARTA);

    // EnumMap
    EnumMap<DiaUtil, String> tarefas = new EnumMap<>(DiaUtil.class);
    tarefas.put(DiaUtil.SEGUNDA, "Reuni√£o de planejamento");
    ```
6.  **Implemente interfaces com `enums`**: `Enums` podem implementar interfaces, permitindo que voc√™ trate diferentes `enums` de forma polim√≥rfica.
    ```java
    public interface Mensageiro {
        String getMensagemFormatada();
    }

    public enum TipoNotificacao implements Mensageiro {
        EMAIL {
            @Override
            public String getMensagemFormatada() { return "Email: "; }
        },
        SMS {
            @Override
            public String getMensagemFormatada() { return "SMS: "; }
        };
    }
    ```
7.  **Prefira `==` para comparar `enums`**: Como `enums` s√£o inst√¢ncias √∫nicas (singletons), voc√™ pode usar o operador `==` para compar√°-los com seguran√ßa e efici√™ncia. `equals()` tamb√©m funciona e faz a mesma coisa para `enums`.
    ```java
    DiaSemana dia1 = DiaSemana.SEGUNDA;
    DiaSemana dia2 = DiaSemana.SEGUNDA;
    if (dia1 == dia2) { // true
        System.out.println("S√£o o mesmo dia.");
    }
    ```

---

### Piores Pr√°ticas (O que evitar üëé)

1.  **N√£o use `ordinal()` para l√≥gica de neg√≥cios**: O m√©todo `ordinal()` retorna a posi√ß√£o de uma constante `enum` em sua declara√ß√£o (come√ßando em 0). Confiar nesse valor √© perigoso, pois se a ordem das constantes mudar, seu c√≥digo quebrar√°. Se precisar de um valor associado, adicione um campo ao `enum`.
    ```java
    public enum Prioridade {
        BAIXA, // ordinal() == 0
        MEDIA, // ordinal() == 1
        ALTA   // ordinal() == 2
    }

    // Ruim:
    // if (prioridade.ordinal() == 0) { ... }

    // Bom (se precisar de um valor num√©rico associado):
    public enum PrioridadeComValor {
        BAIXA(1),
        MEDIA(5),
        ALTA(10);

        private final int valor;
        PrioridadeComValor(int valor) { this.valor = valor; }
        public int getValor() { return valor; }
    }
    // if (prioridade.getValor() == 1) { ... }
    ```
2.  **Evite `enums` muito grandes ou com responsabilidades demais**: Se um `enum` come√ßa a ficar muito complexo, com muitos m√©todos ou l√≥gica que n√£o est√° diretamente relacionada √†s suas constantes, pode ser um sinal de que voc√™ precisa refatorar para classes separadas.
3.  **N√£o tente estender um `enum`**: `Enums` implicitamente herdam de `java.lang.Enum` e n√£o podem herdar de outra classe. (Eles podem, no entanto, implementar interfaces).
4.  **Evite expor construtores p√∫blicos**: Construtores de `enum` devem ser `private` (ou package-private). O compilador os chama automaticamente para criar as inst√¢ncias das constantes definidas. Voc√™ n√£o deve instanciar `enums` com `new`.
5.  **Cuidado ao serializar `enums` que mudam frequentemente**: Se voc√™ serializa um `enum` e depois adiciona, remove ou reordena constantes, pode ter problemas de desserializa√ß√£o. Usar nomes (`toString()`) para persist√™ncia em vez de ordinais pode ser mais robusto, mas ainda requer cuidado. Se os valores associados (como IDs para banco de dados) s√£o importantes, defina-os explicitamente.
6.  **N√£o use `enums` para substituir qualquer conjunto de constantes**: Se as "constantes" podem mudar dinamicamente ou se h√° um n√∫mero ilimitado delas, um `enum` n√£o √© a escolha apropriada. `Enums` s√£o para conjuntos *fixos* de valores conhecidos em tempo de compila√ß√£o.

Lembre-se que o objetivo principal dos `enums` √© melhorar a legibilidade e a seguran√ßa do tipo do seu c√≥digo, representando um conjunto fixo de constantes de forma clara e robusta.


[Voltar ao √çndice](#indice)

---


## <a name="parte84">84 - 081 - Orienta√ß√£o Objetos - Enumera√ß√£o pt 02 - Construtores e atributos</a>

```java
package dominio;

public enum TipoCliente {
    PESSOA_FISICA(1, "Pessoa Fisica"),
    PESSOA_JURIDICA(2, "Pessoa Juridica");

    private int valor;
    public String nomeRelatorio;

    TipoCliente(int valor, String nomeRelatorio) {
        this.valor = valor;
        this.nomeRelatorio = nomeRelatorio;
    }

    public int getValor() {
        return valor;
    }

    public String getNomeRelatorio() {
        return nomeRelatorio;
    }
}

```

```java
package dominio;

public class Cliente {

    public enum TipoPagamento {
        DEBITO,
        CREDITO
    }

    private String nome;
    private TipoCliente tipoCliente;
    private TipoPagamento tipoPagamento;

    public Cliente(String nome, TipoCliente tipoCliente, TipoPagamento tipoPagamento) {
        this.nome = nome;
        this.tipoCliente = tipoCliente;
        this.tipoPagamento = tipoPagamento;
    }

    @Override
    public String toString() {
        return "Cliente{" +
                "nome='" + nome + '\'' +
                ", tipoCliente=" + tipoCliente +
                ", tipoClienteValor=" + tipoCliente.getValor() +
                ", tipoClienteNomeRelatorio=" + tipoCliente.getNomeRelatorio() +
                ", tipoPagamento=" + tipoPagamento +
                '}';
    }
}

```

--

### RESUMO DA GEMINI

## Construtores e Atributos em Enumera√ß√µes Java ‚òï

Continuando o estudo de `enums` em Java, esta parte foca em como adicionar **construtores e atributos** √†s suas enumera√ß√µes, tornando-as ainda mais poderosas e capazes de armazenar dados e comportamentos espec√≠ficos para cada constante.

Quando voc√™ define atributos em um `enum`, cada constante da enumera√ß√£o pode ter seus pr√≥prios valores para esses atributos. Esses valores s√£o tipicamente passados atrav√©s de um **construtor**, que √© chamado automaticamente quando cada constante do `enum` √© criada.

---

### Pontos Principais: Construtores e Atributos em Enums

1.  **Atributos (Campos)**:
    * Voc√™ pode declarar campos (vari√°veis de inst√¢ncia) dentro de um `enum`, assim como faria em uma classe normal.
    * Esses campos geralmente s√£o `private` e `final` para garantir que os dados associados a cada constante do `enum` sejam imut√°veis ap√≥s a cria√ß√£o.

2.  **Construtores**:
    * Construtores em `enums` s√£o sempre **`private`** (ou package-private, o padr√£o, mas `private` √© a conven√ß√£o mais forte). Voc√™ n√£o pode declarar um construtor de `enum` como `public` ou `protected`.
    * O construtor √© chamado uma vez para cada constante definida no `enum` no momento em que a classe do `enum` √© carregada.
    * Voc√™ n√£o chama o construtor do `enum` explicitamente com `new`; o compilador faz isso por voc√™ quando encontra as declara√ß√µes das constantes.
    * Se voc√™ definir um construtor com par√¢metros, dever√° fornecer os argumentos para esses par√¢metros ao declarar cada constante do `enum`.

3.  **M√©todos**:
    * Voc√™ pode adicionar m√©todos ao `enum` para operar sobre os atributos ou fornecer funcionalidades relacionadas √†s constantes. Por exemplo, m√©todos `getter` s√£o comuns para acessar os valores dos atributos.

---

### Exemplos de C√≥digo

#### Exemplo B√°sico: Tipo de Cliente com C√≥digo

```java
public enum TipoCliente {
    PESSOA_FISICA(1, "Pessoa F√≠sica"), // Chama o construtor TipoCliente(1, "Pessoa F√≠sica")
    PESSOA_JURIDICA(2, "Pessoa Jur√≠dica"); // Chama o construtor TipoCliente(2, "Pessoa Jur√≠dica")

    private final int codigo;
    private final String descricao;

    // Construtor √© implicitamente private
    TipoCliente(int codigo, String descricao) {
        this.codigo = codigo;
        this.descricao = descricao;
    }

    public int getCodigo() {
        return codigo;
    }

    public String getDescricao() {
        return descricao;
    }

    // Opcional: sobrescrever toString para uma representa√ß√£o mais amig√°vel
    @Override
    public String toString() {
        return codigo + " - " + descricao;
    }
}

public class TesteTipoCliente {
    public static void main(String[] args) {
        TipoCliente pf = TipoCliente.PESSOA_FISICA;
        System.out.println("Tipo: " + pf.name()); // Sa√≠da: PESSOA_FISICA
        System.out.println("C√≥digo: " + pf.getCodigo()); // Sa√≠da: 1
        System.out.println("Descri√ß√£o: " + pf.getDescricao()); // Sa√≠da: Pessoa F√≠sica
        System.out.println("Representa√ß√£o: " + pf); // Sa√≠da: 1 - Pessoa F√≠sica (devido ao toString)

        TipoCliente pj = TipoCliente.PESSOA_JURIDICA;
        System.out.println("\nTipo: " + pj.name()); // Sa√≠da: PESSOA_JURIDICA
        System.out.println("C√≥digo: " + pj.getCodigo()); // Sa√≠da: 2
        System.out.println("Descri√ß√£o: " + pj.getDescricao()); // Sa√≠da: Pessoa Jur√≠dica
        System.out.println("Representa√ß√£o: " + pj); // Sa√≠da: 2 - Pessoa Jur√≠dica

        // Obtendo um enum pelo nome (√∫til para deserializa√ß√£o ou input de usu√°rio)
        String tipoInput = "PESSOA_FISICA";
        TipoCliente tipoEncontrado = TipoCliente.valueOf(tipoInput);
        System.out.println("\nEncontrado pelo nome: " + tipoEncontrado.getDescricao());
    }
}
```

#### Exemplo Mais Elaborado: Status de Pagamento com L√≥gica

```java
public enum StatusPagamento {
    PENDENTE(1, "Aguardando Pagamento") {
        @Override
        public boolean podeCancelar() {
            return true;
        }
        @Override
        public String proximoPassoPossivel() {
            return "Realizar pagamento ou cancelar.";
        }
    },
    PAGO(2, "Pagamento Confirmado") {
        @Override
        public boolean podeCancelar() {
            return false; // N√£o pode cancelar ap√≥s pago, talvez estornar
        }
        @Override
        public String proximoPassoPossivel() {
            return "Aguardar envio do produto.";
        }
    },
    CANCELADO(3, "Pagamento Cancelado") {
        @Override
        public boolean podeCancelar() {
            return false;
        }
        @Override
        public String proximoPassoPossivel() {
            return "Nenhuma a√ß√£o pendente.";
        }
    },
    ESTORNADO(4, "Pagamento Estornado") {
        @Override
        public boolean podeCancelar() {
            return false;
        }
        @Override
        public String proximoPassoPossivel() {
            return "Nenhuma a√ß√£o pendente.";
        }
    }; // Ponto e v√≠rgula aqui √© OBRIGAT√ìRIO se houver m√©todos ou campos ap√≥s as constantes

    private final int id;
    private final String textoDisplay;

    // Construtor (private por padr√£o)
    StatusPagamento(int id, String textoDisplay) {
        this.id = id;
        this.textoDisplay = textoDisplay;
    }

    public int getId() {
        return id;
    }

    public String getTextoDisplay() {
        return textoDisplay;
    }

    // M√©todos abstratos para serem implementados por cada constante (corpo espec√≠fico da constante)
    public abstract boolean podeCancelar();
    public abstract String proximoPassoPossivel();

    // M√©todo comum a todos
    public void imprimirStatusDetalhado() {
        System.out.println("Status: " + getTextoDisplay() + " (ID: " + getId() + ")");
        System.out.println("  Pode cancelar? " + (podeCancelar() ? "Sim" : "N√£o"));
        System.out.println("  Pr√≥ximo passo: " + proximoPassoPossivel());
    }
}

public class TesteStatusPagamento {
    public static void main(String[] args) {
        StatusPagamento status1 = StatusPagamento.PENDENTE;
        status1.imprimirStatusDetalhado();
        /*
        Sa√≠da:
        Status: Aguardando Pagamento (ID: 1)
          Pode cancelar? Sim
          Pr√≥ximo passo: Realizar pagamento ou cancelar.
        */

        System.out.println("---");

        StatusPagamento status2 = StatusPagamento.PAGO;
        status2.imprimirStatusDetalhado();
        /*
        Sa√≠da:
        Status: Pagamento Confirmado (ID: 2)
          Pode cancelar? N√£o
          Pr√≥ximo passo: Aguardar envio do produto.
        */
    }
}
```
Neste exemplo `StatusPagamento`, cada constante do `enum` n√£o s√≥ tem seus pr√≥prios valores para `id` e `textoDisplay`, mas tamb√©m fornece uma implementa√ß√£o espec√≠fica para os m√©todos abstratos `podeCancelar()` e `proximoPassoPossivel()`. Isso √© chamado de **corpo espec√≠fico da constante** (constant-specific body).

---

### Melhores Pr√°ticas (O que fazer üëç)

1.  **Declare atributos como `private final`**: Isso garante que os dados associados a cada constante sejam imut√°veis e encapsulados.
2.  **Forne√ßa `getters` para os atributos**: Se os atributos precisam ser acessados de fora do `enum`, forne√ßa m√©todos `public getter`. Evite `setters` para manter a imutabilidade.
3.  **Mantenha construtores `private`**: Isso √© imposto pelo Java para `enums`, mas √© uma boa pr√°tica refor√ßar que `enums` n√£o s√£o instanciados como classes normais.
4.  **Use o ponto e v√≠rgula (`;`) ap√≥s a lista de constantes se houver membros subsequentes**: Se o seu `enum` tem apenas constantes, o ponto e v√≠rgula √© opcional. Mas se voc√™ adicionar campos, m√©todos ou construtores, o ponto e v√≠rgula ap√≥s a √∫ltima constante √© obrigat√≥rio.
    ```java
    public enum Opcao {
        SIM, NAO; // Ponto e v√≠rgula obrigat√≥rio aqui se adicionar mais membros

        // Exemplo: um m√©todo
        public boolean isAfirmativo() {
            return this == SIM;
        }
    }
    ```
5.  **Sobrescreva `toString()` para representa√ß√µes amig√°veis**: Por padr√£o, `toString()` retorna o nome da constante (ex: "PESSOA_FISICA"). Se uma representa√ß√£o mais leg√≠vel para o usu√°rio ou para logs for necess√°ria, sobrescreva `toString()`.
6.  **Use corpos espec√≠ficos de constante (Constant-Specific Bodies) para comportamento variado**: Se diferentes constantes do `enum` precisam se comportar de maneiras ligeiramente diferentes para o mesmo m√©todo, voc√™ pode declarar o m√©todo (possivelmente abstrato) no `enum` e fazer com que cada constante o sobrescreva. Isso √© uma forma poderosa de polimorfismo dentro de um `enum`.

---

### Piores Pr√°ticas (O que evitar üëé)

1.  **Atributos mut√°veis**: Evite atributos que n√£o sejam `final`, pois isso quebra a ideia de que as constantes do `enum` s√£o, de fato, constantes e imut√°veis.
    ```java
    // Ruim: atributo mut√°vel
    public enum Nivel {
        BAIXO(1), MEDIO(2), ALTO(3);
        public int valor; // N√£o final, e p√∫blico!
        Nivel(int v) { this.valor = v; }
    }
    ```
2.  **Construtores `public` ou `protected`**: O compilador n√£o permite isso, mas a tentativa indica um mal-entendido de como `enums` s√£o instanciados.
3.  **Confiar em `ordinal()` quando atributos podem fazer o trabalho**: Se voc√™ precisa de um valor num√©rico ou outro dado associado a uma constante, defina um atributo para isso em vez de depender da ordem de declara√ß√£o (`ordinal()`).
4.  **Sobrecarga de responsabilidades**: N√£o transforme um `enum` em uma classe massiva com in√∫meros atributos e m√©todos complexos que poderiam ser melhor gerenciados por classes dedicadas. `Enums` s√£o para representar um conjunto fixo de constantes relacionadas, com dados e comportamentos associados a *essas constantes*.
5.  **Esquecer o ponto e v√≠rgula (`;`)** quando necess√°rio: Se o `enum` cont√©m qualquer coisa al√©m das pr√≥prias constantes (campos, m√©todos, construtores), voc√™ deve terminar a lista de constantes com um ponto e v√≠rgula. A falta dele causar√° um erro de compila√ß√£o.

Ao usar construtores e atributos, os `enums` em Java se tornam uma ferramenta muito expressiva para modelar tipos de dados que representam um conjunto fixo de valores, cada um com suas pr√≥prias caracter√≠sticas e comportamentos.

[Voltar ao √çndice](#indice)

---


## <a name="parte85">85 - 082 - Orienta√ß√£o Objetos - Enumera√ß√£o pt 03 - Sobrescrita de m√©todos</a>

```java
package dominio;

public enum TipoPagamento {
    DEBITO{
        @Override
        public double calculaDesconto(double valor) {
            return valor * 0.1;

        }
    },
    CREDITO{
        @Override
        public double calculaDesconto(double valor) {
            return valor * 0.5;
        }
    };
    public abstract double calculaDesconto(double valor) ;
}
```

```java
        System.out.println(TipoPagamento.DEBITO.calculaDesconto(100));
        System.out.println(TipoPagamento.CREDITO.calculaDesconto(100));
```

---

### RESUMO GEMINI

## Sobrescrita de M√©todos em Enumera√ß√µes Java ‚òï

A capacidade de **sobrescrever m√©todos** em `enums` em Java adiciona uma camada significativa de flexibilidade e poder, permitindo que cada constante da enumera√ß√£o tenha comportamentos espec√≠ficos. Isso √© particularmente √∫til quando diferentes constantes precisam reagir de maneiras distintas a uma mesma chamada de m√©todo.

Existem duas formas principais de sobrescrita de m√©todos em `enums`:

1.  **Sobrescrever m√©todos da classe `java.lang.Enum` (ou `Object`)**: O mais comum √© sobrescrever o m√©todo `toString()` para fornecer uma representa√ß√£o textual mais amig√°vel da constante do `enum`.
2.  **Corpos de M√©todo Espec√≠ficos da Constante (Constant-Specific Method Bodies)**: Voc√™ pode declarar um m√©todo (concreto ou abstrato) no `enum` e, em seguida, fornecer uma implementa√ß√£o diferente para esse m√©todo dentro de cada constante espec√≠fica. Isso permite um comportamento polim√≥rfico dentro do pr√≥prio `enum`.

---

### Pontos Principais: Sobrescrita de M√©todos em Enums

* **Sobrescrevendo `toString()`**: Por padr√£o, `toString()` retorna o nome da constante como declarado (ex: `SEGUNDA_FEIRA`). Voc√™ pode sobrescrev√™-lo para retornar algo mais descritivo ou formatado.
* **M√©todos Abstratos no Enum**: Voc√™ pode declarar m√©todos abstratos dentro do seu `enum`. Se fizer isso, cada constante do `enum` **deve** fornecer uma implementa√ß√£o para esses m√©todos abstratos. Isso for√ßa cada constante a definir seu pr√≥prio comportamento.
* **M√©todos Concretos com Implementa√ß√£o Espec√≠fica da Constante**: Voc√™ pode ter um m√©todo concreto no `enum` com uma implementa√ß√£o padr√£o e, opcionalmente, sobrescrev√™-lo para constantes espec√≠ficas que necessitem de um comportamento diferente.
* **Sintaxe**: Para fornecer uma implementa√ß√£o espec√≠fica da constante, voc√™ abre chaves `{}` ap√≥s a declara√ß√£o da constante e implementa o m√©todo ali. √â necess√°rio um ponto e v√≠rgula (`;`) ap√≥s a √∫ltima constante se o `enum` contiver campos, m√©todos ou construtores adicionais.

---

### Exemplos de C√≥digo

#### Exemplo B√°sico: Sobrescrevendo `toString()`

```java
public enum DiaDaSemana {
    DOMINGO("Domingo"),
    SEGUNDA("Segunda-feira"),
    TERCA("Ter√ßa-feira"),
    QUARTA("Quarta-feira"),
    QUINTA("Quinta-feira"),
    SEXTA("Sexta-feira"),
    SABADO("S√°bado");

    private final String nomeFormatado;

    DiaDaSemana(String nomeFormatado) {
        this.nomeFormatado = nomeFormatado;
    }

    // Getter para o nome formatado (opcional, dependendo da necessidade)
    public String getNomeFormatado() {
        return nomeFormatado;
    }

    // Sobrescrevendo toString() para retornar o nomeFormatado
    @Override
    public String toString() {
        return nomeFormatado;
    }
}

public class TesteToStringEnum {
    public static void main(String[] args) {
        DiaDaSemana hoje = DiaDaSemana.SEXTA;
        System.out.println("Hoje √©: " + hoje); // Sa√≠da: Hoje √©: Sexta-feira
        System.out.println("Nome original da constante: " + hoje.name()); // Sa√≠da: Nome original da constante: SEXTA
        System.out.println("Nome formatado (via getter): " + hoje.getNomeFormatado()); // Sa√≠da: Nome formatado (via getter): Sexta-feira
    }
}
```

#### Exemplo Complexo: Opera√ß√µes Matem√°ticas com Implementa√ß√µes Espec√≠ficas da Constante

Neste exemplo, cada constante do `enum` `Operacao` representa uma opera√ß√£o matem√°tica e implementa um m√©todo abstrato `executar`.

```java
public enum Operacao {
    SOMA {
        @Override
        public double executar(double x, double y) {
            return x + y;
        }
        @Override
        public String getSimbolo() {
            return "+";
        }
    },
    SUBTRACAO {
        @Override
        public double executar(double x, double y) {
            return x - y;
        }
        @Override
        public String getSimbolo() {
            return "-";
        }
    },
    MULTIPLICACAO {
        @Override
        public double executar(double x, double y) {
            return x * y;
        }
        @Override
        public String getSimbolo() {
            return "*";
        }
    },
    DIVISAO {
        @Override
        public double executar(double x, double y) {
            if (y == 0) {
                throw new ArithmeticException("Divis√£o por zero!");
            }
            return x / y;
        }
        @Override
        public String getSimbolo() {
            return "/";
        }
    }; // Ponto e v√≠rgula obrigat√≥rio aqui

    // M√©todo abstrato que cada constante deve implementar
    public abstract double executar(double x, double y);
    public abstract String getSimbolo(); // Outro m√©todo abstrato para o s√≠mbolo da opera√ß√£o

    // M√©todo concreto que pode usar os m√©todos espec√≠ficos da constante
    public void exibirCalculo(double x, double y) {
        try {
            System.out.printf("%.2f %s %.2f = %.2f%n", x, getSimbolo(), y, executar(x, y));
        } catch (ArithmeticException e) {
            System.err.println("Erro ao calcular " + x + " " + getSimbolo() + " " + y + ": " + e.getMessage());
        }
    }
}

public class TesteOperacaoEnum {
    public static void main(String[] args) {
        double x = 10.0;
        double y = 5.0;

        Operacao.SOMA.exibirCalculo(x, y);         // Sa√≠da: 10.00 + 5.00 = 15.00
        Operacao.SUBTRACAO.exibirCalculo(x, y);    // Sa√≠da: 10.00 - 5.00 = 5.00
        Operacao.MULTIPLICACAO.exibirCalculo(x, y); // Sa√≠da: 10.00 * 5.00 = 50.00
        Operacao.DIVISAO.exibirCalculo(x, y);      // Sa√≠da: 10.00 / 5.00 = 2.00
        Operacao.DIVISAO.exibirCalculo(x, 0);      // Sa√≠da: Erro ao calcular 10.0 / 0.0: Divis√£o por zero!

        System.out.println("\nIterando e executando:");
        for (Operacao op : Operacao.values()) {
            System.out.printf("Resultado de 8 %s 2: %.2f%n", op.getSimbolo(), op.executar(8, 2));
        }
    }
}
```

---

### Melhores Pr√°ticas (O que fazer üëç)

1.  **Sobrescreva `toString()` para clareza**: Se a representa√ß√£o padr√£o do nome da constante n√£o for ideal para logs ou interface do usu√°rio, forne√ßa uma sobrescrita de `toString()`.
2.  **Use m√©todos abstratos para for√ßar implementa√ß√µes espec√≠ficas**: Se cada constante *deve* ter um comportamento √∫nico para um determinado m√©todo, declare o m√©todo como `abstract` no `enum`. Isso garante que todas as constantes forne√ßam sua pr√≥pria l√≥gica.
3.  **Utilize corpos espec√≠ficos da constante para variar comportamento**: Esta √© uma maneira elegante de implementar o padr√£o Strategy ou State dentro de um `enum`. Cada constante se torna uma "estrat√©gia" ou "estado" com seu pr√≥prio comportamento.
4.  **Mantenha a l√≥gica coesa**: A l√≥gica dentro dos m√©todos espec√≠ficos da constante deve estar relacionada √† responsabilidade daquela constante. Se ficar muito complexa, pode ser um sinal de que o `enum` est√° fazendo demais.
5.  **Ponto e v√≠rgula obrigat√≥rio**: Lembre-se do ponto e v√≠rgula (`;`) ap√≥s a √∫ltima declara√ß√£o de constante se o `enum` contiver quaisquer membros (campos, m√©todos, construtores, ou corpos espec√≠ficos da constante).
6.  **Combine com atributos**: Atributos podem ser usados em conjunto com m√©todos sobrescritos para fornecer dados que influenciam o comportamento espec√≠fico da constante.

---

### Piores Pr√°ticas (O que evitar üëé)

1.  **Sobrescrita excessiva e desnecess√°ria**: N√£o sobrescreva m√©todos apenas por sobrescrever. Se o comportamento padr√£o (herdado de `Enum` ou `Object`) √© suficiente, ou se um m√©todo concreto no `enum` atende a todas as constantes, n√£o h√° necessidade de implementa√ß√µes espec√≠ficas.
2.  **L√≥gica muito complexa dentro de corpos espec√≠ficos de constante**: Se a implementa√ß√£o de um m√©todo para uma constante se torna muito longa ou envolve muitas depend√™ncias, pode ser um indicativo de que essa l√≥gica deveria estar em uma classe separada, e o `enum` poderia delegar a ela. O objetivo √© manter o `enum` coeso.
3.  **Ignorar a necessidade de m√©todos abstratos**: Se voc√™ se encontrar verificando qual √© a constante atual com `if/else` ou `switch` dentro de um m√©todo do `enum` para ent√£o executar l√≥gicas diferentes, provavelmente voc√™ deveria estar usando um m√©todo abstrato (ou um m√©todo concreto com sobrescritas espec√≠ficas da constante).
    ```java
    // Ruim: Usar switch dentro de um m√©todo do enum
    public enum TipoArquivo {
        TEXTO, BINARIO, IMAGEM;

        public String getDescricao() {
            switch (this) { // Evite isso dentro do enum!
                case TEXTO: return "Arquivo de texto simples";
                case BINARIO: return "Arquivo de dados bin√°rios";
                case IMAGEM: return "Arquivo de imagem";
                default: throw new AssertionError();
            }
        }
    }

    // Bom: Usar m√©todo abstrato ou sobrescrita
    public enum TipoArquivoMelhorado {
        TEXTO {
            @Override
            public String getDescricao() { return "Arquivo de texto simples"; }
        },
        BINARIO {
            @Override
            public String getDescricao() { return "Arquivo de dados bin√°rios"; }
        },
        IMAGEM {
            @Override
            public String getDescricao() { return "Arquivo de imagem"; }
        };
        public abstract String getDescricao();
    }
    ```
4.  **Esquecer o ponto e v√≠rgula (`;`)**: Um erro comum que leva a erros de compila√ß√£o quando se adiciona qualquer membro ap√≥s as constantes do `enum`.
5.  **Tentar sobrescrever m√©todos `final` da classe `Enum`**: M√©todos como `ordinal()`, `name()`, `compareTo()`, `equals()`, `hashCode()`, e `getDeclaringClass()` s√£o `final` em `java.lang.Enum` e n√£o podem ser sobrescritos (exceto `toString()`, que √© de `Object`).

A sobrescrita de m√©todos, especialmente com corpos espec√≠ficos da constante, transforma `enums` de simples listas de nomes em tipos de dados altamente especializados e comportamentais, promovendo um c√≥digo mais limpo e orientado a objetos.

[Voltar ao √çndice](#indice)

---


## <a name="parte86">86 - 083 - Orienta√ß√£o Objetos - Enumera√ß√£o pt 04 - Busca por atributos</a>

```java
package dominio;

public enum TipoCliente {
    PESSOA_FISICA(1, "Pessoa Fisica"),
    PESSOA_JURIDICA(2, "Pessoa Juridica");

    private int valor;
    public String nomeRelatorio;

    TipoCliente(int valor, String nomeRelatorio) {
        this.valor = valor;
        this.nomeRelatorio = nomeRelatorio;
    }

    public static TipoCliente tipoClientePorNomeRelatorio(String nomeRelatorio) {
        for (TipoCliente tipoCliente : values()) {
            if (tipoCliente.getNomeRelatorio().equals(nomeRelatorio)) {
                return tipoCliente;
            }
        }
        return null;
```

```java
        TipoCliente tipoCliente1 = TipoCliente.valueOf("PESSOA_FISICA");
        System.out.println(tipoCliente1);

        TipoCliente tipoCliente2 = TipoCliente.tipoClientePorNomeRelatorio("PESSOA_FISICA");
        System.out.println(tipoCliente2);

```


--- 

### Resumo GEMINI

Entendido! O tema agora √© "Busca por atributos" em `enums` Java. Isso √© super √∫til quando voc√™ tem um `enum` com atributos e precisa encontrar uma constante espec√≠fica baseada no valor de um desses atributos (por exemplo, obter um `StatusPedido` a partir de um c√≥digo num√©rico que veio de um banco de dados ou de uma API).

A ideia principal √© criar um m√©todo est√°tico dentro do seu `enum` que permita essa busca.

---
## Busca por Atributos em Enumera√ß√µes Java üîé

Quando suas enumera√ß√µes Java possuem atributos, frequentemente surge a necessidade de obter uma constante espec√≠fica do `enum` com base no valor de um desses atributos. Por exemplo, voc√™ pode ter um `enum` `StatusPedido` com um atributo `codigo`, e precisar encontrar o `StatusPedido` que corresponde a um `codigo` recebido de uma fonte externa.

A abordagem mais comum e recomendada √© implementar um **m√©todo est√°tico** dentro do pr√≥prio `enum` que itere sobre as constantes (usando o m√©todo `values()`) e compare o atributo desejado. Para otimizar buscas em `enums` com muitas constantes, pode-se usar um `Map` est√°tico para um lookup mais r√°pido.

---

### Pontos Principais: Busca por Atributos

1.  **Necessidade**: Surge quando voc√™ tem um valor (ex: um ID, um c√≥digo, uma string descritiva) e precisa encontrar a constante do `enum` que possui esse valor em um de seus atributos.
2.  **M√©todo `values()`**: O m√©todo `values()`, implicitamente dispon√≠vel em todos os `enums`, retorna um array contendo todas as constantes do `enum` na ordem em que foram declaradas. Este array pode ser iterado para realizar a busca.
3.  **M√©todo Est√°tico de Busca**: √â uma conven√ß√£o criar um m√©todo `public static` (por exemplo, `getByCodigo(int codigo)`, `fromString(String texto)`, etc.) dentro do `enum` para encapsular a l√≥gica de busca.
4.  **Tratamento de N√£o Encontrado**: O m√©todo de busca deve definir como lidar com casos onde nenhuma constante corresponde ao valor fornecido (retornar `null`, lan√ßar uma exce√ß√£o como `IllegalArgumentException`, ou retornar um valor padr√£o).
5.  **Otimiza√ß√£o com `Map` (para `enums` grandes)**: Se o `enum` tiver muitas constantes e a performance da busca for cr√≠tica, pode-se inicializar um `Map` est√°tico no `enum` que mapeia o valor do atributo para a constante. Isso oferece uma busca O(1).

---

### Exemplos de C√≥digo

#### Exemplo B√°sico: Buscando Tipo de Pagamento por C√≥digo

```java
public enum TipoPagamento {
    BOLETO(1, "Boleto Banc√°rio"),
    CARTAO_CREDITO(2, "Cart√£o de Cr√©dito"),
    PIX(3, "Pagamento Instant√¢neo (PIX)"),
    TRANSFERENCIA(4, "Transfer√™ncia Banc√°ria");

    private final int codigo;
    private final String descricao;

    TipoPagamento(int codigo, String descricao) {
        this.codigo = codigo;
        this.descricao = descricao;
    }

    public int getCodigo() {
        return codigo;
    }

    public String getDescricao() {
        return descricao;
    }

    // M√©todo est√°tico para buscar por c√≥digo
    public static TipoPagamento getByCodigo(int codigo) {
        for (TipoPagamento tipo : values()) { // Itera sobre todas as constantes
            if (tipo.getCodigo() == codigo) {
                return tipo; // Retorna a constante encontrada
            }
        }
        // Lan√ßa uma exce√ß√£o se o c√≥digo n√£o for encontrado
        throw new IllegalArgumentException("C√≥digo de tipo de pagamento inv√°lido: " + codigo);
        // Alternativamente, poderia retornar null:
        // return null;
    }

    @Override
    public String toString() {
        return descricao;
    }
}

public class TesteBuscaEnum {
    public static void main(String[] args) {
        int codigoRecebido = 3; // Exemplo de c√≥digo vindo de uma API, banco, etc.

        try {
            TipoPagamento tipo = TipoPagamento.getByCodigo(codigoRecebido);
            System.out.println("C√≥digo " + codigoRecebido + " corresponde a: " + tipo);
            // Sa√≠da: C√≥digo 3 corresponde a: Pagamento Instant√¢neo (PIX)

            TipoPagamento tipoInexistente = TipoPagamento.getByCodigo(99); // C√≥digo inv√°lido
            System.out.println(tipoInexistente);

        } catch (IllegalArgumentException e) {
            System.err.println(e.getMessage());
            // Sa√≠da: C√≥digo de tipo de pagamento inv√°lido: 99
        }

        // Exemplo retornando null (se o m√©todo getByCodigo fosse alterado)
        // TipoPagamento tipo2 = TipoPagamento.getByCodigo(99);
        // if (tipo2 == null) {
        //     System.out.println("Tipo de pagamento com c√≥digo 99 n√£o encontrado.");
        // }
    }
}
```

#### Exemplo Otimizado com `Map` Est√°tico: C√≥digo de Moeda

Para `enums` com um n√∫mero maior de constantes, ou quando a performance da busca √© cr√≠tica.

```java
import java.util.Map;
import java.util.HashMap;
import java.util.Optional; // Para um retorno mais elegante de valor opcional

public enum Moeda {
    BRL("BRL", "Real Brasileiro", "R$"),
    USD("USD", "D√≥lar Americano", "$"),
    EUR("EUR", "Euro", "‚Ç¨"),
    GBP("GBP", "Libra Esterlina", "¬£"),
    JPY("JPY", "Iene Japon√™s", "¬•");
    // ... imagine muitas outras moedas

    private final String codigoISO;
    private final String nome;
    private final String simbolo;

    // Mapa est√°tico para lookup r√°pido pelo c√≥digoISO
    private static final Map<String, Moeda> lookupPorCodigoISO = new HashMap<>();

    // Bloco est√°tico para popular o mapa quando o enum √© carregado
    static {
        for (Moeda m : values()) {
            lookupPorCodigoISO.put(m.getCodigoISO(), m);
        }
    }

    Moeda(String codigoISO, String nome, String simbolo) {
        this.codigoISO = codigoISO;
        this.nome = nome;
        this.simbolo = simbolo;
    }

    public String getCodigoISO() {
        return codigoISO;
    }

    public String getNome() {
        return nome;
    }

    public String getSimbolo() {
        return simbolo;
    }

    // M√©todo de busca usando o Map (O(1) em m√©dia)
    public static Moeda getByCodigoISO(String codigoISO) {
        Moeda moeda = lookupPorCodigoISO.get(codigoISO.toUpperCase());
        if (moeda == null) {
            throw new IllegalArgumentException("C√≥digo ISO de moeda inv√°lido: " + codigoISO);
        }
        return moeda;
    }

    // Alternativa usando Optional para evitar exce√ß√µes ou null
    public static Optional<Moeda> findByCodigoISO(String codigoISO) {
        return Optional.ofNullable(lookupPorCodigoISO.get(codigoISO.toUpperCase()));
    }

    @Override
    public String toString() {
        return nome + " (" + simbolo + ")";
    }
}

public class TesteBuscaMoeda {
    public static void main(String[] args) {
        String codigo = "EUR";
        Moeda euro = Moeda.getByCodigoISO(codigo);
        System.out.println("Moeda encontrada: " + euro + ", S√≠mbolo: " + euro.getSimbolo());
        // Sa√≠da: Moeda encontrada: Euro (‚Ç¨), S√≠mbolo: ‚Ç¨

        Optional<Moeda> ieneOpt = Moeda.findByCodigoISO("JPY");
        ieneOpt.ifPresent(moeda -> System.out.println("Moeda (Optional): " + moeda.getNome()));
        // Sa√≠da: Moeda (Optional): Iene Japon√™s

        Optional<Moeda> inexistenteOpt = Moeda.findByCodigoISO("XYZ");
        if (inexistenteOpt.isEmpty()) {
            System.out.println("Moeda XYZ n√£o encontrada via Optional.");
            // Sa√≠da: Moeda XYZ n√£o encontrada via Optional.
        }

        try {
            Moeda.getByCodigoISO("ABC");
        } catch (IllegalArgumentException e) {
            System.err.println(e.getMessage());
            // Sa√≠da: C√≥digo ISO de moeda inv√°lido: ABC
        }
    }
}
```

---

### Melhores Pr√°ticas (O que fazer üëç)

1.  **Crie m√©todos est√°ticos de busca nomeados claramente**: Nomes como `getByCodigo()`, `fromValor()`, `valueOfLabel()` s√£o mais descritivos do que um `valueOf()` sobrecarregado (que j√° existe para buscar pelo nome da constante).
2.  **Seja consistente no tratamento de n√£o encontrados**: Escolha uma estrat√©gia (lan√ßar exce√ß√£o, retornar `null`, ou retornar `Optional`) e aplique-a consistentemente. Lan√ßar `IllegalArgumentException` √© comum se o valor de entrada *deveria* corresponder a uma constante. Retornar `Optional<MeuEnum>` (Java 8+) √© uma forma moderna e segura de lidar com valores que podem n√£o existir.
3.  **Use um `Map` est√°tico para `enums` grandes ou buscas frequentes**: Para melhorar a performance, pr√©-calcule um `Map` que mapeia o atributo de busca para a constante do `enum`. Isso √© feito em um bloco de inicializa√ß√£o est√°tico.
4.  **Torne os atributos do `enum` `final`**: Isso garante que os valores pelos quais voc√™ est√° buscando n√£o mudem, mantendo a consist√™ncia do `Map` de lookup, se usado.
5.  **Considere a sensibilidade a mai√∫sculas/min√∫sculas (case sensitivity)**: Se estiver buscando por um atributo `String` (como um c√≥digo ou descri√ß√£o), decida se a busca deve ser case-sensitive ou n√£o, e normalize a entrada e/ou os valores armazenados no `Map` (ex: usando `toUpperCase()` ou `toLowerCase()`).

---

### Piores Pr√°ticas (O que evitar üëé)

1.  **Expor a l√≥gica de itera√ß√£o fora do `enum`**: Clientes do `enum` n√£o deveriam ter que escrever o loop `for (MeuEnum e : MeuEnum.values())` repetidamente. Encapsule essa l√≥gica dentro de um m√©todo est√°tico no pr√≥prio `enum`.
2.  **Depender de `ordinal()` para busca**: O `ordinal()` representa a posi√ß√£o de declara√ß√£o e √© fr√°gil. Se a ordem mudar, a busca baseada em `ordinal()` quebrar√°. Sempre use um atributo expl√≠cito para a busca.
3.  **Modificar o `Map` de lookup ap√≥s a inicializa√ß√£o**: Se voc√™ usar um `Map` est√°tico para lookup, ele deve ser populado uma vez no bloco est√°tico e depois tratado como imut√°vel.
4.  **N√£o tratar o caso de valor n√£o encontrado**: Se o m√©todo de busca simplesmente retornar `null` sem uma documenta√ß√£o clara ou se o c√≥digo cliente n√£o verificar o `null`, isso pode levar a `NullPointerExceptions`.
5.  **Performance ruim com `enums` muito grandes e buscas lineares frequentes**: Se um `enum` tem centenas de constantes e voc√™ est√° buscando por atributo em um loop `for` muitas vezes em uma se√ß√£o cr√≠tica de performance, a inicializa√ß√£o de um `Map` est√°tico √© uma otimiza√ß√£o importante a ser considerada.
6.  **Nomes de m√©todo de busca gen√©ricos ou confusos**: Um m√©todo chamado `get(Object value)` pode ser amb√≠guo se o `enum` tiver m√∫ltiplos atributos pelos quais se poderia buscar.

Ao implementar m√©todos de busca por atributos, seus `enums` se tornam mais f√°ceis de usar e integrar com outras partes do sistema que podem n√£o conhecer as constantes do `enum` diretamente, mas sim seus valores de atributo.

---

**Sim, para os cen√°rios que os exemplos dados ilustram, usar `enum` da maneira como foi mostrado √© geralmente considerado uma √≥tima pr√°tica em Java e, em muitos casos, a melhor maneira de tratar esses dados.**

Vamos recapitular o porqu√™ e depois discutir quando alternativas podem ser mais adequadas:

### Por que `enum` √© bom para esses casos?

1.  **Seguran√ßa de Tipo (Type Safety)**: `Enum` garante que voc√™ s√≥ pode usar os valores definidos. Voc√™ n√£o pode acidentalmente passar um inteiro ou string inv√°lido, como aconteceria com constantes `public static final int` ou `String`. Isso elimina uma classe inteira de bugs em tempo de compila√ß√£o.
2.  **Conjunto Fixo e Conhecido**: `Enums` s√£o ideais quando voc√™ tem um n√∫mero limitado e bem definido de constantes que s√£o conhecidas em tempo de compila√ß√£o (ex: dias da semana, status de um pedido, tipos de pagamento, opera√ß√µes matem√°ticas fixas).
3.  **Legibilidade e Manutenibilidade**: O c√≥digo fica mais claro e f√°cil de entender. `StatusPedido.APROVADO` √© muito mais expressivo do que `pedido.setStatus(1)`.
4.  **Capacidade de Adicionar Atributos e Comportamento**:
    * **Atributos**: Permitem que cada constante do `enum` carregue dados espec√≠ficos (ex: `TipoPagamento.BOLETO` com `codigo = 1` e `descricao = "Boleto Banc√°rio"`).
    * **Construtores**: Gerenciam a inicializa√ß√£o desses atributos.
    * **M√©todos**: Permitem que cada constante tenha seu pr√≥prio comportamento ou que o `enum` como um todo forne√ßa funcionalidades √∫teis (ex: `Operacao.SOMA.executar(a, b)` ou `TipoPagamento.getByCodigo(int codigo)`). A sobrescrita de m√©todos para comportamento espec√≠fico da constante √© um recurso poderoso.
5.  **Integra√ß√£o com a Linguagem**:
    * Funcionam bem em instru√ß√µes `switch`.
    * `EnumSet` e `EnumMap` s√£o cole√ß√µes altamente otimizadas para `enums`.
    * S√£o naturalmente serializ√°veis (com ressalvas se a estrutura do `enum` mudar).

### Quando `enum` √© a melhor escolha (como nos exemplos)?

* **Representar estados finitos**: Status de um pedido, n√≠veis de prioridade, modos de opera√ß√£o.
* **Representar um conjunto fixo de op√ß√µes**: Tipos de documento, categorias de produtos (se forem fixas), dias da semana, naipes de baralho.
* **Implementar o padr√£o Strategy de forma simples**: Como no exemplo de `Operacao`, onde cada constante implementava um m√©todo `executar` de forma diferente.
* **Substituir "magic numbers" ou constantes de string**: Para c√≥digos de erro, tipos de mensagem, etc., onde cada valor tem um significado espec√≠fico.
* **Facilitar buscas seguras**: O m√©todo `getByAtributo()` que discutimos √© um exemplo de como `enums` podem fornecer uma maneira robusta e segura de converter dados externos (como um ID de banco de dados) para um tipo seguro em Java.

### Quando considerar alternativas ou abordagens diferentes?

Apesar de todas as vantagens, existem cen√°rios onde `enums` podem n√£o ser a melhor solu√ß√£o, ou onde seu uso excessivo pode complicar as coisas:

1.  **Dados Din√¢micos ou Carregados do Banco de Dados**:
    * Se o conjunto de "constantes" n√£o √© fixo e precisa ser carregado de um banco de dados, arquivo de configura√ß√£o, ou pode ser alterado pelo usu√°rio em tempo de execu√ß√£o, `enums` n√£o s√£o adequados porque s√£o definidos em tempo de compila√ß√£o.
    * **Alternativa**: Use classes normais (POJOs) e carregue inst√¢ncias a partir do banco (ex: uma tabela de "Tipos de Cliente" que pode ser editada). Um padr√£o Factory ou um Service Layer podem ser usados para buscar esses objetos.

2.  **N√∫mero Muito Grande de "Constantes"**:
    * Se voc√™ tem milhares de "constantes" potenciais, um `enum` pode se tornar pesado, pois todas as inst√¢ncias s√£o carregadas na mem√≥ria quando a classe do `enum` √© inicializada.
    * **Alternativa**: Novamente, uma tabela de banco de dados com busca sob demanda pode ser mais eficiente.

3.  **Necessidade de Heran√ßa Complexa**:
    * `Enums` implicitamente herdam de `java.lang.Enum` e n√£o podem herdar de outra classe. Eles podem implementar interfaces, o que √© muito √∫til, mas se voc√™ precisa de uma hierarquia de classes com estado e comportamento herdados de uma superclasse que n√£o seja `Enum`, ent√£o classes regulares s√£o o caminho.

4.  **L√≥gica Excessivamente Complexa nos Enums**:
    * Se os m√©todos dentro do seu `enum` (especialmente os espec√≠ficos de cada constante) come√ßam a ficar muito grandes e complexos, manipulando muitas depend√™ncias ou l√≥gica de neg√≥cios extensa, pode ser um sinal de que o `enum` est√° assumindo responsabilidades demais.
    * **Alternativa**: O `enum` ainda pode ser usado para representar os diferentes tipos ou estrat√©gias, mas a l√≥gica complexa pode ser delegada para classes separadas (padr√£o Strategy mais expl√≠cito, onde o `enum` apenas aponta para a inst√¢ncia da estrat√©gia correta).

5.  **"Constantes" que s√£o mais Entidades do Dom√≠nio**:
    * Se os itens que voc√™ est√° tentando modelar t√™m um ciclo de vida pr√≥prio, relacionamentos complexos com outras entidades, ou precisam ser gerenciados por um ORM de forma mais completa, eles provavelmente s√£o mais "entidades" do que "constantes" e devem ser modelados como classes Java normais.

### Conclus√£o

**Para os exemplos que vimos (como `TipoPagamento`, `Operacao`, `StatusPedido`, `DiaDaSemana` com atributos e m√©todos de busca/comportamento), `enums` s√£o, sim, uma abordagem excelente e recomendada em Java.** Eles oferecem uma combina√ß√£o poderosa de seguran√ßa de tipo, clareza e capacidade de encapsular dados e comportamento.

A chave √© reconhecer a natureza dos dados que voc√™ est√° modelando:

* **√â um conjunto pequeno, finito e fixo de valores conceituais?** `Enum` √© provavelmente o ideal.
* **Os valores podem mudar, s√£o muitos, v√™m de uma fonte externa din√¢mica, ou precisam de uma estrutura de heran√ßa complexa?** Classes regulares, possivelmente com dados de um banco, s√£o uma escolha melhor.

√â √≥timo que voc√™ esteja fazendo essa pergunta, pois entender as nuances e os limites de cada ferramenta √© fundamental para se tornar um bom desenvolvedor! Os `enums` em Java s√£o muito mais poderosos do que em algumas outras linguagens onde s√£o apenas apelidos para inteiros; em Java, eles s√£o verdadeiras classes.

[Voltar ao √çndice](#indice)

---


## <a name="parte87">87 - 084 - Orienta√ß√£o Objetos - Classes abstratas pt 01</a>

- https://www.youtube.com/watch?v=ws1NVBGeegs&list=PL62G310vn6nFIsOCC0H-C2infYgwm8SWW&index=86


[Voltar ao √çndice](#indice)

---


## <a name="parte88">88 - 085 - Orienta√ß√£o Objetos - Classes abstratas pt 02 - M√©todos abstratos</a>

- https://www.youtube.com/watch?v=j97OEyzBcKI




[Voltar ao √çndice](#indice)

---


## <a name="parte89">89 - 086 - Orienta√ß√£o Objetos - Classes abstratas pt 03 - M√©todos abstratos regras</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte90">90 - 087 - Orienta√ß√£o Objetos - Interfaces pt 01 - Introdu√ß√£o</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte91">91 - 088 - Orienta√ß√£o Objetos - Interfaces pt 02 - Implementando m√∫ltiplas interfaces</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte92">92 - 089 - Orienta√ß√£o Objetos - Interfaces pt 03 - Atributos e m√©todos est√°ticos</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte93">93 - 090 - Orienta√ß√£o Objetos - Polimorfismo pt 01 - Introdu√ß√£o</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte94">94 - 091 - Orienta√ß√£o Objetos - Polimorfismo pt 02 - Funcionamento</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte95">95 - 092 - Orienta√ß√£o Objetos - Polimorfismo pt 03 - Par√¢metros polim√≥rficos</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte96">96 - 093 - Orienta√ß√£o Objetos - Polimorfismo pt 04 - Cast e instanceof</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte97">97 - 094 - Orienta√ß√£o Objetos - Polimorfismo pt 05 - Programa√ß√£o orientada a interface</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte98">98 - 095 - Exce√ß√µes pt 01 - Errors</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte99">99 - 096 - Exce√ß√µes pt 02 - RuntimeException</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte100">100 - 097 - Exce√ß√µes pt 03 - Exception</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte101">101 - 098 - Exce√ß√µes pt 04 - Lan√ßando exce√ß√£o unchecked</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte102">102 - 099 - Exce√ß√µes pt 05 - Lan√ßando exce√ß√£o checked</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte103">103 - 100 - Exce√ß√µes pt 06 - Bloco Finally</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte104">104 - 101 - Exce√ß√µes pt 07 - Capturando m√∫ltiplas exce√ß√µes</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte105">105 - 102 - Exce√ß√µes pt 08 - Multi catch em linha</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte106">106 - 103 - Exce√ß√µes pt 09 - Try with resources</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte107">107 - 104 - Exce√ß√µes pt 10 - Exce√ß√£o customizada</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte108">108 - 105 - Exce√ß√µes pt 11 - Exce√ß√£o e regras de sobrescrita</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte109">109 - 106 - Classes Utilit√°rias - Wrappers pt 01</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte110">110 - 107 - Classes Utilit√°rias - Wrappers pt 02</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte111">111 - 108 - Classes Utilit√°rias - Strings pt 01</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte112">112 - 109 - Classes Utilit√°rias - Strings pt 02</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte113">113 - 110 - Classes Utilit√°rias - Strings pt 03 - Desempenho</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte114">114 - 111 - Classes Utilit√°rias - Strings pt 04 - StringBuilder</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte115">115 - 112 - Classes Utilit√°rias - Date</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte116">116 - 113 - Classes Utilit√°rias - Calendar</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte117">117 - 114 - Classes Utilit√°rias - DateFormat</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte118">118 - 115 - Classes Utilit√°rias - Internacionaliza√ß√£o Datas com Locale</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte119">119 - 116 - Classes Utilit√°rias - Internacionaliza√ß√£o N√∫meros com Locale</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte120">120 - 117 - Classes Utilit√°rias - Internacionaliza√ß√£o de moeda com Locale</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte121">121 - 118 - Classes Utilit√°rias - SimpleDateFormat</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte122">122 - 119 - Classes Utilit√°rias - LocalDate</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte123">123 - 120 - Classes Utilit√°rias - LocalTime</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte124">124 - 121 - Classes Utilit√°rias - LocalDateTime</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte125">125 - 122 - Classes Utilit√°rias - Instant</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte126">126 - 123 - Classes Utilit√°rias - Duration</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte127">127 - 124 - Classes Utilit√°rias - Period</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte128">128 - 125 - Classes Utilit√°rias - ChronoUnit</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte129">129 - 126 - Classes Utilit√°rias - TemporalAdjusters</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte130">130 - 127 - Classes Utilit√°rias - TemporalAdjuster</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte131">131 - 128 - Classes Utilit√°rias - ZonedDateTime, ZoneId, OffsetDateTime</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte132">132 - 129 - Classes Utilit√°rias - DateTimeFormatter</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte133">133 - 130 - Classes Utilit√°rias - ResourceBundle</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte134">134 - 131 - Classes Utilit√°rias - Regex pt 01 - Pattern e Matcher</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte135">135 - 132 - Classes Utilit√°rias - Regex pt 02 - Pattern e Matcher - Meta caracteres</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte136">136 - 133 - Classes Utilit√°rias - Regex pt 03 - Pattern e Matcher - Range</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte137">137 - 134 - Classes Utilit√°rias - Regex pt 04 - Pattern e Matcher - Quantificadores pt 01</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte138">138 - 135 - Classes Utilit√°rias - Regex pt 05 - Pattern e Matcher - Quantificadores pt 02</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte139">139 - 136 - Classes Utilit√°rias - Regex pt 06 - Pattern e Matcher - Anchor</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte140">140 - 137 - Classes Utilit√°rias - Scanner - Tokens e Delimitadores</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte141">141 - 138 - Classes Utilit√°rias - IO pt 01 - File</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte142">142 - 139 - Classes Utilit√°rias - IO pt 02 - FileWriter</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte143">143 - 140 - Classes Utilit√°rias - IO pt 03 - FileReader</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte144">144 - 141 - Classes Utilit√°rias - IO pt 04 - BufferedWriter</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte145">145 - 142 - Classes Utilit√°rias - IO pt 05 - BufferedReader</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte146">146 - 143 - Classes Utilit√°rias - IO pt 06 - File para diret√≥rios</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte147">147 - 144 - Classes Utilit√°rias - NIO pt 01 - Path, Paths, Files pt 01</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte148">148 - 145 - Classes Utilit√°rias - NIO pt 02 - Path, Paths, Files pt 02</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte149">149 - 146 - Classes Utilit√°rias - NIO pt 03 - Normaliza√ß√£o</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte150">150 - 147 - Classes Utilit√°rias - NIO pt 04 - Resolvendo Paths</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte151">151 - 148 - Classes Utilit√°rias - NIO pt 05 - Relativize</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte152">152 - 149 - Classes Utilit√°rias - NIO pt 06 - BasicFileAttributes pt 01</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte153">153 - 150 - Classes Utilit√°rias - NIO pt 07 - BasicFileAttributes pt 02</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte154">154 - 151 - Classes Utilit√°rias - NIO pt 08 - DosFileAttribute</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte155">155 - 152 - Classes Utilit√°rias - NIO pt 09 - PosixFileAttributes</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte156">156 - 153 - Classes Utilit√°rias - NIO pt 10 - DirectoryStream</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte157">157 - 154 - Classes Utilit√°rias - NIO pt 11 - SimpleFileVisitor pt 01</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte158">158 - 155 - Classes Utilit√°rias - NIO pt 12 - SimpleFileVisitor pt 02</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte159">159 - 156 - Classes Utilit√°rias - NIO pt 13 - PathMatcher pt 01</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte160">160 - 157 - Classes Utilit√°rias - NIO pt 14 - PathMatcher pt 02</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte161">161 - 158 - Classes Utilit√°rias - NIO pt 15 - ZipOutputStream</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte162">162 - 159 - Classes Utilit√°rias - Serialization pt 01</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte163">163 - 160 - Classes Utilit√°rias - Serialization pt 02</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte164">164 - 161 - Cole√ß√µes pt 01 - equals pt 01</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte165">165 - 162 - Cole√ß√µes pt 02 - equals pt 02</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte166">166 - 163 - Cole√ß√µes pt 03 - hashCode pt 01</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte167">167 - 164 - Cole√ß√µes pt 04 - hashCode pt 02</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte168">168 - 165 - Cole√ß√µes pt 05 - Complexidade Big-O</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte169">169 - 166 - Cole√ß√µes pt 06 - List pt 01</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte170">170 - 167 - Cole√ß√µes pt 07 - List pt 02</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte171">171 - 168 - Cole√ß√µes pt 08 - List pt 03</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte172">172 - 169 - Cole√ß√µes pt 09 - Sorting lists pt 01</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte173">173 - 170 - Cole√ß√µes pt 10 - Sorting lists pt 02 - Comparable</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte174">174 - 171 - Cole√ß√µes pt 11 - Sorting lists pt 03 - Comparator</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte175">175 - 172 - Cole√ß√µes pt 12 - Binary Search</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte176">176 - 173 - Cole√ß√µes pt 13 - Convers√£o de Lista para Arrays e vice versa</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte177">177 - 174 - Cole√ß√µes pt 14 - Iterator</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte178">178 - 175 - Cole√ß√µes pt 15 - Set, HashSet</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte179">179 - 176 - Cole√ß√µes pt 16 - NavigableSet, TreeSet pt 01</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte180">180 - 177 - Cole√ß√µes pt 17 - NavigableSet, TreeSet pt 02</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte181">181 - 178 - Cole√ß√µes pt 18 - Map, HashMap, LinkedHashMap pt 01</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte182">182 - 179 - Cole√ß√µes pt 19 - Map, HashMap, LinkedHashMap pt 02</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte183">183 - 180 - Cole√ß√µes pt 20 - Map, HashMap, LinkedHashMap pt 03</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte184">184 - 181 - Cole√ß√µes pt 21 - NavigableMap, TreeMap</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte185">185 - 182 - Cole√ß√µes pt 22 - Queue, PriorityQueue</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte186">186 - 183 - Generics pt 01 - Introdu√ß√£o</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte187">187 - 184 - Generics pt 02 - Wildcard pt 01</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte188">188 - 185 - Generics pt 03 - Wildcard pt 02</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte189">189 - 186 - Generics pt 04 - Classes Gen√©ricas pt 01</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte190">190 - 187 - Generics pt 05 - Classes Gen√©ricas pt 02</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte191">191 - 188 - Generics pt 06 - M√©todos Gen√©ricos</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte192">192 - 189 - Classes Internas pt 01 - Classes aninhadas</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte193">193 - 190 - Classes Internas pt 02 - Classes Locais</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte194">194 - 191 - Classes Internas pt 03 - Classes An√¥nimas</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte195">195 - 192 - Classes Internas pt 04 - Classes aninhadas est√°ticas</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte196">196 - 193 - Parametrizando comportamentos pt 01</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte197">197 - 194 - Parametrizando comportamentos pt 02</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte198">198 - 195 - Lambdas pt 01 - Predicate</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte199">199 - 196 - Lambdas pt 02 - Consumer</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte200">200 - 197 - Lambdas pt 03 - Function</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte201">201 - 198 - Method Reference pt 01 - Refer√™ncia a m√©todos est√°ticos</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte202">202 - 199 - Method Reference pt 02 - Refer√™ncia a m√©todos n√£o est√°ticos</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte203">203 - 200 - Method Reference pt 03 - Refer√™ncia a construtor</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte204">204 - 201 - Optional pt 01</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte205">205 - 202 - Optional pt 02</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte206">206 - 203 - Streams pt 01 - Introduction pt 01</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte207">207 - 204 - Streams pt 02 - Introduction pt 02</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte208">208 - 205 - Streams pt 03 - Introduction pt 03</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte209">209 - 206 - Streams pt 04 - FlatMap pt 01</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte210">210 - 207 - Streams pt 05 - FlatMap pt 02</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte211">211 - 208 - Streams pt 06 - Finding and Matching</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte212">212 - 209 - Streams pt 07 - Reduce pt 01</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte213">213 - 210 - Streams pt 08 - Reduce pt 02</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte214">214 - 211 - Streams pt 09 - Gerando streams pt 01</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte215">215 - 212 - Streams pt 10 - Gerando streams pt 02</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte216">216 - 213 - Streams pt 11 - Collectors pt 01 - Summarizing</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte217">217 - 214 - Streams pt 12 - Collectors pt 02 - Grouping by pt 01</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte218">218 - 215 - Streams pt 13 - Collectors pt 03 - Grouping by pt 02</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte219">219 - 216 - Streams pt 14 - Collectors pt 04 - Grouping by pt 03</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte220">220 - 217 - Streams pt 15 - Collectors pt 05 - Grouping by pt 04</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte221">221 - 218 - Streams pt 16 - Parallel Streams pt 01</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte222">222 - 219 - Streams pt 17 - Parallel Streams pt 02</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte223">223 - 220 - Threads pt 01 - Introduction</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte224">224 - 221 - Threads pt 02 - Estados das threads</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte225">225 - 222 - Threads pt 03 - Prioridade e Sleep</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte226">226 - 223 - Threads pt 04 - Yield e Join</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte227">227 - 224 - Threads pt 05 - Sincronismo de thread pt 01</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte228">228 - 225 - Threads pt 06 - Sincronismo de thread pt 02</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte229">229 - 226 - Threads pt 07 - Sincronismo de thread pt 03 - Classes thread safe</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte230">230 - 227 - Threads pt 08 - Sincronismo de thread pt 04 - Deadlock</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte231">231 - 228 - Threads pt 09 - Sincronismo de thread pt 05 - Wait, notify e notifyAll</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte232">232 - 229 - Concorr√™ncia pt 01 - AtomicInteger</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte233">233 - 230 - Concorr√™ncia pt 02 - Lock and ReentrantLock</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte234">234 - 231 - Concorr√™ncia pt 03 - Conditions</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte235">235 - 232 - Concorr√™ncia pt 04 - ReentrantReadWriteLock</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte236">236 - 233 - Concorr√™ncia pt 05 - CopyOnWriteArrayList</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte237">237 - 234 - Concorr√™ncia pt 06 - ArrayBlockingQueue</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte238">238 - 235 - Concorr√™ncia pt 07 - LinkedTransferQueue</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte239">239 - 236 - Concorr√™ncia pt 08 - Executors pt 01 - Thread Pools</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte240">240 - 237 - Concorr√™ncia pt 09 - Executors pt 02 - ScheduledExecutorService</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte241">241 - 238 - Concorr√™ncia pt 10 - Executors pt 03 - Interface Callable</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte242">242 - 239 - Concorr√™ncia pt 11 - Executors pt 04 - Future</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte243">243 - 240 - Concorr√™ncia pt 12 - CompletableFuture pt 01 - get and join</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte244">244 - 241 - Concorr√™ncia pt 13 - CompletableFuture pt 02 - streams</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte245">245 - 242 - Concorr√™ncia pt 14 - CompletableFuture pt 03 - ThreadFactory</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte246">246 - 243 - Concorr√™ncia pt 15 - CompletableFuture pt 04 - Encadeando chamadas pt 01</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte247">247 - 244 - Concorr√™ncia pt 16 - CompletableFuture pt 05 - Encadeando chamadas pt 02</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte248">248 - 245 - Concorr√™ncia pt 17 - CompletableFuture pt 06 - allOf, anyOf</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte249">249 - 246 - Padr√µes de Projeto pt 01 - Builder</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte250">250 - 247 - Padr√µes de Projeto pt 02 - Factory</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte251">251 - 248 - Padr√µes de Projeto pt 03 - Singleton pt 01 - Eager Initialization</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte252">252 - 249 - Padr√µes de Projeto pt 04 - Singleton pt 02 - Lazy Initialization</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte253">253 - 250 - Padr√µes de Projeto pt 05 - Singleton pt 03 - Singleton with enumeration</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte254">254 - 251 - Padr√µes de Projeto pt 06 - Data Transfer Object</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte255">255 - 252 - JDBC pt 01 - Instalando Docker</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte256">256 - 253 - JDBC pt 02 - Criando container MySQL</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte257">257 - 254 - JDBC pt 03 - Instalando Workbench, criando schema e tabelas</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte258">258 - 255 - JDBC pt 04 - Instalando e adicionando maven ao projeto</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte259">259 - 256 - JDBC pt 05 - Adicionando depend√™ncia e conectando com banco</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte260">260 - 257 - JDBC pt 06 - Inserindo dados com Statement</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte261">261 - 258 - JDBC pt 07 - Lombok e Log4J2</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte262">262 - 259 - JDBC pt 08 - Deletando dados com Statement</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte263">263 - 260 - JDBC pt 09 - Atualizando dados com Statement</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte264">264 - 261 - JDBC pt 10 - Buscando dados com ResultSet pt 01 - findAll</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte265">265 - 262 - JDBC pt 11 - Buscando dados com ResultSet pt 02 - findByName</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte266">266 - 263 - JDBC pt 12 - ResultSetMetaData</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte267">267 - 264 - JDBC pt 13 - DatabaseMetaData</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte268">268 - 265 - JDBC pt 14 - ResultSet.TYPE_SCROLL_INSENSITIVE</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte269">269 - 266 - JDBC pt 15 - Atualizando registros com ResultSet</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte270">270 - 267 - JDBC pt 16 - Inserindo e deletando registros com ResultSet</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte271">271 - 268 - JDBC pt 17 - PreparedStatement pt 01</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte272">272 - 269 - JDBC pt 18 - PreparedStatement pt 02</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte273">273 - 270 - JDBC pt 19 - CallableStatement</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte274">274 - 271 - JDBC pt 20 - Connected RowSet - JdbcRowSet pt 01</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte275">275 - 272 - JDBC pt 21 - Connected RowSet - JdbcRowSet pt 02</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte276">276 - 273 - JDBC pt 22 - Disconnected RowSet - CachedRowSet</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte277">277 - 274 - JDBC pt 23 - Transa√ß√£o</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte278">278 - 275 - JDBC pt 24 - CRUD pt 01 - findByName and findAll</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte279">279 - 276 - JDBC pt 25 - CRUD pt 02 - delete</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte280">280 - 277 - JDBC pt 26 - CRUD pt 03 - save</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte281">281 - 278 - JDBC pt 27 - CRUD pt 04 - update</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte282">282 - 279 - JDBC pt 28 - CRUD pt 05 - Anime Crud</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte283">283 - 280 - Testes unit√°rios com jUnit pt 01</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte284">284 - 281 - Testes unit√°rios com jUnit pt 02</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte285">285 - 282 - Atualizando JDK</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte286">286 - 283 - Record Class</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte287">287 - 284 - Pattern Matching for instanceof</a>



[Voltar ao √çndice](#indice)

---


## <a name="parte288">288 - 285 - √â s√≥ correr pro abra√ßo</a>



[Voltar ao √çndice](#indice)

---